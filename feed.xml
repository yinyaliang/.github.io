<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2022-09-06T14:28:01+08:00</updated><id>/feed.xml</id><title type="html">尹亚亮</title><subtitle>An amazing website.</subtitle><author><name>Your Name</name></author><entry><title type="html">bcc c 环境部署</title><link href="/bcc-01/" rel="alternate" type="text/html" title="bcc c 环境部署" /><published>2022-08-29T00:00:00+08:00</published><updated>2022-08-29T00:00:00+08:00</updated><id>/bcc-01</id><content type="html" xml:base="/bcc-01/"><![CDATA[<h4 id="下载kernel">下载kernel</h4>

<p>查看系统版本</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
root@yinyaliang-virtual-machine:/usr/src# uname -r

5.8.0-43-generic

</code></pre></div></div>

<p>下载对应版本</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/v5.x/

</code></pre></div></div>

<p>解压放在/usr/src目录下</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@yinyaliang-virtual-machine:/usr/src# ll

total 176612

drwxr-xr-x  5 root       root            4096 7月   8 20:06 ./

drwxr-xr-x 14 root       root            4096 2月  10 02:48 ../

drwxrwxr-x 24 root       root            4096 8月   3  2020 linux-5.8/

-rwxrw-rw-  1 yinyaliang yinyaliang 180827693 7月   1 20:07 linux-5.8.tar.gz*

drwxr-xr-x  7 root       root            4096 2月  10 02:50 linux-headers-5.8.0-43-generic/

drwxr-xr-x 24 root       root            4096 2月  10 02:50 linux-hwe-5.8-headers-5.8.0-43/
</code></pre></div></div>

<h4 id="安装依赖">安装依赖</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apt install libncurses5-dev flex bison libelf-dev binutils-dev libssl-dev 

</code></pre></div></div>

<h4 id="安装clang和llvm">安装clang和llvm</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apt install clang llvm

</code></pre></div></div>

<h4 id="配置内核">配置内核</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd /usr/src/linux-5.8 &amp;&amp; make defconfig

</code></pre></div></div>

<h4 id="解决modpost-not-found-错误">解决modpost: not found 错误</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make modules_prepare 或者  make scripts

</code></pre></div></div>

<h4 id="关联内核头文件">关联内核头文件</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make headers_install

</code></pre></div></div>

<h4 id="编译内核bpf程序样例">编译内核BPF程序样例</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make M=samples/bpf/

</code></pre></div></div>]]></content><author><name>Your Name</name></author><category term="BCC" /><summary type="html"><![CDATA[下载kernel]]></summary></entry><entry><title type="html">路由交换 - BGP案例 - 04</title><link href="/rs-bgp-04/" rel="alternate" type="text/html" title="路由交换 - BGP案例 - 04" /><published>2022-08-28T00:00:00+08:00</published><updated>2022-08-28T00:00:00+08:00</updated><id>/rs-bgp-04</id><content type="html" xml:base="/rs-bgp-04/"><![CDATA[<p>BGP案例04
(参考https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/26634-bgp-toc.html#neighborsroutemaps)</p>

<h3 id="cidr-and-aggregate-addresses">CIDR and Aggregate Addresses</h3>
<p><img src="/assets/images/bgp/b26.png" /></p>

<p>BGP4对BGP3的主要增强之一是无类域间路由(CIDR)。CIDR或supernet是一种查看IP地址的新方法。对于CIDR，没有类的概念，比如类A、B或C。例如，网络192.213.0.0曾经是一个非法的C类网络。现在，这个网络是一个合法的supernet，192.213.0 /16。“16”表示子网掩码中的比特数，当您从IP地址的最左边开始计数时。这个表示类似于192.213.0.0 255.255.0.0</p>

<p>使用聚合是为了最小化路由表的大小。聚合是将多个不同路由的特性组合在一起的过程，从而使单个路由的宣告成为可能。在本例中，RTB生成网络160.10.0.0。将RTC配置为将该路由的超网络160.0.0.0传播到RTA</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTB# 
router bgp 200 
neighbor 3.3.3.1 remote-as 300 
network 160.10.0.0 

<span class="c">#RTC </span>
router bgp 300 
neighbor 3.3.3.3 remote-as 200 
neighbor 2.2.2.2 remote-as 100 
network 170.10.0.0 
aggregate-address 160.0.0.0 255.0.0.0
</code></pre></div></div>

<p>RTC将聚合地址160.0.0.0传播到RTA</p>

<h3 id="aggregate-commands">Aggregate Commands</h3>

<p>聚合命令的范围很广。为了完成聚合的操作，必须了解每个组件是如何工作的</p>

<p>第一个使本节示例中的命令 <a href="https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/26634-bgp-toc.html#cidragg">CIDR and Aggregate Addresses</a></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aggregate-address address-mask
</code></pre></div></div>

<p>这个命令通知前缀路由和所有更具体的路由。命令 aggregate-address 160.0.0.0传播一个网络160.0.0.0，但不阻止将160.10.0.0传播到RTA。结果是两个网络都将160.0.0.0和160.10.0.0传播到RTA</p>

<blockquote>
  <p>如果在BGP路由表中没有该地址的明细路由，聚合就会失效</p>
</blockquote>

<p>例如，如果RTB在BGP表中没有关于160.0.0.0的明细路由，则RTB不能生成160.0.0.0的聚合。将更具体的路由注入到BGP表是可能的。路由注入可以通过</p>

<ul>
  <li>来自其它AS的更新</li>
  <li>从IGP或者静态路由重分布进入BGP</li>
  <li>使用network命令，例如 network 160.10.0.0</li>
</ul>

<p>如果你想RTC不宣告明细路由只宣告网络160.0.0.0</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aggregate-address address mask summary-only
</code></pre></div></div>

<p>这个命令只对前缀做宣告。该命令抑制所有的明细路由</p>

<p>命令 aggregate 160.0.0.0 255.0.0.0 summary-only 只传播网络160.0.0.0，并抑制160.10.0.0里的明细路由</p>

<blockquote>
  <p>如果通过network语句聚合一个网络到BGP中，这个网络会一直存在在BGP的更新中，甚至使用aggregate summary-only命令，路由也会存在， <a href="https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/26634-bgp-toc.html#cidrex1">CIDR Example 1</a>   讨论了这个情况</p>
</blockquote>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aggregate-address address-mask as-set
</code></pre></div></div>

<p>这个命令宣告前缀和更精确的路由。但是该命令在路由更新的路径信息中包含 as-set的信息</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aggregate 129.0.0.0 255.0.0.0 as-set
</code></pre></div></div>
<p><a href="https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/26634-bgp-toc.html#ex2"> CIDR Example 2 (as-set) </a> 讨论了这个命令</p>

<p>如果希望在进行聚合时抑制特定的路由，请定义route map并将route map应用于聚合。该操作允许选择要抑制哪些更具体的路由</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aggregate-address address-mask suppress-map map-name
</code></pre></div></div>

<p>这个命令宣告前缀和更精确的路由。但命令以route map 为基础抑制宣告。假设，  <a href="https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/26634-bgp-toc.html#cidragg">CIDR and Aggregate Addresses</a>  的图中，希望聚合160.0.0.0，抑制路由160.20.0.0，并允许传播160.10.0.0。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>route-map CHECK permit 10 
match ip address 1 

access-list 1 permit 160.20.0.0 0.0.255.255 
access-list 1 deny 0.0.0.0 255.255.255.255
</code></pre></div></div>

<p>suppress-map,对访问控制列表允许的任何包都会有抑制的效果</p>

<p>应用route map到 aggregate部分</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTC# 
router bgp 300 
neighbor 3.3.3.3 remote-as 200 
neighbor 2.2.2.2 remote-as 100 
neighbor 2.2.2.2 remote-as 100 
network 170.10.0.0 
aggregate-address 160.0.0.0 255.0.0.0 suppress-map CHECK
</code></pre></div></div>

<p>这是另外一种变化</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aggregate-address address-mask attribute-map map-name
</code></pre></div></div>

<p>这个命令允许您在发送聚合时设置属性，例如metric，为了对聚合的源设置为IGP，使用route map 到  aggregate attribute-map  命令</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>route-map SETMETRIC 
<span class="nb">set </span>origin igp 

aggregate-address 160.0.0.0 255.0.0.0 attribute-map SETORIGIN
</code></pre></div></div>

<p>更多信息可以参考 <a href="https://www.cisco.com/en/US/tech/tk365/technologies_tech_note09186a0080094826.shtml">Understanding Route Aggregation in BGP</a>.</p>

<h4 id="cidr-example-1">CIDR Example 1</h4>

<p><img src="/assets/images/bgp/b27.png" /></p>

<p>需求:允许RTB宣告前缀160.0.0.0并禁止所有的明细路由，这个需求的问题是网络160.10.0.0是AS200的本地网络，这意味着AS200是160.10.0.0的源,如果不为160.10.0.0生成条目，就不能让RTB为160.0.0.0生成前缀， aggregate summary-only也做不到，RTB生成两个网络，因为RTB是160.10.0.0的发起者。这个问题有两种解决办法</p>

<p>第一个解决方案是使用静态路由并重新分发到BGP中。结果是RTB的宣告origin 会显示incomplete (?)</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTB# 
router bgp 200 
neighbor 3.3.3.1 remote-as 300 
redistribute static 

<span class="o">!</span><span class="nt">---</span> This generates an update <span class="k">for </span>160.0.0.0 <span class="o">!</span><span class="nt">---</span> with the origin path as <span class="s2">"incomplete"</span><span class="nb">.</span>

ip route 160.0.0.0 255.0.0.0 null0
</code></pre></div></div>

<p>在第二个解决方案中，除了静态路由之外，还可以使用network命令。具有相同的效果，只是将更新的origin设置为IGP</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTB# 
router bgp 200 
network 160.0.0.0 mask 255.0.0.0

<span class="o">!</span><span class="nt">---</span> This entry marks the update with origin IGP.
 
neighbor 3.3.3.1 remote-as 300 
redistribute static
ip route 160.0.0.0 255.0.0.0 null0 
</code></pre></div></div>

<h4 id="cidr-example-2-as-set">CIDR Example 2 (as-set)</h4>
<p>使用as-set在聚合中减少路径信息的大小，使用AS -set, AS编号只出现一次，而不管在聚合的多个路径中出现了多少次AS编号，在聚合导致path的属性丢失的时候可以使用 aggregate as-set 命令，在本例中，RTC从RTA获得关于160.20.0.0的更新，从RTB获得关于160.10.0.0的更新，假设RTC希望聚合网络160.0.0.0/8并将网络发送给RTD，RTD不知道这条路线的源,如果你添加aggregate as-set，强制RTC以集合{}的形式生成路径信息，该集合包含了所有的路径信息，无论哪条路径先出现</p>

<p><img src="/assets/images/bgp/b28.png" /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTB# 
router bgp 200 
network 160.10.0.0 
neighbor 3.3.3.1 remote-as 300 

RTA# 
router bgp 100 
network 160.20.0.0 
neighbor 2.2.2.1 remote-as 300
</code></pre></div></div>

<p>Case 1</p>

<p>RTC没有使用as-set。RTC向RTD发送一个包含路径信息(300)的更新160.0.0.0/8，就像路由起源于AS300一样</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTC# 
router bgp 300 
neighbor 3.3.3.3 remote-as 200 
neighbor 2.2.2.2 remote-as 100 
neighbor 4.4.4.4 remote-as 400 
aggregate 160.0.0.0 255.0.0.0 summary-only 

<span class="o">!</span><span class="nt">---</span> This <span class="nb">command </span>causes RTC to send RTD updates about 160.0.0.0/8 <span class="o">!</span><span class="nt">---</span> 
with no indication that 160.0.0.0 actually comes from two different ASs. 
<span class="o">!</span><span class="nt">---</span> This may create loops <span class="k">if </span>RTD has an entry back into AS100 or AS200.

</code></pre></div></div>

<p>Case 2</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTC# 
   router bgp 300 
   neighbor 3.3.3.3 remote-as 200 
   neighbor 2.2.2.2 remote-as 100 
   neighbor 4.4.4.4 remote-as 400 
   aggregate 160.0.0.0 255.0.0.0 summary-only 
   aggregate 160.0.0.0 255.0.0.0 as-set 

<span class="o">!</span><span class="nt">---</span> This <span class="nb">command </span>causes RTC to send RTD updates about 160.0.0.0/8 
<span class="o">!</span><span class="nt">---</span> with an indication that 160.0.0.0 belongs to a <span class="nb">set</span> <span class="o">{</span>100 200<span class="o">}</span><span class="nb">.</span>
 
</code></pre></div></div>

<p>下面的两部分，  BGP Confederation 和 Route Reflectors，是为互联网服务提供商(isp)，希望进一步控制iBGP 对等体爆炸式的在他们的AS内部出现</p>

<h3 id="bgp-confederation">BGP Confederation</h3>

<p>BGP联邦减少了AS中的iBGP网格。将AS划分为多个AS，并将整个组分配给单个的联邦。每一个单独的iBGP都实现全互联。即使这些ASs在联邦中有eBGP对等体，但它们就像使用iBGP一样交换路由。通过这种方式，联邦保存了next hop、metric和local preference信息。在外界看来，联邦似乎是一个单一的AS</p>

<p>使用下面的命令配置BGP联邦</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bgp confederation identifier autonomous-system 
</code></pre></div></div>

<p>联邦的标识符使用联邦组的AS号
这个命令在联邦内执行让多个对等体互联</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bgp confederation peers autonomous-system <span class="o">[</span>autonomous-system]
</code></pre></div></div>

<p>联邦的例子</p>

<p><img src="/assets/images/bgp/b29.png" /></p>

<p>假设您有一个由9位BGP路由器组成的AS500。其他非BGP路由器也存在，但只对BGP路由器感兴趣，这些路由器具有到其他ASs的EBGP连接。您需要八个EBGP对等和一个到外部ASs的EBGP对等</p>

<p>如果使用联邦，可以将AS500分成多个ASs: AS50、AS60和AS70。您将把500作为联邦标识。外面只看到一个，比如500。对于每个AS50、AS60和AS70，都定义了一个完整的IBGP对等网格，使用  bgp confederation peers 定义联邦对等体</p>

<p>下面是路由器RTC、RTD和RTA的示例配置</p>

<blockquote>
  <p>RTA不知道AS50、AS60或AS70。RTA只知道AS500</p>
</blockquote>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTC#
router bgp 50
bgp confederation identifier 500
bgp confederation peers 60 70
neighbor 128.213.10.1 remote-as 50 <span class="o">(</span>IBGP connection within AS50<span class="o">)</span>
neighbor 128.213.20.1 remote-as 50 <span class="o">(</span>IBGP connection within AS50<span class="o">)</span>
neighbor 129.210.11.1 remote-as 60 <span class="o">(</span>BGP connection with confederation peer 60<span class="o">)</span>
neighbor 135.212.14.1 remote-as 70 <span class="o">(</span>BGP connection with confederation peer 70<span class="o">)</span>
neighbor 5.5.5.5 remote-as 100 <span class="o">(</span>EBGP connection to external AS100<span class="o">)</span>

RTD# 
router bgp 60 
bgp confederation identifier 500 
bgp confederation peers 50 70 
neighbor 129.210.30.2 remote-as 60 <span class="o">(</span>IBGP connection within AS60<span class="o">)</span> 
neighbor 128.213.30.1 remote-as 50<span class="o">(</span>BGP connection with confederation peer 50<span class="o">)</span> 
neighbor 135.212.14.1 remote-as 70 <span class="o">(</span>BGP connection with confederation peer 70<span class="o">)</span> 
neighbor 6.6.6.6 remote-as 600 <span class="o">(</span>EBGP connection to external AS600<span class="o">)</span> 

RTA# 
   router bgp 100 
   neighbor 5.5.5.4 remote-as 500 <span class="o">(</span>EBGP connection to confederation 500<span class="o">)</span>
</code></pre></div></div>

<h3 id="route-reflectors">Route Reflectors</h3>

<p>另外一个解决IBGP对等体爆炸的方案是Route Reflectors(RRs),在IBGP 这章，一个BGP路由器并不像另外一个IBGP路由器宣告来自其它IBGP路由器的学习的路由，可以稍微放宽这一限制，并提供额外的控制，允许路由器向其他IBGP路由器宣告或反射IBGP学习的路由。这种路由反射减少了AS中的IBGP对等体的数量</p>

<p><img src="/assets/images/bgp/b30.png" /></p>

<p>在正常的情况下，在AS100内维护着RTA、RTB和RTC互连的IBGP网络，如果使用RR，RTC可以被选为RR，RTC和RTA以及RTB是IBGP对等体，RTA和RTB没有太大的必要也设置为对等体，因为RTC可以反射来自RTA和RTB的更新</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>neighbor route-reflector-client
</code></pre></div></div>

<p>运行这个命令的路由器就是RR，RR周围的路由器就是客户端，在这个例子中，RTC 配置 neighbor route-reflector-client 命令指明RTA和RTB的IP地址。RR和客户端就组合成了一个集群。在这个例子中，RTA、RTB和RTC组成一个集群，S100内只有一个RR，其它RR的IBGP对等体就是”非客户端”</p>

<p><img src="/assets/images/bgp/b31.png" /></p>

<p>一个AS内可以有多个RR，RR对待其它的RRs就像对待其它IBGP路由器一样，其它RRs可以属于相同的集群(客户端组)或其它集群，在一个配置中，可以将AS划分为多个集群，将每个RR与其它RRs配置为完全网状拓扑中的非客户端对等体，客户端不可以与客户端集群之外的IBGP路由器成为对等体</p>

<p>第二张图中，RTA、RTB和RTC组成一个集群，RTC是RR，对于RTC, RTA和RTB是客户端，其它都是非客户端。 neighbor route-reflector-client 要指向客户端，RTD也是RTE和RTF的RR。RTG是第三个集群中的RR</p>

<blockquote>
  <p>RTD、RTC和RTG是全互连的，但是其它集群的路由器不是，当RR接收到路由时，RR路由如下所示。但是，这取决于对等类型</p>
  <ul>
    <li>从非客户端对等体到集群中的所有客户端的路由</li>
    <li>从客户端对等体到所有非客户端对等体以及到客户端对等体的路由</li>
    <li>从EBGP对等体路由将更新发送到所有客户端和非客户端对等体。</li>
  </ul>
</blockquote>

<p>路由器RTC、RTD、RTB的BGP配置如下</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTC#

router bgp 100
neighbor 2.2.2.2 remote-as 100
neighbor 2.2.2.2 route-reflector-client
neighbor 1.1.1.1 remote-as 100
neighbor 1.1.1.1 route-reflector-client
neighbor 7.7.7.7 remote-as 100
neighbor 4.4.4.4 remote-as 100
neighbor 8.8.8.8 remote-as 200


RTB#

router bgp 100
neighbor 3.3.3.3 remote-as 100
neighbor 12.12.12.12 remote-as 300


RTD#

router bgp 100
neighbor 6.6.6.6 remote-as 100
neighbor 6.6.6.6 route-reflector-client
neighbor 5.5.5.5 remote-as 100
neighbor 5.5.5.5 route-reflector-client
neighbor 7.7.7.7 remote-as 100
neighbor 3.3.3.3 remote-as 100
</code></pre></div></div>

<p>因为有IBGP学习路由的反射，可能会产生路由环路。RR方案有几个方法可以避免环路</p>

<ul>
  <li>originator-id 这是一个可选的、非传递的BGP属性，长度为4字节。RR创建此属性。属性在本地AS中携带路由发起者的路由器ID (RID)。如果配置产生环路，路由信息返回到发起者，则会忽略该信息</li>
  <li>cluster-list   Multiple RRs within a Cluster 请参考</li>
</ul>

<h4 id="multiple-rrs-within-a-cluster">Multiple RRs within a Cluster</h4>
<p><img src="/assets/images/bgp/b32.png" /></p>

<p>一般情况下，一个集群内的路由器只有一个RR，这种情况，这个RR的Router ID 标识了这个集群，为了增加冗余，减少单点，一个集群可以有多个RR。需要使用一个4字节的集群ID来配置同一集群中的所有RRs，以便RR能够识别来自同一集群中的RRs的更新</p>

<p>集群列表是路由已通过的集群id序列。当RR反射从RR客户端到集群外部的非客户端的路由时，RR将本地集群ID附加到集群列表中。如果这个更新有一个空的集群列表，RR将创建一个。使用此属性，RR可以识别路由信息是否由于配置不当而回到到相同的集群。如果在集群列表中找到本地集群ID，则忽略该宣告</p>

<p>在本节的图中，RTD、RTE、RTF和RTH属于一个集群。RTD和RTH都是同一个集群的RRs</p>

<blockquote>
  <p>存在冗余是因为RTH与所有RRs实现了全互连。如果RTD出现问题，RTH就会取代RTD</p>
</blockquote>

<p>RTH, RTD, RTF, and RTC的配置如下:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTH#

router bgp 100
neighbor 4.4.4.4 remote-as 100
neighbor 5.5.5.5 remote-as 100
neighbor 5.5.5.5 route-reflector-client
neighbor 6.6.6.6 remote-as 100
neighbor 6.6.6.6 route-reflector-client
neighbor 7.7.7.7 remote-as 100
neighbor 3.3.3.3 remote-as 100
neighbor 9.9.9.9 remote-as 300
bgp cluster-id 10


RTD#

router bgp 100
neighbor 10.10.10.10 remote-as 100
neighbor 5.5.5.5 remote-as 100
neighbor 5.5.5.5 route-reflector-client
neighbor 6.6.6.6 remote-as 100
neighbor 6.6.6.6 route-reflector-client
neighbor 7.7.7.7 remote-as 100
neighbor 3.3.3.3 remote-as 100
neighbor 11.11.11.11 remote-as 400
bgp cluster-id 10


RTF#

router bgp 100
neighbor 10.10.10.10 remote-as 100
neighbor 4.4.4.4 remote-as 100
neighbor 13.13.13.13 remote-as 500


RTC#

router bgp 100
neighbor 1.1.1.1 remote-as 100
neighbor 1.1.1.1 route-reflector-client
neighbor 2.2.2.2 remote-as 100
neighbor 2.2.2.2 route-reflector-client
neighbor 4.4.4.4 remote-as 100
neighbor 7.7.7.7 remote-as 100
neighbor 10.10.10.10 remote-as 100
neighbor 8.8.8.8 remote-as 200
</code></pre></div></div>

<blockquote>
  <p>RTC不需要使用 bgp cluster-id命令，因为集群中只存在一个RR</p>
</blockquote>

<blockquote>
  <p>此配置不能使用对等组(peer group)。如果集群中的客户端彼此之间没有直接的IBGP对等体，并且客户端通过RR交换更新，就不要使用对等组。如果配置对等组，a potential withdrawal to the source of a route on the RR transmits to all clients inside the cluster。这种传输可能会导致问题</p>
</blockquote>

<p>默认情况下RR上启用路由器子命令 bgp client-to-client reflection 。如果您关闭了这个命令，并在客户端之间实施了冗余的BGP对等体，可以安全地使用对等组。有关更多信息请参考 Limitations of Peer Groups</p>

<h4 id="rr-and-conventional-bgp-speakers">RR and Conventional BGP Speakers</h4>

<p>AS里可能会有不支持RR协议的BGP路由器，本文中称为传统的路由器，RR解决方案中允许这类传统路由器的存在.这些路由器可以是客户端组的成员，也可以是非客户端组的成员.这些路由器的存在使得从当前IBGP模型到RR模型的迁移变得简单。如果将单个路由器配置为RR，并使其他RRs和RR客户端成为普通的IBGP对等端，则可以开始创建集群。然后可以逐步创建更多集群</p>

<p><img src="/assets/images/bgp/b33.png" /></p>

<p>图中，RTD RTE和RTF支持路由反射，RTC RTA 和RTB是传统路由器.无法将这几台路由器配置为RRs，可以将这台路由器和RTD配置为IBGP，之后如果对路由器做了升级，可以将RTC配置为RTA和RTB的RR。客户端不需要支持路由放射，只需要RR需要升级</p>

<p>配置:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTD#

router bgp 100
neighbor 6.6.6.6 remote-as 100
neighbor 6.6.6.6 route-reflector-client
neighbor 5.5.5.5 remote-as 100
neighbor 5.5.5.5 route-reflector-client
neighbor 3.3.3.3 remote-as 100
neighbor 2.2.2.2 remote-as 100
neighbor 1.1.1.1 remote-as 100
neighbor 13.13.13.13 remote-as 300


RTC#

router bgp 100
neighbor 4.4.4.4 remote-as 100
neighbor 2.2.2.2 remote-as 100
neighbor 1.1.1.1 remote-as 100
neighbor 14.14.14.14 remote-as 400
</code></pre></div></div>

<p>当准备升级RTC并使RTC成为RR时，请删除IBGP全互连并让RTA和RTB成为RTC的客户</p>

<h4 id="如何避免环路">如何避免环路</h4>
<p>到目前为止，已经提到了两个可以用来防环的属性:original -id和cluster-list</p>

<p>另一种控制环路的方法是对出方向的route map 做更多的set 条件。route map出方向的set 不会影响反射到IBGP对等体的路由</p>

<p>还可以对 nexthop-self增加限制，当在RRs上使用netxthop-self，只会影响EBGP学习到的系一条路由，反射路由的下一跳不会更改</p>

<h4 id="route-flap-dampening">Route Flap Dampening</h4>
<p>Cisco IOS 11.0引入了路由翻滚惩罚.是一种最大程度减少不稳定路由造成的路由翻滚的机制，减少了网络的震荡.可以定义一些行为来识别不好的路由，每次的不稳定都会使值增大1000，累计到阈值就会被惩罚.对路由的宣告产生抑制.但同时会有一个惩罚值得衰减时间.惩罚值降低到预设置的重用值以下，就会恢复路由宣告.这种方法不适用于通过IBGP学习的外部AS的路由。通过这种方式，避免了对于IBGP路由器指向外部的路由进行的惩罚</p>

<p>惩罚粒度为5秒时衰减。取消对路由的抑制的粒度为10秒。路由器会保留这些信息，直到惩罚值小于“重用限制”的一半。此时，路由器将清除信息</p>

<p>路由翻滚默认关闭，下面的是相关的操作命令</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bgp dampening  <span class="c">#打开</span>
no bgp dampening  <span class="c">#关闭</span>
bgp dampening half-life-time <span class="c">#改变半衰期</span>
</code></pre></div></div>

<p>同时设置所有参数的命令是</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> bgp dampening half-life-time reuse suppress maximum-suppress-time
</code></pre></div></div>

<p>语法的详细信息</p>
<ul>
  <li>half-life-time  范围是1-45分钟，当前默认值是15分钟</li>
  <li>reuse-value   范围是1-20,000，缺省值是750</li>
  <li>suppress-value  范围是1-20,000，缺省值是2000</li>
  <li>max-suppress-time   这是抑制路由的最大持续时间。范围是1-255分钟，默认值是半衰期的4倍</li>
</ul>

<p><img src="/assets/images/bgp/b34.png" /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTB#
<span class="nb">hostname </span>RTB

interface Serial0
 ip address 203.250.15.2 255.255.255.252

interface Serial1
 ip address 192.208.10.6 255.255.255.252

router bgp 100
 bgp dampening
 network 203.250.15.0
 neighbor 192.208.10.5 remote-as 300


RTD#
<span class="nb">hostname </span>RTD

interface Loopback0
ip address 192.208.10.174 255.255.255.192

interface Serial0/0
 ip address 192.208.10.5 255.255.255.252

router bgp 300
 network 192.208.10.0
 neighbor 192.208.10.6 remote-as 100
</code></pre></div></div>

<p>RTB的配置用于使用默认参数抑制路由。如果您假设到RTD的EBGP链接是稳定的，那么RTB BGP表看起来是这样的</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTB# show ip bgp
BGP table version is 24, <span class="nb">local </span>router ID is 203.250.15.2 Status codes: s
suppressed, d damped, h <span class="nb">history</span>, <span class="k">*</span> valid, <span class="o">&gt;</span> best, i - internal Origin
codes: i - IGP, e - EGP, ? - incomplete

   Network          Next Hop          Metric LocPrf Weight Path
<span class="k">*</span><span class="o">&gt;</span> 192.208.10.0     192.208.10.5           0             0 300 i
<span class="k">*</span><span class="o">&gt;</span> 203.250.15.0     0.0.0.0                0         32768 i
</code></pre></div></div>

<p>为了模拟问题，在RTD上执行ip bgp 192.208.10.6命令。RTB BGP表看起来是这样的</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTB# show ip bgp
BGP table version is 24, <span class="nb">local </span>router ID is 203.250.15.2 Status codes: s
suppressed, d damped, h <span class="nb">history</span>, <span class="k">*</span> valid, <span class="o">&gt;</span> best, i - internal Origin
codes: i - IGP, e - EGP, ? - incomplete

   Network          Next Hop          Metric LocPrf Weight Path
 h 192.208.10.0     192.208.10.5           0             0 300 i
<span class="k">*</span><span class="o">&gt;</span> 203.250.15.0     0.0.0.0                0         32768 i

</code></pre></div></div>

<p>192.208.10.0的BGP条目处于历史状态。这个位置意味着您没有到路由的最佳路径，但是关于路由的flap这条线路因扑动而受到处罚，但处罚仍低于“限制限制”。默认值是2000。路由抑制尚未发生。如果这条路线再翻几次，你就明白了信息仍然存在</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTB# show ip bgp 192.208.10.0
BGP routing table entry <span class="k">for </span>192.208.10.0 255.255.255.0, version 25
Paths: <span class="o">(</span>1 available, no best path<span class="o">)</span>
300 <span class="o">(</span><span class="nb">history </span>entry<span class="o">)</span>
    192.208.10.5 from 192.208.10.5 <span class="o">(</span>192.208.10.174<span class="o">)</span>
Origin IGP, metric 0, external
Dampinfo: penalty 910, flapped 1 <span class="nb">times </span><span class="k">in </span>0:02:03
</code></pre></div></div>

<p>这条线路因为抖动而受到处罚，但处罚仍低于“限制限制”。默认值是2000。路由抑制尚未发生。如果这条路线再出几次问题</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTB# show ip bgp
BGP table version is 32, <span class="nb">local </span>router ID is 203.250.15.2 Status codes:
s suppressed, d damped, h <span class="nb">history</span>, <span class="k">*</span> valid, <span class="o">&gt;</span> best, i - internal Origin codes:
i - IGP, e - EGP, ? - incomplete

   Network          Next Hop          Metric LocPrf Weight Path
<span class="k">*</span>d 192.208.10.0     192.208.10.5           0             0  300 i
<span class="k">*</span><span class="o">&gt;</span> 203.250.15.0     0.0.0.0               0       32768  i
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTB# show ip bgp 192.208.10.0
BGP routing table entry <span class="k">for </span>192.208.10.0 255.255.255.0, version 32
Paths: <span class="o">(</span>1 available, no best path<span class="o">)</span>
300, <span class="o">(</span>suppressed due to dampening<span class="o">)</span>
192.208.10.5 from 192.208.10.5 <span class="o">(</span>192.208.10.174<span class="o">)</span>
      Origin IGP, metric 0, valid, external
Dampinfo: penalty 2615, flapped 3 <span class="nb">times </span><span class="k">in </span>0:05:18 , reuse <span class="k">in </span>0:27:00
</code></pre></div></div>

<p>这条路线已经被抑制了，当代价达到“重用值”时，路由将被重用.重用值是默认值750，当惩罚值小于重用限制的一半时，就会清除惩罚的信息.当惩罚变为375(750/2=375)时进行清除。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>show ip bgp flap-statistics    
<span class="c"># 显示所有路径的flap统计信息</span>

show ip bgp flap-statistics regexp regular-expression  
<span class="c"># 显示与正则表达式匹配的所有路径的flap统计信息。</span>

show ip bgp flap-statistics filter-list list  
<span class="c"># 显示通过过滤器的所有路径的flap统计信息</span>

show ip bgp flap-statistics A.B.C.D m.m.m.m   
<span class="c"># 显示单个条目的flap统计信息</span>

show ip bgp flap-statistics A.B.C.D m.m.m.m longer-prefix   
<span class="c">#  显示更多特定条目的flap统计信息</span>

show ip bgp neighbor <span class="o">[</span>dampened-routes] | <span class="o">[</span>flap-statistics]   
<span class="c"># 显示来自邻居的所有路径的flap统计信息</span>

clear ip bgp flap-statistics  
<span class="c">#  清除所有路径的flap统计信息</span>

clear ip bgp flap-statistics regexp regular-expression  
<span class="c">#  清除与正则表达式匹配的所有路径的flap统计信息</span>

clear ip bgp flap-statistics filter-list list  
<span class="c">#  清除所有通过过滤器的路径的flap统计信息</span>

clear ip bgp flap-statistics A.B.C.D m.m.m.m  
<span class="c"># 清除单个条目的flap统计信息。</span>

clear ip bgp A.B.C.D flap-statistics  
<span class="c"># 清除来自邻居的所有路径的flap统计信息</span>
</code></pre></div></div>]]></content><author><name>Your Name</name></author><category term="RS" /><summary type="html"><![CDATA[BGP案例04 (参考https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/26634-bgp-toc.html#neighborsroutemaps)]]></summary></entry><entry><title type="html">php 配置fcgi 获取监控数据</title><link href="/monitor-php/" rel="alternate" type="text/html" title="php 配置fcgi 获取监控数据" /><published>2022-08-27T00:00:00+08:00</published><updated>2022-08-27T00:00:00+08:00</updated><id>/monitor-php</id><content type="html" xml:base="/monitor-php/"><![CDATA[<p>规避Nginx,通过fcgi接口取值</p>

<h3 id="安装">安装</h3>

<p>在 centos上可以通过下面的方式安装</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yum <span class="nt">--enablerepo</span><span class="o">=</span>epel <span class="nb">install </span>fcgi
</code></pre></div></div>

<p>FasdCGI在命令行访问需要通过配置环境变量,连接到一个FastCGI接口,需要有–bind和–conect参数:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cgi-fcgi -bind -connect 127.0.0.1:端口
</code></pre></div></div>

<h3 id="配置">配置</h3>

<p>php-fpm的conf 需要配置</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pm.status_path <span class="o">=</span> /status
listen <span class="o">=</span> 61185
listen.allowed_clients <span class="o">=</span> 127.0.0.1
</code></pre></div></div>

<h3 id="测试">测试</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">SCRIPT_NAME</span><span class="o">=</span>/status <span class="nv">SCRIPT_FILENAME</span><span class="o">=</span>/status <span class="nv">REQUEST_METHOD</span><span class="o">=</span>GET <span class="nv">QUERY_STRING</span><span class="o">=</span>xml cgi-fcgi <span class="nt">-bind</span> <span class="nt">-connect</span> 127.0.0.1:61185
Expires: Thu, 01 Jan 1970 00:00:00 GMT
Cache-Control: no-cache, no-store, must-revalidate, max-age<span class="o">=</span>0
Content-Type: text/xml

&lt;?xml <span class="nv">version</span><span class="o">=</span><span class="s2">"1.0"</span> ?&gt;
&lt;status&gt;
&lt;pool&gt;www&lt;/pool&gt;
&lt;process-manager&gt;dynamic&lt;/process-manager&gt;
&lt;start-time&gt;1661607804&lt;/start-time&gt;
&lt;start-since&gt;135&lt;/start-since&gt;
&lt;accepted-conn&gt;21&lt;/accepted-conn&gt;
&lt;listen-queue&gt;0&lt;/listen-queue&gt;
&lt;max-listen-queue&gt;0&lt;/max-listen-queue&gt;
&lt;listen-queue-len&gt;128&lt;/listen-queue-len&gt;
&lt;idle-processes&gt;5&lt;/idle-processes&gt;
&lt;active-processes&gt;1&lt;/active-processes&gt;
&lt;total-processes&gt;6&lt;/total-processes&gt;
&lt;max-active-processes&gt;1&lt;/max-active-processes&gt;
&lt;max-children-reached&gt;0&lt;/max-children-reached&gt;
&lt;slow-requests&gt;0&lt;/slow-requests&gt;
&lt;/status&gt;
</code></pre></div></div>

<p>以上返回值表示正常获取到值,参数还可以支持 json,xml,html</p>

<h3 id="参数说明">参数说明</h3>

<ul>
  <li>pool – 套接字的池的名称，在php-fpm 配置中定义</li>
  <li>process manager: 进程管理器用来控制子进程数量的方法,可以通过pm来配置,有static, dynamic,ondemand</li>
  <li>start time: 服务启动时间相对应的日期,reload后会更新</li>
  <li>start since: 服务运行时长</li>
  <li>accepted conn: 连接池已接受的传入请求数,当一个连接被接受时，它会从监听队列中移除(实时显示)</li>
  <li>listen queue: 当前已启动但尚未接受的连接数。如果此值非零，则通常意味着所有可用的服务器进程当前都处于忙碌状态，并且没有可用于服务下一个请求的进程.通过pm.max_children调整</li>
  <li>max listen queue: 服务启动后listen queue 的最大值</li>
  <li>listen queue len: 排队的连接数的上限,通过listen.backlog 配置,这个值也会受到 net.core.somaxconn 的限制</li>
  <li>idle processes: 处于“等待处理”状态的进程数量。当pm的值为dynamic的时候,这个值会在 pm.min_spare_servers 和 pm.max_spare_servers 值之间</li>
  <li>active processes: 活跃进程数量,最小值为1</li>
  <li>total processes: 空闲进程+活动进程的和。如果pm的值为static 的，这个数字显示 pm.max_children 的值</li>
  <li>max active processes: php-fpm 服务启动后，<em>active processes</em> 的历史最高值。不会超过 pm.max_children</li>
  <li>max children reached: php-fpm 服务器启动后, 到达pm.max_children 的次数,只有pm为 dynamic才有效</li>
</ul>

<h3 id="排错">排错</h3>

<p>如果上面的命令返回空,将listen.allowed_clients的127.0.0.1放在第一位</p>]]></content><author><name>Your Name</name></author><category term="Monitor" /><summary type="html"><![CDATA[规避Nginx,通过fcgi接口取值]]></summary></entry><entry><title type="html">etcd集群监控</title><link href="/monitor-etcd/" rel="alternate" type="text/html" title="etcd集群监控" /><published>2022-08-26T00:00:00+08:00</published><updated>2022-08-26T00:00:00+08:00</updated><id>/monitor-etcd</id><content type="html" xml:base="/monitor-etcd/"><![CDATA[<p>etcd集群监控</p>

<h3 id="系统">系统</h3>
<p>Centos 7</p>

<h3 id="测试接口">测试接口</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">--cert</span> /opt/etcd/ssl/server.pem <span class="nt">--key</span> /opt/etcd/ssl/server-key.pem https://10.0.2.45:2379/metrics <span class="nt">--insecure</span>
</code></pre></div></div>

<h3 id="prometheus-配置">prometheus 配置</h3>

<p>添加 etcd主机组 prometheus.yml</p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="pi">-</span> <span class="na">job_name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">etcd</span><span class="nv"> </span><span class="s">cluster"</span>
    <span class="na">scheme</span><span class="pi">:</span> <span class="s">https</span>
    <span class="na">static_configs</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">targets</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">10.0.2.44:2379"</span><span class="pi">,</span><span class="s2">"</span><span class="s">10.0.2.45:2379"</span><span class="pi">,</span><span class="s2">"</span><span class="s">10.0.2.46:2379"</span><span class="pi">]</span>
    <span class="na">tls_config</span><span class="pi">:</span>
      <span class="na">insecure_skip_verify</span><span class="pi">:</span> <span class="no">true</span>
      <span class="na">cert_file</span><span class="pi">:</span> <span class="s2">"</span><span class="s">/data/config/oss/prometheus/etcd_ca/server.pem"</span>
      <span class="na">key_file</span><span class="pi">:</span> <span class="s2">"</span><span class="s">/data/config/oss/prometheus/etcd_ca/server-key.pem"</span>
</code></pre></div></div>]]></content><author><name>Your Name</name></author><category term="Monitor" /><summary type="html"><![CDATA[etcd集群监控]]></summary></entry><entry><title type="html">路由交换 - BGP案例 - 03</title><link href="/rs-bgp-03/" rel="alternate" type="text/html" title="路由交换 - BGP案例 - 03" /><published>2022-08-26T00:00:00+08:00</published><updated>2022-08-26T00:00:00+08:00</updated><id>/rs-bgp-03</id><content type="html" xml:base="/rs-bgp-03/"><![CDATA[<p>BGP案例03
(参考https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/26634-bgp-toc.html#neighborsroutemaps)</p>

<h3 id="bgp-filtering">BGP Filtering</h3>

<p>有很多方法可以控制发送和接收的BGP更新，可以使用路由信息作为基础过滤BGP更新，或者使用路径信息或社区作为基础过滤BGP更新，这些方法都可以得到一样的结果。使用哪种方法却决于特定的网络情况</p>

<h4 id="route-filtering">Route Filtering</h4>

<p><img src="/assets/images/bgp/b21.png" /></p>

<p>为了可以限制路由学习到的更新或者宣告的更新，你可以从一个特定的邻居使用路由更新过滤BGP，可以定义一个控制访问列表，然后应用到一个邻居的更新中，配置命令:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>neighbor <span class="o">{</span>ip-address | peer-group-name<span class="o">}</span> distribute-list access-list-number <span class="o">{</span><span class="k">in</span> | out<span class="o">}</span> 
</code></pre></div></div>

<p>在这个例子中，RTB作为160.10.0.0的源网络发送 更新到RTC.如果RTC不想发布更新到AS100，需要定义一个访问控制列表，并把这个访问控制列表应用到路由进程配置中</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTC# 
router bgp 300 
network 170.10.0.0 
neighbor 3.3.3.3 remote-as 200 
neighbor 2.2.2.2 remote-as 100 
neighbor 2.2.2.2 distribute-list 1 out 

access-list 1 deny 160.10.0.0 0.0.255.255 

access-list 1 permit 0.0.0.0 255.255.255.255
</code></pre></div></div>

<blockquote>
  <p>过滤掉所有到160.10.0.0的路由更新</p>
</blockquote>

<p>在处理一些超网的时候访问控制列表可能会有一些棘手</p>

<p>假定，在本节的例子中，RTB有160.10.x.x的不同子网，您的目标是过滤更新并只发布160.0.0.0/8</p>

<p>命令 access-list 1 permit 160.0.0.0 0.255.255.255允许60.0.0.0/8, 160.0.0.0/9，为了将更新限制为仅160.0.0.0/8，必须使用这种格式的扩展访问列表</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>access-list 101 permit ip 160.0.0.0 0.255.255.255 255.0.0.0 0.0.0.0.
</code></pre></div></div>

<p>这个列表只允许160.0.0.0/8</p>

<p>参考 <a href="https://www.cisco.com/en/US/tech/tk365/technologies_tech_note09186a00801310cb.shtml">How to Block One or More Networks From a BGP Peer</a> 里面有关如何过滤来自BGP对等的网络的示例配置，该方法使用具有标准和扩展访问控制列表(acl)的distribution -list命令，以及前缀列表过滤</p>

<h4 id="path-filtering">Path Filtering</h4>

<p>另外一种筛选的方法 path filtering</p>

<p><img src="/assets/images/bgp/b22.png" /></p>

<p>可以使用BGP AS 路径信息 在访问控制列表中应用到出方向和入方向的更新.本节的图中，你可以阻止160.10.0.0的更新去往AS100，若要阻止更新，在RTC上定义一个访问列表，防止将源自AS200的任何更新传输到AS100</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ip as-path access-list access-list-number <span class="o">{</span>permit | deny<span class="o">}</span> as-regular-expression
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>neighbor <span class="o">{</span>ip-address | peer-group-name<span class="o">}</span> filter-list access-list-number <span class="o">{</span><span class="k">in</span> | out<span class="o">}</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTC# 
router bgp 300 
neighbor 3.3.3.3 remote-as 200 
neighbor 2.2.2.2 remote-as 100 
neighbor 2.2.2.2 filter-list 1 out

<span class="o">!</span><span class="nt">---</span> The 1 is the access list number below.

ip as-path access-list 1 deny ^200<span class="nv">$ </span>
ip as-path access-list 1 permit .<span class="k">*</span>
</code></pre></div></div>

<p>本例中的access-list 1命令强制拒绝包含以200开头和以200结尾的路径信息的任何更新，命令中的^200$是一个“正则表达式”，其中^表示匹配开头，$表示匹配结尾，因为RTB发送关于160.10.0.0的更新，其中包含以200开头和以200结尾的路径信息，更新与访问列表匹配。访问列表拒绝这些更新。</p>

<p>：*是另一个正则表达式，.表示“任何字符”，<em>表示“该字符的重复”。所以.</em>表示任何路径信息，这是允许传输所有其他更新所必需的。</p>

<p>如果不是使用^200$，而是使用^200，这本章的图中显示，AS400源的更新具有的路径信息(200,400)。200在前，400在后，这些更新与访问列表^200匹配，因为路径信息以200开头，访问列表阻止将这些更新传输到RTA</p>

<p><a href="https://www.cisco.com/en/US/docs/ios/iproute_bgp/command/reference/irg_bgp5.html#wp1161831">show ip bgp regexp regular-expression</a>命令显示与正则表达式配置匹配的所有路径</p>

<h3 id="as-regular-expression">AS Regular Expression</h3>

<p>正则表达式是与输入字符串匹配的模式。当构建正则表达式时，指定输入必须匹配的字符串。对于BGP，指定一个字符串，该字符串包含输入必须匹配的路径信息</p>

<p>在 <a href="https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/26634-bgp-toc.html#pathfilter">Path Filtering</a>的示例中，指定了字符串^200$。需要更新内部的路径信息来匹配字符串，以便做出决策</p>

<p>正则表达式包括</p>

<p>Range</p>

<p>范围是左方括号和右方括号中的字符序列。例如[abcd]</p>

<p>Atom</p>

<p>Piece</p>

<p>Branch</p>

<p><a href="https://www.cisco.com/en/US/tech/tk365/technologies_tech_note09186a0080094a92.shtml">Using Regular Expressions in BGP</a>   参考提供的样例</p>

<h4 id="bgp-community-filtering">BGP Community Filtering</h4>

<p>本文档介绍路由过滤和AS-path过滤的内容，还有一个方法是community过滤.  <a href="https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/26634-bgp-toc.html#communityattribute">Community Attribute</a>  讨论community，本章提供一些使用community的例子</p>

<p><img src="/assets/images/bgp/b23.png" /></p>

<p>在例子中，你希望RTB为BGP路由设置community属性，使RTC不能传递路由到外部对等体，使用no-export 的community 属性</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTB# 
router bgp 200 
network 160.10.0.0 
neighbor 3.3.3.1 remote-as 300 
neighbor 3.3.3.1 send-community 
neighbor 3.3.3.1 route-map setcommunity out 

route-map setcommunity 
match ip address 1 
<span class="nb">set </span>community no-export  

access-list 1 permit 0.0.0.0 255.255.255.255 
</code></pre></div></div>

<blockquote>
  <p>本例使用route-map setcommunity命令将community设置为no-export</p>
</blockquote>

<blockquote>
  <p>要将此属性发送到RTC，必须使用 neighbor send-community 命令</p>
</blockquote>

<p>当RTC使用NO_EXPORT属性获取更新时，RTC不会将更新传播给外部对等方RTA</p>

<p>在本例中，RTB将community属性设置为 100 200 additive。在向RTC传输之前会在已经存在的community 的值添加100 200</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTB# 
   router bgp 200 
   network 160.10.0.0 
   neighbor 3.3.3.1 remote-as 300 
   neighbor 3.3.3.1 send-community 
   neighbor 3.3.3.1 route-map setcommunity out 

route-map setcommunity 
match ip address 2 
<span class="nb">set </span>community 100 200 additive 

access-list 2 permit 0.0.0.0 255.255.255.255
</code></pre></div></div>

<p>community list是route map的match子句中使用的一组communities。community list 允许根据不同的community 号码 列表 筛选或设置属性</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ip community-list community-list-number <span class="o">{</span>permit | deny<span class="o">}</span> community-number
</code></pre></div></div>

<p>例如，你可以定义route map，match-on-community:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>route-map match-on-community 
match community 10

<span class="o">!</span><span class="nt">---</span> The community list number is 10.

<span class="nb">set </span>weight 20
ip community-list 10 permit 200 300

<span class="o">!</span><span class="nt">---</span> The community number is 200 300.
</code></pre></div></div>

<p>可以使用community列表来过滤或设置某些参数，比如权重和度量，以community值作为基础进行某些更新,在本节的第二个示例中，RTB向RTC发送了一个community为100 200的更新。如果RTC希望以这些值为基础设置权重,可以做如下操作</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTC# 
router bgp 300 
neighbor 3.3.3.3 remote-as 200 
neighbor 3.3.3.3 route-map check-community <span class="k">in 

</span>route-map check-community permit 10 
match community 1 
<span class="nb">set </span>weight 20 

route-map check-community permit 20 
match community 2 exact 
<span class="nb">set </span>weight 10 

route-map check-community permit 30 
match community 3 

ip community-list 1 permit 100 
ip community-list 2 permit 200 
ip community-list 3 permit internet 
</code></pre></div></div>

<p>任何在community属性中包含100的路由都匹配列表1，这条路由的权重设为20。任何只有200的路由匹配community的列表2，并且权重为20。关键字 exact 说明社区只由200个成员组成，没有其他内容。这里是最后一个社区列表，以确保不会删除其他更新，在默认情况下，任何不匹配的内容都会自动删除，关键字internet表示所有路由，因为所有路由都是internet社区的成员</p>

<p>参考   <a href="https://www.cisco.com/en/US/tech/tk365/technologies_configuration_example09186a00801475b2.shtml">Using BGP Community Values to Control Routing Policy in an Upstream Provider Network</a> 获取更多信息</p>

<h3 id="bgp-neighbors-and-route-maps">BGP Neighbors and Route Maps</h3>

<p><img src="/assets/images/bgp/b24.png" /></p>

<p>可以使用neighbor命令和route map结合在一起对进入或者出去的更新进行过滤或者设置参数</p>

<p>当基于IP做匹配的时候，route maps 和 neighbor对进入的更新不起作用</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>neighbor ip-address route-map route-map-name
</code></pre></div></div>

<p>假定图中你想RTC只学习到AS200的网络，并且设置权重为20，可以联合使用neighbor和as-path 访问控制列表</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTC# 
   router bgp 300 
   network 170.10.0.0 
   neighbor 3.3.3.3 remote-as 200 
   neighbor 3.3.3.3 route-map stamp <span class="k">in 

</span>route-map stamp 
match as-path 1 
<span class="nb">set </span>weight 20 

ip as-path access-list 1 permit ^200<span class="err">$</span>
</code></pre></div></div>

<p>任何源自AS200的更新都具有以200开头、以200结尾的路径信息。这些更新是允许的。任何其他更新都会丢弃。</p>

<p>假定你希望实现下面的功能:</p>
<ul>
  <li>接受来自AS200的、权重为20的更新</li>
  <li>删除源自AS400的更新</li>
  <li>其他更新的权重为10</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTC# 
router bgp 300 
network 170.10.0.0 
neighbor 3.3.3.3 remote-as 200 
neighbor 3.3.3.3 route-map stamp <span class="k">in 

</span>route-map stamp permit 10 
match as-path 1 
<span class="nb">set </span>weight 20 

route-map stamp permit 20 
match as-path 2 
<span class="nb">set </span>weight 10 

ip as-path access-list 1 permit ^200<span class="nv">$ </span>
ip as-path access-list 2 permit ^200 600 .<span class="k">*</span>
</code></pre></div></div>

<p>该语句将本地更新的权重设置为20。该语句还为AS400后面的更新设置了10的权重，并丢弃了来自AS400的更新。</p>

<h4 id="use-of-set-as-path-prepend-command">Use of set as-path prepend Command</h4>

<p>在某些情况下，为了操作BGP决策过程，必须要操作路径信息。可以在route map中使用下面的命令:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">set </span>as-path prepend as-path# as-path#
</code></pre></div></div>

<p>假设，在  <a href="https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/26634-bgp-toc.html#neighborsroutemaps">BGP Neighbors and Route Maps</a>  这章中，RTC向两个不同的ASs (AS100和AS200)宣告自己的网络170.10.0.0。当信息传播到AS600时，AS600到170.10.0.0网络在的路由器可以通过两条不同的路由到达。第一个路由是通过AS100(100,300)，第二个路由是通过AS400(400,200,300)。如果所有其它属性都相同，AS600选择最短路径并通过AS100选择路由</p>

<p>AS300通过AS100获得所有的流量。如果您想从AS300改变路由，可以使通过AS100的路径看起来比通过AS400的路径长。如果将宣告中的现有路径信息作为数字添加到AS100中，则可以这样做。一个常见的做法是这样重复你自己的AS号码</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTC# 
router bgp 300 
network 170.10.0.0 
neighbor 2.2.2.2 remote-as 100 
neighbor 2.2.2.2 route-map SETPATH out 

route-map SETPATH 
<span class="nb">set </span>as-path prepend 300 300
</code></pre></div></div>

<p>由于这个配置，AS600通过AS100接收关于170.10.0.0的更新，路径信息为:(100,300,300,300)。这个路径信息比AS600从AS400接收到的(400、200、300)长</p>

<h4 id="bgp-peer-groups">BGP Peer Groups</h4>

<p><img src="/assets/images/bgp/b25.png" /></p>

<p>BGP对等组是一组具有相同更新策略的BGP邻居。roupte maps、distribute lists和filter lists通常设置更新策略。不能为每个单独的邻居定义相同的策略;但可以定义一个对等组名称并将这些策略分配给对等组</p>

<p>对等组的成员继承对等组的所有配置选项。如果这些选项不影响出站更新，还可以配置成员覆盖这些选项。但只能覆盖入站设置的选项</p>

<p>要定义对等组的命令:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>neighbor peer-group-name peer-group
</code></pre></div></div>

<p>此示例将对等组应用于内部和外部BGP邻居</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTC# 
   router bgp 300 
   neighbor internalmap peer-group 
   neighbor internalmap remote-as 300 
   neighbor internalmap route-map SETMETRIC out 
   neighbor internalmap filter-list 1 out 
   neighbor internalmap filter-list 2 <span class="k">in 
   </span>neighbor 5.5.5.2 peer-group internalmap 
   neighbor 5.6.6.2 peer-group internalmap 
   neighbor 3.3.3.2 peer-group internalmap 
   neighbor 3.3.3.2 filter-list 3 <span class="k">in</span>
</code></pre></div></div>

<p>这个配置定义了一个名为internalmap的对等组。该配置为组定义了一些策略，例如将度量设置为5的route map SETMETRIC和两个不同的filter-list 1和2。该配置将对等组应用于所有内部邻居RTE、RTF和RTG。此外，该配置还为邻居RTE定义了一个单独的列表3。此列表覆盖对等组中的列表2</p>

<blockquote>
  <p>只能覆盖影响入站更新的选项</p>
</blockquote>

<p>现在，看看如何使用外部邻居的对等组。可以使用对等组externalmap配置RTC，并将对等组应用于外部邻居</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTC# 
   router bgp 300 
   neighbor externalmap peer-group 
   neighbor externalmap route-map SETMETRIC 
   neighbor externalmap filter-list 1 out 
   neighbor externalmap filter-list 2 <span class="k">in 
   </span>neighbor 2.2.2.2 remote-as 100 
   neighbor 2.2.2.2 peer-group externalmap 
   neighbor 4.4.4.2 remote-as 600 
   neighbor 4.4.4.2 peer-group externalmap 
   neighbor 1.1.1.2 remote-as 200 
   neighbor 1.1.1.2 peer-group externalmap 
   neighbor 1.1.1.2 filter-list 3 <span class="k">in</span>
</code></pre></div></div>

<blockquote>
  <p>在这些配置中，将remote定义为对等组之外的语句，因为必须定义不同的外部ASs</p>
</blockquote>

<p>更多关于对等体组的信息请参考 <a href="https://www.cisco.com/en/US/tech/tk365/technologies_tech_note09186a0080093fb7.shtml">BGP Peer Groups</a>.</p>

<blockquote>
  <p>在Cisco IOS软件发布12.0(24)S中，Cisco引入了BGP动态更新对等组特性。该功能也可以在以后的Cisco IOS软件版本中使用。该特性引入了一种新的算法，详细信息参考  <a href="https://www.cisco.com/univercd/cc/td/doc/product/software/ios120/120newft/120limit/120s/120s24/s_bgpdpg.htm">BGP Dynamic Update Peer-Groups</a></p>
</blockquote>]]></content><author><name>Your Name</name></author><category term="RS" /><summary type="html"><![CDATA[BGP案例03 (参考https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/26634-bgp-toc.html#neighborsroutemaps)]]></summary></entry><entry><title type="html">路由交换 - BGP案例 - 02</title><link href="/rs-bgp-02/" rel="alternate" type="text/html" title="路由交换 - BGP案例 - 02" /><published>2022-08-24T00:00:00+08:00</published><updated>2022-08-24T00:00:00+08:00</updated><id>/rs-bgp-02</id><content type="html" xml:base="/rs-bgp-02/"><![CDATA[<p>BGP案例02
(参考https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/26634-bgp-toc.html#neighborsroutemaps)</p>

<h3 id="as_path-attribute">AS_PATH Attribute</h3>

<p><img src="/assets/images/bgp/b10.png" /></p>

<p>当路由更新通过一个AS的时候，AS的编号会成为这个更新的前缀，AS_PATH属性实际上是一个路由为到达目的地而穿过的AS编号列表.AS_SET是已穿过的所有AS的有序数学集合{}。AS_SET示例: <a href="https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/26634-bgp-toc.html#ex2">CIDR Example 2 (as-set)</a></p>

<p>在本小节的例子中，RTB在AS200中宣告网络190.10.0.0，当路由穿过AS300，RTC添加它自己的AS号码到network，所以当190.10.0.0到达RTA，这个network会被添加两个AS号码，第一个是200，然后是300，RTA上到达190.10.0.0是(300,200)</p>

<p>同样的过程也适用于170.10.0.0和180.10.0.0。RTB必须选择path (300,100)，为了达到170.10.0.0,RTB穿过AS300和AS100。RTC必须穿过路径(200)才能达到190.10.0.0，路径(100)才能达到170.10.0.0</p>

<h3 id="origin-attribute">Origin Attribute</h3>

<p>origin是一个强制性属性，定义路径信息的起源，origion属性能够假定三个值</p>

<ul>
  <li>IGP     网络层可达性信息(NLRI)是网络产生之初的内部信息。这通常发生在发出 bgp network 命令时。BGP表中的i表示IGP。</li>
  <li>EBGP      NLRI是通过外部网关协议(EGP)学习的。BGP表中的e表示EGP</li>
  <li>INCOMPLETE      NLRI是未知的，或者是通过其他方式习得的。当您将路由从其他路由协议重新分发到BGP并且路由的起源不完整时，通常会产生不完整的情况。一个?在BGP表中表示INCOMPLETE</li>
</ul>

<p><img src="/assets/images/bgp/b11.png" /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTA# 
router bgp 100 
neighbor 190.10.50.1 remote-as 100 
neighbor 170.10.20.2 remote-as 300 
network 150.10.0.0 
redistribute static 
 
ip route 190.10.0.0 255.255.0.0 null0 
 
RTB# 
router bgp 100 
neighbor 150.10.30.1 remote-as 100 
network 190.10.50.0 
RTE# 
router bgp 300 
neighbor 170.10.20.1 remote-as 100 
network 170.10.0.0
</code></pre></div></div>

<p>RTA通过300i到达170.10.0.0，“300i”表示下一个AS路径为300，路由为IGP。RTA通过i也达到190.10.50，这个“i”表示这个路由条目在同一个AS内，源也是IGP。RTE通过100i达到150.10.0.0，“100i”表示下一个AS为100，源为IGP，通过100 ? RTE达到190.10.0.0。“100”表示下一个AS是100，源是不完整的，来自静态路由。</p>

<h3 id="bgp-next-hop-attribute">BGP Next Hop Attribute</h3>

<p><img src="/assets/images/bgp/b12.png" /></p>

<p>BGP下一跳属性是为了到达某个目的地而使用的下一跳IP地址</p>

<p>对于EBGP，下一跳总是neighbor 命令指定的邻居的IP地址，在这个例子中，RTC宣告170.10.0.0到RTA，下一跳为170.10.20.2。RTA向RTC宣告150.10.0.0，下一跳是170.10.20.1.对于IBGP，协议规定EBGP宣告的下一跳应该被带到IBGP中。由于这个规则，RTA向它的IBGP对等RTB宣告170.10.0.0，下一跳为170.10.20.2。因此，根据RTB，下一跳到达170.10.0.0的路由是170.10.20.2，而不是150.10.30.1</p>

<p>通过IGP来保证RTB可以到达170.10.20.2，否则，RTB会因为无法访问下一跳地址而将目的地为170.10.0.0的数据包丢弃，例如，如果RTB运行iGRP，在RTA网络170.10.0.0上运行iGRP。可以在和RTC互联的链路上使用被动模式，所以只会有BGP的信息和RTC进行交换</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTA# 
router bgp 100 
neighbor 170.10.20.2 remote-as 300 
neighbor 150.10.50.1 remote-as 100 
network 150.10.0.0 
RTB# 
router bgp 100 
neighbor 150.10.30.1 remote-as 100 
RTC# 
router bgp 300 
neighbor 170.10.20.1 remote-as 100 
network 170.10.0.0 
</code></pre></div></div>

<blockquote>
  <p>RTC宣告170.10.0.0到RTA，下一跳170.10.20.2</p>
</blockquote>

<blockquote>
  <p>RTA宣告170.10.0.0到RTB，下一条170.10.20.2，EBGP的下一跳携带进了IBGP</p>
</blockquote>

<p>在处理多路(multiaccess)和非广播多路(NBMA)网络时要特别小心， <a href="https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/26634-bgp-toc.html#bgpmultiaccess">BGP Next Hop (Multiaccess Networks)</a> 和 <a href="https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/26634-bgp-toc.html#bgpnbma">BGP Next Hop (NBMA)</a> 提供了更详细的信息</p>

<h4 id="bgp-next-hop-multiaccess-networks">BGP Next Hop (Multiaccess Networks)</h4>

<p><img src="/assets/images/bgp/b13.png" /></p>

<p>这个示例显示了下一跳在多路访问(如以太网)上的行为</p>

<p>假定RTC和RTD在AS300中运行OSPF，RTC和RTA运行BGP，RTC可以通过网络170.10.20.3到达180.20.0.0，当RTC向RTA发送关于180.20.0.0的BGP更新时,RTC使用170.10.20.3作为下一跳,RTC没有使用它自己的IP地址，170.10.20.2。RTC使用这个地址是因为RTA、RTC和RTD之间的网络是一个多路网络，RTA使用RTD作为下一跳达到180.20.0.0比通过RTC更合理。</p>

<blockquote>
  <p>RTC向RTA宣告180.20.0.0的下一跳是170.10.20.3</p>
</blockquote>

<p>如果RTA、RTC和RTD的共同介质不是多路访问的，而是NBMA，则会发生进一步的问题</p>

<h4 id="bgp-next-hop-nbma">BGP Next Hop (NBMA)</h4>

<p><img src="/assets/images/bgp/b14.png" /></p>

<p>公共的介质在图中以云的方式出现，如果是帧中继或者其它的NBMA云，RTC向RTA宣告了180.20.0.0，下一跳为170.10.20.3。</p>

<p>问题是RTA没有直接的永久性虚拟电路(PVC)到RTD，并且不能到达下一跳。在这种情况下，路由失败</p>

<p>next-hop-self 命令可以解决这个问题</p>

<p>对于下一跳的情况，例如在BGP下一跳(NBMA)示例中，您可以使用next-hop-self命令。的语法是:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>neighbor <span class="o">{</span>ip-address | peer-group-name<span class="o">}</span> next-hop-self 
</code></pre></div></div>

<p>next-hop-self命令允许强制BGP使用特定的IP地址作为下一跳</p>

<p>对于<a href="https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/26634-bgp-toc.html#bgpnbma">BGP Next Hop (NBMA)</a>示例，这种配置解决了这个问题</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTC# 
router bgp 300 
neighbor 170.10.20.1 remote-as 100 
neighbor 170.10.20.1 next-hop-self 
</code></pre></div></div>

<p>RTC宣告180.20.0.0，下一跳170.10.20.2</p>

<h4 id="bgp-backdoor">BGP Backdoor</h4>

<p><img src="/assets/images/bgp/b15.png" /></p>

<p>在图中，RTA和RTC运行EBGP，RTB和RTC运行EBGP，RTA和RTB运行一种IGP，可以是RIP,IGRP或者其它协议，根据定义，EBGP的更新的AS值是20，小于IGP的AD值，AD值如下：</p>

<ul>
  <li>120 for RIP</li>
  <li>100 for IGRP</li>
  <li>90 for EIGRP</li>
  <li>110 for OSPF</li>
</ul>

<p>RTA接到160.10.0.0的更新来自两个路由协议</p>

<ul>
  <li>eBGP with a distance of 20</li>
  <li>IGP with a distance that is greater than 20</li>
</ul>

<p>默认情况下的BGP AD值</p>

<ul>
  <li>External distance—20</li>
  <li>Internal distance—200</li>
  <li>Local distance—200</li>
</ul>

<p>但你可以使用distance命令来改变默认距离:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>distance bgp external-distance internal-distance local-distance
</code></pre></div></div>

<p>RTA选择了EBGP通过RTC，因为AD值更短</p>

<p>如果你需要RTA通过RTB的IGP学习到160.10.0.0，你有两个选择</p>

<ul>
  <li>改变eBGP的外部AD或IGP AD</li>
  <li>使用BGP backdoor</li>
</ul>

<blockquote>
  <p>不推荐改变eBGP的外部AD或IGP AD</p>
</blockquote>

<p>BGP backdoor使IGP路由优选</p>

<p>使用 <a href="https://www.cisco.com/en/US/docs/ios/iproute_bgp/command/reference/irg_bgp4.html#wp1145478">network address backdoor</a> 命令</p>

<p>配置的网络是你希望通过IDP到达的网络，在BGP中，这个配置的网络会与本地分配的网络同样，除非BGP不宣告这个网络</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTA# 
router eigrp 10 

network 150.10.0.0 

router bgp 100 
neighbor 2.2.2.1 remote-as 300 
network 160.10.0.0 backdoor 
</code></pre></div></div>

<p>Network 160.10.0.0被视为一个本地条目，但不作为一个普通的网络条目进行宣传</p>

<p>RTA通过AD为90的EIGRP向RTB学习到160.10.0.0，RTA还通过AD为20的eBGP向RTC学习到这个地址，正常情况下,EBGP会更优，但是使用了 network backdoor命令，EIGRP会更优</p>

<h3 id="synchronization">Synchronization</h3>

<p><img src="/assets/images/bgp/b16.png" /></p>

<p>在讨论同步前，看下这个情景，RTC在AS300内发出170.10.0.0的更新，RTA和RTB运行IBGP，RTB会得到可以通过2.2.2.1的下一跳到达170.10.0.0的更新，记住这个下一跳是通过IBGP携带的，为了到达下一跳，RTB必须发送流量到RTE</p>

<p>假定没有重分布网络170.10.0.0到IGP，RTE不会知道170.10.0.0是否存在</p>

<p>如果RTB开始向AS400宣告RTB可以到达170.10.0.0，从RTD到RTB 目的为170.10.0.0的流量会被RTE丢弃</p>

<p>如果你的AS传递流量从一个AS到另外一个AS，BGP不能再AS内部的路由器通过IBGP学习到路由之前宣告这条路由，BGP要等待IGP在AS内传播这条路由，然后BGP宣告这条路由到外部对等</p>

<p>在这个例子中，RTB等待IGP的170.10.0.0，然后RTB发送更新到RTD，如果你添加了一条静态路由在RTB中到170.10.0.0，可以使RTB认为IGP已经传播了这条路由，要确保其它路由器可以到达170.10.0.0</p>

<h3 id="disable-synchronization">Disable Synchronization</h3>

<p>在一些情况中，你不需要同步信息，如果你不允许一个其它AS的流量通过你的AS，你可以关闭同步，如果所有的路由器都在你的AS中运行BGP，你可以关闭同步，这样IGP中可以减少路由条目，并且BGP可以更快的收敛</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>router bgp 100 
no synchronization
</code></pre></div></div>

<blockquote>
  <p>设置完成后一定要运行clear ip bgp命令</p>
</blockquote>

<p><img src="/assets/images/bgp/b17.png" /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTB# 
router bgp 100 
network 150.10.0.0 
neighbor 1.1.1.2 remote-as 400 
neighbor 3.3.3.3 remote-as 100 
no synchronization 

<span class="o">!</span><span class="nt">---</span> RTB puts 170.10.0.0 <span class="k">in </span>its IP routing table and advertises the network 
<span class="o">!</span><span class="nt">---</span> to RTD, even <span class="k">if </span>RTB does not have an IGP path to 170.10.0.0.

RTD# 
router bgp 400 
neighbor 1.1.1.1 remote-as 100 
network 175.10.0.0 

RTA# 
   router bgp 100 
   network 150.10.0.0 
   neighbor 3.3.3.4 remote-as 100
</code></pre></div></div>

<h3 id="weight-attribute">Weight Attribute</h3>

<p><img src="/assets/images/bgp/b18.png" /></p>

<p>weight属性是思科的私有属性，这个属性使用weigth值选择最佳路径，weight在本地分配给路由器，只会对特定的路由器有意义，不会通过任何路由更新传播，weight可以是0到65,535之间的数字，初始值为32768，其它的路径为0</p>

<p>同一个目的地由多条路由的时候，权重越高优先级越高，请看下这节的例子，RTA从AS4中学习到175.10.0.0，RTA通告更新到RTC，RTB也从AS4中学习到175.10.0.0，RTB也通告更新到RTC，RTC现在由两条路径到175.10.0.0，需要在两条路中选择一条，如果你在RTC上设置来自RTA的更新权重，强制RTC使用RTA作为到达175.10.0.0的下一跳，有几种方法可以实现</p>

<ul>
  <li>使用 neighbor 命令
    <blockquote>
      <table>
        <tbody>
          <tr>
            <td>neighbor {ip-address</td>
            <td>peer-group} weight weight</td>
          </tr>
        </tbody>
      </table>
    </blockquote>
  </li>
  <li>AS_PATH
    <blockquote>
      <table>
        <tbody>
          <tr>
            <td>ip as-path access-list access-list-number {permit</td>
            <td>deny} as-regular-expression neighbor ip-address filter-list access-list-number weight weight</td>
          </tr>
        </tbody>
      </table>
    </blockquote>
  </li>
  <li>route maps</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTC# 
router bgp 300 
neighbor 1.1.1.1 remote-as 100 
neighbor 1.1.1.1 weight 200 

<span class="o">!</span><span class="nt">---</span> The route to 175.10.0.0 from RTA has a 200 weight.

neighbor 2.2.2.2 remote-as 200 
neighbor 2.2.2.2 weight 100 

<span class="o">!</span><span class="nt">---</span> The route to 175.10.0.0 from RTB has a 100 weight.
</code></pre></div></div>

<p>RTA，具有更高的weight值，是优选的下一跳，同样也可以使用AS_PATH</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTC# 
router bgp 300 
neighbor 1.1.1.1 remote-as 100 
neighbor 1.1.1.1 filter-list 5 weight 200 
neighbor 2.2.2.2 remote-as 200 
neighbor 2.2.2.2 filter-list 6 weight 100 
... 
ip as-path access-list 5 permit ^100<span class="nv">$ </span>

<span class="o">!</span><span class="nt">---</span> This only permits path 100.

ip as-path access-list 6 permit ^200<span class="nv">$ </span>
... 
</code></pre></div></div>

<p>使用route maps</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTC# 
router bgp 300 
neighbor 1.1.1.1 remote-as 100 
neighbor 1.1.1.1 route-map setweightin <span class="k">in 
</span>neighbor 2.2.2.2 remote-as 200 
neighbor 2.2.2.2 route-map setweightin <span class="k">in</span> 
... 
ip as-path access-list 5 permit ^100<span class="nv">$ </span>
... 

route-map setweightin permit 10 
match as-path 5 
<span class="nb">set </span>weight 200 

<span class="o">!</span><span class="nt">---</span> Anything that applies to access list 5, such as packets from AS100, has weight 200.


route-map setweightin permit 20 
   <span class="nb">set </span>weight 100 

<span class="o">!</span><span class="nt">---</span> Anything <span class="k">else </span>has weight 100.
</code></pre></div></div>

<blockquote>
  <p>可以修改权重，以选择MPLS VPN BGP路径  将IGP路径作为备份</p>
</blockquote>

<h4 id="local-preference-attribute">Local Preference Attribute</h4>

<p><img src="/assets/images/bgp/b19.png" /></p>

<p>Local preference 是向AS指明哪条路径对于到达目的网络优先选择，具有高优先级的路径会优先选择，默认的Local preference 是100</p>

<p>不像weight属性，只在本地路由器起作用，Local preference 会在同一个AS内部交换传递</p>

<p>使用 <a href="https://www.cisco.com/en/US/docs/ios/12_3t/ip_route/command/reference/ip2_b1gt.html#wp1078941">bgp default local-preference value</a>设置local preference，也可以使用local preference配合route map使用，就像本节中的实例:</p>

<blockquote>
  <p>如果有变化，必要情况下需要执行软重置(就是清除路由器上的bgp进程),使用clear ip bgp [soft][in/out]清除bgp进程，soft不会重置bgp邻居， [in/out]代表接口方向，如果没有指明in或者out，默认都会重置</p>
</blockquote>

<blockquote>
  <p>bgp default local-preference 命令再路由器更新上设置本地优先级去往同AS内的对等，本节的图中显示，AS256从两个不同的组织接受170.10.0.0更新，Local preference帮助你决定使用哪条路径离开AS256到达目的网络，假如RTD是优先离开地点，这个配置对来自AS300的更新设置local preference为200，对来自AS100 的更新设置为150</p>
</blockquote>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTC# 
router bgp 256 
neighbor 1.1.1.1 remote-as 100 
neighbor 128.213.11.2 remote-as 256 
bgp default local-preference 150 

RTD# 
router bgp 256 
neighbor 3.3.3.4 remote-as 300 
neighbor 128.213.11.1 remote-as 256 
bgp default local-preference 200
</code></pre></div></div>

<p>在这个配置中RTC设置所有更新的local preference 为150，设置RTD所有更新的local preference为200，local preference 会在AS256中交换，因此，RTC和RTD认为来自AS300的170.10.0.0的更新比来自AS100的更新具有更高的优先级，所有去往AS256的流量或通过ETD出去</p>

<p>使用route map可以提供更加灵活的方法，在本章的例子中，当更新到达RTD的时候，所有RTD收到的更新都将Local preference 标记为200，来自AS34更新的local preference也被标记为200，tag不是必须的，你可以使用tag标记为特定的路由设置特定的local preference。下面是示例:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTD# 
router bgp 256 
neighbor 3.3.3.4 remote-as 300 
neighbor 3.3.3.4 route-map setlocalin <span class="k">in 
</span>neighbor 128.213.11.1 remote-as 256 
.... 
ip as-path access-list 7 permit ^300<span class="nv">$ </span>
... 

route-map setlocalin permit 10 
match as-path 7 
<span class="nb">set </span>local-preference 200 

route-map setlocalin permit 20 
<span class="nb">set </span>local-preference 150 
</code></pre></div></div>

<p>在这个配置中，任何来自AS300的更新会将local preference设置为200，其它的更新，比如来自AS34的，会将值设置为150</p>

<h4 id="metric-attribute">Metric Attribute</h4>

<p><img src="/assets/images/bgp/b20.png" /></p>

<p>metric属性也被称作MULTI_EXIT_DISCRIMINATOR，MED (BGP4), 或者 INTER_AS (BGP3),这个属性是向外部的邻居指明哪条路径进入AS更优，metric可以在另一个AS中有多个入口点时到达某个路由时提供了一种动态的方法来改变另一个AS的选路，较低的metric会更优</p>

<p>不像local preference，metric在AS间交换，metric会携带进入一个AS内部，但不会在这个AS中再向其它AS发送，当一个更新携带一个给定的metric进入到一个AS，这个metric会在这个AS中用于选路决策，当同样的更新通过第三个AS的时候，metric会归为0,图中显示了一组度量，metric默认为0</p>

<p>除非路由器接收到其它的信息，路由器会根据来自同一个AS内邻居metric对比来产生路径，为了方便对比来自不同邻居的metrics，你需要在路由器上指明 <a href="https://www.cisco.com/en/US/docs/ios/iproute_bgp/command/reference/irg_bgp1.html#wp1112034">bgp always-compare-med</a> 命令</p>

<blockquote>
  <p>有两个BGP配置命令可以影响基于多出口(MED)的路径选择，<a href="https://www.cisco.com/en/US/docs/ios/iproute_bgp/command/reference/irg_bgp1.html#wp1113816">bgp deterministic-med</a>命令和 bgp always-compare-med命令， bgp deterministic-med 命令确保当不同的对等在相同的AS中发布宣告时，在路由选择时比较MED。 bgp always-compare-med确保不同ASs中邻居路径的MED比较， bgp always-compare-med一般使用在 有多个服务提供者或者是企业要统一设置MED的策略。参考  <a href="https://www.cisco.com/en/US/tech/tk365/technologies_tech_note09186a0080094925.shtml">How the bgp deterministic-med Command Differs from the bgp always-compare-med Command</a>了解这些命令如何影响BGP路径选择</p>
</blockquote>

<p>在本节的图表中，AS100通过三个不同的路由器:RTC、RTD和RTB获取关于网络180.10.0.0的信息。RTC和RTD在AS300中，RTB在AS400中</p>

<p>在本例中，将因为命令  <a href="https://www.cisco.com/en/US/docs/ios/iproute_bgp/command/reference/irg_bgp1.html#wp1112361">bgp bestpath as-path ignore</a> 忽略对RTA的AS-Path比较，它被配置为强制BGP使用下一个属性进行路由比较(在本例中为metric或MED)，如果省略掉该命令，BGP将从路由器RTC路由到180.10.0.0，因为它具有最短的as - path。</p>

<p>假定你将来自RTC的metric设置为120，RTD的metric设置为200，RTB的metric设置为50，默认下，路由器会比较来自同一个AS内邻居的metrics，因此，RTA只能比较来自RTC的metric和来自RTD的metric,RTA选择RTC作为最佳下一跳，因为120小于200.当RTA从RTB获得度量为50的更新时,RTA无法将该指标与120进行比较，因为RTC和RTB在不同的ASs中,RTA必须根据其他一些属性进行选择。</p>

<p>为了强制RTA比较指标，您必须在RTA上发出bgp always-compare-med命令。这些配置说明了这个过程</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTA# 
   router bgp 100 
   neighbor 2.2.2.1 remote-as 300 
   neighbor 3.3.3.3 remote-as 300 
   neighbor 4.4.4.3 remote-as 400 
   bgp bestpath as-path ignore
   .... 

RTC# 
   router bgp 300 
   neighbor 2.2.2.2 remote-as 100 
   neighbor 2.2.2.2 route-map setmetricout out 
   neighbor 1.1.1.2 remote-as 300 

route-map setmetricout permit 10 
   <span class="nb">set </span>metric 120 

RTD# 
   router bgp 300 
   neighbor 3.3.3.2 remote-as 100 
   neighbor 3.3.3.2 route-map setmetricout out 
   neighbor 1.1.1.1 remote-as 300 

route-map setmetricout permit 10 
   <span class="nb">set </span>metric 200 

RTB# 
   router bgp 400 
   neighbor 4.4.4.4 remote-as 100 
   neighbor 4.4.4.4 route-map setmetricout out 

route-map setmetricout permit 10 
   <span class="nb">set </span>metric 50
</code></pre></div></div>

<p>上面的配置,RTA会选择RTC作为下一跳，考虑到所有其他属性都是相同的，为了在度量比较中包含RTB，必须以这种方式配置RTA</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTA# 
router bgp 100 
neighbor 2.2.21 remote-as 300 
neighbor 3.3.3.3 remote-as 300 
neighbor 4.4.4.3 remote-as 400 
bgp always-compare-med
</code></pre></div></div>

<p>在本例中，RTA选择RTB作为下一跳到达网络180.10.0.0</p>

<p>可以使用default-metric命令设置重分布路由的metric</p>

<p>假设在本节的示例中，RTB通过静态将网络引入AS100</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTB# 
router bgp 400 
redistribute static 
default-metric 50 
 
ip route 180.10.0.0 255.255.0.0 null 0 
</code></pre></div></div>

<h4 id="community-attribute">Community Attribute</h4>

<p>community属性是一个可传递的可选属性，范围在0到4,294,967,200之间。community属性是一种在特定community中对目标进行分组并根据这些community应用路由决策的方法。路由决策包括accept, prefer, and redistribute以及其它</p>

<p>您可以使用route map来设置community属性。route map set命令具有以下语法</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">set </span>community community-number <span class="o">[</span>additive] <span class="o">[</span>well-known-community] 
</code></pre></div></div>

<p>一些预定义的</p>
<ul>
  <li>no-export   不向EBGP对等做宣告。将此路由保存在一个AS内</li>
  <li>no-advertise  不要向任何对等(内部或外部)宣传此路由</li>
  <li>internet   在因特网community宣告这条路线。任何路由器都属于这个社区</li>
  <li>local-as  在联合场景中使用，以防止在本地AS之外传输数据包。</li>
</ul>

<p>两个通过route map 设置community的场景</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>route-map communitymap 
match ip address 1 
<span class="nb">set </span>community no-advertise
or

route-map setcommunity 
match as-path 1 
<span class="nb">set </span>community 200 additive 
</code></pre></div></div>

<p>如果你没有使用 additive 关键字,200替换任何已存在的旧的community，如果你设置了additive，community会追加200，即使设置了community属性，默认情况下该属性也不会传输给邻居，要将属性发送给邻居，必须使用此命令</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>neighbor <span class="o">{</span>ip-address | peer-group-name<span class="o">}</span> send-community 
</code></pre></div></div>

<p>例子:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTA# 
router bgp 100 
neighbor 3.3.3.3 remote-as 300 
neighbor 3.3.3.3 send-community 
neighbor 3.3.3.3 route-map setcommunity out
</code></pre></div></div>

<p>在Cisco IOS软件发行版12.0及更高版本中，您可以使用三种不同的格式配置community,decimal, hexadecimal, and AA:NN,默认情况下，思科IOS软件使用的是较老的decimal格式，如果想使用AA:NN的显示和配置，使用  ip bgp-community new-format全局配置命令，AA:NN的第一部分表示AS，第二部分表示2字节数</p>

<p>例子:</p>

<p>如果全局配置中没有ip bgp-community new-format命令，则show ip bgp 6.0.0.0命令将以decimal格式显示community属性值。在本例中，community属性值显示为6553620。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Router# show ip bgp 6.0.0.0
BGP routing table entry <span class="k">for </span>6.0.0.0/8, version 7
Paths: <span class="o">(</span>1 available, best <span class="c">#1, table Default-IP-Routing-Table)</span>
  Not advertised to any peer
  1
    10.10.10.1 from 10.10.10.1 <span class="o">(</span>200.200.200.1<span class="o">)</span>
      Origin IGP, metric 0, localpref 100, valid, external, best
      Community: 6553620
</code></pre></div></div>

<p>配置全局的 ip bgp-community new-format 命令</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Router# configure terminal
Enter configuration commands, one per line.  End with CNTL/Z.
Router<span class="o">(</span>config<span class="o">)</span><span class="c"># ip bgp-community new-format </span>
Router<span class="o">(</span>config<span class="o">)</span><span class="c"># exit</span>
</code></pre></div></div>

<p>使用ip bgp-community new-format 全局配置命令，community值以AA:NN格式显示。该值在本例中的show ip bgp 6.0.0.0命令的输出中显示为100:20</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Router# show ip bgp 6.0.0.0
BGP routing table entry <span class="k">for </span>6.0.0.0/8, version 9
Paths: <span class="o">(</span>1 available, best <span class="c">#1, table Default-IP-Routing-Table)</span>
  Not advertised to any peer
  1
    10.10.10.1 from 10.10.10.1 <span class="o">(</span>200.200.200.1<span class="o">)</span>
      Origin IGP, metric 0, localpref 100, valid, external, best
      Community: 100:20
</code></pre></div></div>]]></content><author><name>Your Name</name></author><category term="RS" /><summary type="html"><![CDATA[BGP案例02 (参考https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/26634-bgp-toc.html#neighborsroutemaps)]]></summary></entry><entry><title type="html">路由交换 - BGP案例 - 01</title><link href="/rs-bgp-01/" rel="alternate" type="text/html" title="路由交换 - BGP案例 - 01" /><published>2022-08-23T00:00:00+08:00</published><updated>2022-08-23T00:00:00+08:00</updated><id>/rs-bgp-01</id><content type="html" xml:base="/rs-bgp-01/"><![CDATA[<p>BGP案例01
(参考https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/26634-bgp-toc.html#neighborsroutemaps)</p>

<h3 id="bgp如何工作">BGP如何工作?</h3>
<p>BGP使用TCP 179端口作为传输协议，两台BGP路由器基于TCP建立连接，建立连接后的路由器成为对等(peer)，对等路由器通过交换信息打开和确认连接参数
BGP路由器交换网络可达信息，信息主要指示出路由必须经过的完整路径，以便到达目标网络。使用BGP的AS号标记路径，用于构建无环的AS图，还显示了在何处应用路由策略，以便对路由行为实施一些限制
为了交换BGP路由信息而形成TCP连接的任何两个路由器都是“对等”或“邻居”，BGP对等初始会交换完整的BGP路由表，交换之后，当路由表发生更改时，对等只会发送增量更新，BGP会对BGP表维持一个版本号，所有的BGP对等都会保持版本号一致，每当BGP路由信息发生更改而更新表时，版本号就会随之更改，keepalive数据包用来确保BGP对等之间的连接是活动的，通知包会在出现错误或特殊情况时发出</p>

<h3 id="ebgp-和-ibgp">EBGP 和 IBGP</h3>

<p>如果一个AS自治系统内有许多BGP路由器(speakers),这个AS可以为其它AS提供过境服务(传递路由)，如图所示，AS200 作为AS100和AS300的过境AS</p>

<p>为了发送信息到外部的AS，必须要保证网络的可达性，为了保证网络的可达性，会发生以下的过程:</p>

<ul>
  <li>内部BGP(ibgp)对等会在一个AS的路由器上运行</li>
  <li>将BGP信息重新分发给运行在AS中的IGP协议</li>
</ul>

<p>当BGP在属于两个不同AS的路由器之间运行时，这称为外部BGP (eBGP)。当BGP在路由器之间以相同的方式运行时，这称为iBGP</p>

<p><img src="/assets/images/bgp/b1.png" /></p>

<h3 id="启用bgp路由">启用BGP路由</h3>

<p>完成下面的配置以启用和配置BGP</p>

<p>假定你有两台路由器RTA和RTB，在第一个例子中，RTA和RTB在不同的AS中，在第二个例子中，两台路由器在一样的AS中</p>

<p>定义路由器进程和路由器所属的AS号。 使用下面的命令在路由器上启用BGP</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTA#
router bgp 100

RTB#
router bgp 200
</code></pre></div></div>

<blockquote>
  <p>这些语句表明RTA运行BGP，属于AS100。RTB运行BGP，属于AS200</p>
</blockquote>

<p>定义BGP邻居</p>

<p>BGP邻居结构表示试图通过BGP通信的路由器，BGP邻居的部分解释了这个过程</p>

<h3 id="bgp邻居">BGP邻居</h3>

<p>路由器之间建立TCP连接后，两个BGP路由器成为邻居。为了让两个对等路由器开始交换路由更新，TCP连接是必不可少的</p>

<p>在TCP连接成功后，路由器会发送open信息来交换值，路由器交换的值包括AS号、路由器运行的BGP版本、BGP路由器ID和keepalive保持时间，在确认和接受这些值之后，会建立邻居，除了Established状态外，任何状态都表明这两个路由器没有成为邻居，并且路由器不能交换BGP更新。</p>

<p>使用neighbor命令建立TCP连接</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>neighbor ip-address remote-as number
</code></pre></div></div>

<p>命令中的number表示要连接到的路由器的AS号， ip-address为直接连接eBGP的下一跳地址，在ibgp中，ip-address可以是其它路由器的任何IP地址，在对等路由器上的neighbor命令后面的Ip地址要相互可达，可以使用扩展ping来验证可达性，扩展ping要使用neighbor的IP地址来作为ping的源地址，而不能使用路由器的数据包发出地址</p>

<p>如果BGP的配置有任何的变化，你必须重置邻居连接以使新的参数生效</p>

<ul>
  <li>clear ip bgp address</li>
  <li>clear ip bgp *</li>
</ul>

<blockquote>
  <p>第一个命令的address 代表邻居的地址，第二个命令表示清楚所有的邻居连接</p>
</blockquote>

<p>默认情况下，BGP会话使用BGP 4版本并且向下兼容，如果需要，可以通过在路由器上强制设置BGP版本来实现邻居间的通信而避免协商，可以在路由器上使用下面的命令配置</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>neighbor <span class="o">{</span>ip address | peer-group-name<span class="o">}</span> version value
</code></pre></div></div>

<p>这是一个neighbor命令配置的例子</p>

<p><img src="/assets/images/bgp/b2.png" /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTA#
router bgp 100
neighbor 129.213.1.1 remote-as 200

RTB#
router bgp 200
neighbor 129.213.1.2 remote-as 100
neighbor 175.220.1.2 remote-as 200

RTC#
router bgp 200
neighbor 175.220.212.1 remote-as 200
</code></pre></div></div>

<p>在这个例子中，RTA和RTB运行EBGP,RTB和RTC运行IBGP,  remote-as后面的as号码指向外部或者内部的AS，表示是EBGP或者IBGP，而且，EBGP对等是直连，IBGP对等没有直连，IBGP路由器不需要直连，单数，它们之间不许有一些IGP运行来确保两个邻居之间可达</p>

<p>show ip bgp neighbors命令显示信息的样例</p>

<blockquote>
  <p>特别需要注意BGP的状态，除了Established，其它状态都代表对等(peers)之间没有UP</p>
</blockquote>

<blockquote>
  <p>同样，注意下面几项:</p>
  <ul>
    <li>BGP的版本，4</li>
    <li>远程路由器的router id，这个数字是路由器上最大的IP地址，或者是最高的环回接口(如果存在的话)</li>
    <li>表的版本，表版本提供表的状态。每当新信息出现时，该表都会增加版本。一个不断增加的版本表示有一些路由抖动导致路由的不断更新</li>
  </ul>
</blockquote>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># show ip bgp neighbors</span>
     BGP neighbor is 129.213.1.1, remote AS 200, external <span class="nb">link 
     </span>BGP version 4, remote router ID 175.220.12.1 
     BGP state <span class="o">=</span> Established, table version <span class="o">=</span> 3, up <span class="k">for </span>0:10:59 
     Last <span class="nb">read </span>0:00:29, hold <span class="nb">time </span>is 180, keepalive interval is 60 seconds 
     Minimum <span class="nb">time </span>between advertisement runs is 30 seconds 
     Received 2828 messages, 0 notifications, 0 <span class="k">in </span>queue 
     Sent 2826 messages, 0 notifications, 0 <span class="k">in </span>queue 
     Connections established 11<span class="p">;</span> dropped 10 
</code></pre></div></div>

<h4 id="bgp-and-loopback-interfaces">BGP and Loopback Interfaces</h4>

<p>在IBGP中通常使用loopback来定义邻居，但在EBGP中却不常见，通常，在IBGP中，使用loopback接口来确保邻居的IP地址保持正常，并且独立于正常运行的硬件。在eBGP的情况下，对等路由器经常具有直接连接，所以， 环回口不适用EBGP</p>

<p>如果你在neighbor命令中使用loopback接口的IP地址，你需要在邻居路由器中敲一些额外的配置，邻居路由器需要通知BGP使用环回接口而不是物理接口来启动BGP邻居TCP连接，为了指明使用环回口，参考下面的命令</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>neighbor ip-address update-source interface
</code></pre></div></div>

<p>这个例子演示了命令的用法</p>

<p><img src="/assets/images/bgp/b3.png" /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTA# 
     router bgp 100 
     neighbor 190.225.11.1 remote-as 100 
     neighbor 190.225.11.1 update-source loopback 1 
RTB# 
     router bgp 100 
     neighbor 150.212.1.1 remote-as 100 
</code></pre></div></div>

<p>这个例子中，RTA和RTB运行IBGP，AS号是100。在neighbor命令中，RTB使用RTA的loopback接口，150.212.1.1，这种情况下，RTA必须强制BGP在TCP邻居连接中使用loopback IP地址作为源,为了可以执行这个动作(将loopback作为源)，RTA添加了  update-source interface-type interface-number命令，也就是 neighbor 190.225.11.1 update-source loopback 1，这句话表示，当BGP和邻居190.225.11.1 通话的时候，强制使用loopback接口的IP地址</p>

<blockquote>
  <p>RTA使用RTB的物理接口190.224.11.1，作为邻居，使用物理接口地址 RTB不需要任何其它的配置，有关完整的网络场景示例配置，请参考  <a href="https://www.cisco.com/en/US/tech/tk365/technologies_configuration_example09186a0080093f25.shtml">Sample Configuration for iBGP and eBGP With or Without a Loopback Address</a></p>
</blockquote>

<h3 id="ebgp-multihop">EBGP Multihop</h3>

<p>有一些情况，思科路由器可以和不允许直连的其它路由器之间运行EBGP，为了实现这种连接，你可以使用EBGP多跳，EBGP多跳可以将两台无法直连的外部对等中间实现连接，多跳只可以在ebgp中实现，不支持ibgp，下面是ebgp 多跳的例子</p>

<p><img src="/assets/images/bgp/b4.png" /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTA# 
router bgp 100 
neighbor 180.225.11.1 remote-as 300 
neighbor 180.225.11.1 ebgp-multihop 
RTB# 
router bgp 300 
neighbor 129.213.1.2 remote-as 100
</code></pre></div></div>

<p>RTA显示没有直接连接的外部邻居，RTA需要使用 <a href="https://www.cisco.com/en/US/docs/ios/iproute_bgp/command/reference/irg_bgp3.html#wp1106590">neighbor ebgp-multihop</a>命令，在另一边，RTB指出直连的邻居，129.213.1.2，因为是直连，RTB不需要使用 neighbor ebgp-multihop命令，你还应该配置IGP或静态路由，以允许没有连接的邻居彼此连接。</p>

<p><a href="https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/26634-bgp-toc.html#ebgpmulithoploadbal">eBGP Multihop (Load Balancing)</a> 演示如何在使用EBGP平行连接的情况下使用BGP实现负载平衡。</p>

<p>eBGP Multihop (Load Balancing)</p>

<p><img src="/assets/images/bgp/b5.png" /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTA# 
int loopback 0 
ip address 150.10.1.1 255.255.255.0 
router bgp 100 
neighbor 160.10.1.1 remote-as 200 
neighbor 160.10.1.1 ebgp-multihop 
neighbor 160.10.1.1 update-source loopback 0 
network 150.10.0.0 
 
ip route 160.10.0.0 255.255.0.0 1.1.1.2 
ip route 160.10.0.0 255.255.0.0 2.2.2.2 
RTB# 
int loopback 0 
ip address 160.10.1.1 255.255.255.0 
router bgp 200 
neighbor 150.10.1.1 remote-as 100 
neighbor 150.10.1.1 update-source loopback 0 
neighbor 150.10.1.1 ebgp-multihop 
network 160.10.0.0 
 
ip route 150.10.0.0 255.255.0.0 1.1.1.1 
ip route 150.10.0.0 255.255.0.0 2.2.2.1
</code></pre></div></div>

<p>这个例子演示了使用 loopback interfaces, update-source, and ebgp-multihop,该示例是一个解决方案，目的是在并行串行线路上实现两个EBGP路由器之间的负载平衡。在正常情况下，BGP会选择一条线路发包，不会发生负载均衡的情况，但引入了环回口，EBGP的吓一跳是环回口，你使用静态路由，或者是IGP,引入两条相等cost路径到达目的地,RTA有两个选择到达下一跳160.10.1.1,一条路径通过1.1.1.2，另一条路径通过2.2.2.2。RTB也有同样的选择</p>

<h3 id="route-maps">Route Maps</h3>

<p>在BGP中大量使用route maps,在BGP的环境中，route map是一种控制和修改路由信息的方法。路由信息的控制和修改是通过定义从一个路由协议到另一个路由协议的路由重分发条件来实现的，或者路由信息的控制可以在BGP进入和发出的时候，route map的命令格式如下</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>route-map map-tag <span class="o">[[</span>permit | deny] | <span class="o">[</span>sequence-number]] 
</code></pre></div></div>

<p>map tag 是给route map起个名字。可以为相同名字或者route map定义多个实例，序列号用来指明在route map中的位置</p>

<p>在这个例子中，为route map定义了两个实例，使用MYMAP的名字.洗一个实例使用10的序号，第二个实例使用20的序号</p>

<ul>
  <li>route-map MYMAP permit 10 (这里设置第一个条件)</li>
  <li>route-map MYMAP permit 20 (这里设置第二个条件)</li>
</ul>

<p>当将route map应用到路由的出方向或者入方向，第一个条件通过实例10来应用，如果第一个条件没有满足，则会继续匹配更高序号的条件</p>

<h4 id="match-and-set-configuration-commands">match and set Configuration Commands</h4>

<p>每个route map 由一组match 和set配置命令组成。match指定匹配条件，set 指定一个set操作，如果match匹配则会执行set操作</p>

<p>例如，你可以定义一个route map检查发出去的更新，如果匹配ip 1.1.1.1的地址，就把这个更新的metric设置为5</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>match ip address 1.1.1.1 
<span class="nb">set </span>metric 5
</code></pre></div></div>

<p>现在，如果你匹配了条件并且添加了permit，就会对路由重新发布，进行set的操作，并且退出</p>

<p>如果你匹配到了条件，并且添加了deny，没有对路由的重新分配或控制，并且退出</p>

<p>如果match没有匹配到并且你设置了permit或者deny，会检查route map的下一个实例。例如，检查实例20。下一个实例检查将继续进行，直到断开或完成route map的所有实例。如果所有的实例都检查完却没有匹配上，则不会接受这条路由或者不转发这条路由</p>

<p>在思科的IOS 11.2之前的版本，如果你使用route maps过滤BGP更新而不是使用在协议间使用重分发,在IP地址上使用match命令时，无法对入站进行筛选，出站可以过滤，11.2之后的版本没有这个限制</p>

<p>相关的match命令</p>
<ul>
  <li>match as-path</li>
  <li>match community</li>
  <li>match clns</li>
  <li>match interface</li>
  <li>match ip address</li>
  <li>match ip next-hop</li>
  <li>match ip route-source</li>
  <li>match metric</li>
  <li>match route-type</li>
  <li>match tag</li>
</ul>

<p>set相关</p>
<ul>
  <li>set as-path</li>
  <li>set clns</li>
  <li>set automatic-tag</li>
  <li>set community</li>
  <li>set interface</li>
  <li>set default interface</li>
  <li>set ip default next-hop</li>
  <li>set level</li>
  <li>set local-preference</li>
  <li>set metric</li>
  <li>set metric-type</li>
  <li>set next-hop</li>
  <li>set origin</li>
  <li>set tag set weight</li>
</ul>

<p>看一个route map的例子</p>

<p><img src="/assets/images/bgp/b6.png" /></p>

<p>假设RTA和RTB运行路由信息协议(RIP)， RTA和RTC运行BGP。RTA通过BGP获取更新并将更新重新分发到RIP。假设RTA希望将170.10.0.0路由重分发到RTB设置度量为2，而所有其他路由的度量为5。在这种情况下，可以使用这种配置</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTA#
router rip
network 3.0.0.0
network 2.0.0.0
network 150.10.0.0
passive-interface Serial0
redistribute bgp 100 route-map SETMETRIC

router bgp 100
neighbor 2.2.2.3 remote-as 300
network 150.10.0.0

route-map SETMETRIC permit 10
match ip-address 1
<span class="nb">set </span>metric 2

route-map SETMETRIC permit 20
<span class="nb">set </span>metric 5

access-list 1 permit 170.10.0.0 0.0.255.255

</code></pre></div></div>

<p>在本例中，如果路由匹配IP地址170.10.0.0，则该路由的度量为2。然后，退出route map。如果没有匹配，您将继续执行route map，会将其他所有的metric 设置为 5(也就是没有match 默认匹配所有)</p>

<blockquote>
  <p>不匹配任何匹配语句的路由会发生什么情况? 默认情况下，这些路由将被删除</p>
</blockquote>

<p>例子2</p>

<p>假设，在示例1中，不希望AS100接受关于170.10.0.0的更新。当将IP地址作为基础匹配时，不能将route map应用于入站方向。因此，你必须在RTC上的出站方向使用route map:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTC#

router bgp 300
network 170.10.0.0
neighbor 2.2.2.2 remote-as 100
neighbor 2.2.2.2 route-map STOPUPDATES out

route-map STOPUPDATES permit 10
match ip address 1

access-list 1 deny 170.10.0.0 0.0.255.255
access-list 1 permit 0.0.0.0 255.255.255.255
</code></pre></div></div>

<p>现在，已经对如何启动BGP和如何定义邻居已经比较熟悉了，接下来看看如何启动网络信息交换。
使用BGP发送网络信息有多种方式。这些部分将逐一介绍这些方法</p>

<ul>
  <li>Network Command</li>
  <li>Redistribution</li>
  <li>Static Routes and Redistribution</li>
</ul>

<h3 id="network-command">network Command</h3>

<p>network 的命令</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>network network-number <span class="o">[</span>mask network-mask]
</code></pre></div></div>

<p>network命令不同于IGRP和RIP，不要尝试在接口上运行BGP，network命令使用mask部分,因为BGP version 4 (BGP4)可以处理子网和上网。最多可以接受200个网络命令条目。</p>

<p>如果路由器知道要宣告的网络，无论是连接的、静态的还是动态学习的，network命令都可以工作。</p>

<p>一个network命令的例子</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTA#
router bgp 1
network 192.213.0.0 mask 255.255.0.0
ip route 192.213.0.0 255.255.0.0 null 0
</code></pre></div></div>

<p>这个例子表明路由器A为192.213.0.0/16生成一个网络条目。/16表示您使用了一个类C地址的超网络，并为前两个八位或前16位做了宣告</p>

<blockquote>
  <p>需要使用静态路由使路由器生成192.213.0.0，因为静态路由会在路由表中放入一个匹配的条目</p>
</blockquote>

<h4 id="redistribution">Redistribution</h4>

<p>network命令是通过BGP宣告网络的一种方式，另外一种方式是重发布你的IGP到BGP中，IGP可以是IGRP\OSPF\RIP\EIGRP\或者其它协议.重发布看起来很恐怖，因为会将所有内部路由都转储到BGP中。其中一些路由是通过BGP学习的，所以不需要再次发送它们，要仔细筛选路由信息，以确保你想发布到internet的是唯一的路由，而不是发送有的的路由出去</p>

<p>RTA宣布129.213.1.0,RTC宣布175.220.0.0。看看RTC配置</p>

<p><img src="/assets/images/bgp/b7.png" /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTC#
router eigrp 10
network 175.220.0.0
redistribute bgp 200
default-metric 1000 100 250 100 1500

router bgp 200
neighbor 1.1.1.1 remote-as 300
network 175.220.0.0 mask 255.255.0.0 
</code></pre></div></div>

<p>如果你使用重发布</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTC#
router eigrp 10
network 175.220.0.0
redistribute bgp 200
default-metric 1000 100 250 100 1500

router bgp 200
neighbor 1.1.1.1 remote-as 300
redistribute eigrp 10
</code></pre></div></div>

<blockquote>
  <p>EIGRP注入129.213.1.0到BGP中</p>
</blockquote>

<p>这种重新分配会导致AS生成129.213.1.0网段。但你不是129.213.1.0的来源，AS100是源。因此，必须使用过滤器来防止AS将源从网络中删除。正确的配置是</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTC#
router eigrp 10
network 175.220.0.0
redistribute bgp 200
default-metric 1000 100 250 100 1500

router bgp 200
neighbor 1.1.1.1 remote-as 300
neighbor 1.1.1.1 distribute-list 1 out
redistribute eigrp 10

access-list 1 permit 175.220.0.0 0.0.255.255
</code></pre></div></div>

<p>可以使用access-list命令来控制源自AS200的网络</p>

<p>OSPF在BGP中的重分布与在其他igp中的重分布略有不同，redistribute ospf 1 在router bgp下不会生效，需要指明 internal, external, 和nssa-external，参考  <a href="https://www.cisco.com/en/US/tech/tk365/technologies_tech_note09186a00800943c5.shtml">Understanding Redistribution of OSPF Routes into BGP</a></p>

<h4 id="static-routes-and-redistribution">Static Routes and Redistribution</h4>

<p>可以使用静态路由去创建一个网络或者子网的路由，唯一不同的是BGP会认为这个路由是未知的或者是不完整的，下面是和重分布例子一样的结果</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTC#
router eigrp 10
network 175.220.0.0
redistribute bgp 200
default-metric 1000 100 250 100 1500

router bgp 200
neighbor 1.1.1.1 remote-as 300
redistribute static
...
ip route 175.220.0.0 255.255.255.0 null0
....

</code></pre></div></div>

<p>null0接口会忽略掉这个包，所以，如果你接收到一个包，而且可以匹配到比175.220.0.0更精确的路由，路由器会通过这个更精确的路由发送包，然而，如果匹配不到，路由器会忽略这个包，这个办法是宣告超网的好办法</p>

<p>本文讨论了如何使用不同的方法从AS中创建路由，请记住，这些路由是在BGP通过邻居学习的其他BGP路由之外生成的(内部或者外部),BGP将通过BGP从其它对等学习到的信息传递给其它对等，不同之处在于，路由是从network命令、重发布，或者是静态作为这些路由器的源，重分布一直都是将BGP引入IGP的方法</p>

<p><img src="/assets/images/bgp/b8.png" /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTA#
router bgp 100
neighbor 150.10.20.2 remote-as 300
network 150.10.0.0

RTB#
router bgp 200
neighbor 160.10.20.2 remote-as 300
network 160.10.0.0

RTC#
router bgp 300
neighbor 150.10.20.1 remote-as 100
neighbor 160.10.20.1 remote-as 200
network 170.10.00
</code></pre></div></div>

<blockquote>
  <p>在RTC中，不需要网络150.10.0.0或网络160.10.0.0，除非希望RTC生成这些网络，并在这些网络从AS100和AS200传入时传递这些网络。同样，区别在于network命令为这些相同的网络添加了一个额外的宣告，这表明AS300也是这些路由的来源</p>
</blockquote>

<blockquote>
  <p>请记住，BGP不接受源自其自身的AS更新。确保无环的域间拓扑</p>
</blockquote>

<p>例如，例子中的AS200和AS100有一个直连，RTA产生一个路由150.10.0.0并且发送这个路由到AS300，然后，RTC将路由传递到AS200，源为AS100，RTB传递150.10.0.0到AS100，源仍然是AS100。RTA注意到更新源自它自己的AS，忽略了更新</p>

<h3 id="ibgp">IBGP</h3>

<p>可以使用IBGP作为其它AS的中转AS.通过学习EBGP，重新分布到IGP中，然后再重新分布到另一个AS中，可以实现同样的功能麽?是的，但是IBGP提供了更灵活和更有效的方法来在AS中交换信息,例如BGP提供一种方式控制local preference来作为AS的出口，<a href="https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/26634-bgp-toc.html#localpref">Local Preference Attribute</a>提供更多的信息</p>

<p><img src="/assets/images/bgp/b9.png" /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTA#
router bgp 100
neighbor 190.10.50.1 remote-as 100
neighbor 170.10.20.2 remote-as 300
network 150.10.0.0

RTB#
router bgp 100
neighbor 150.10.30.1 remote-as 100
neighbor 175.10.40.1 remote-as 400
network 190.10.50.0

RTC#
router bgp 400
neighbor 175.10.40.2 remote-as 100
network 175.10.0.0
</code></pre></div></div>

<blockquote>
  <p>记住，当一个自治系统中的BGP路由器接收到来自其它路由器的更新信息，收到更新信息的BGP路由器不会将该信息重新分发给其它BGP路由器(同一个AS内)，接收更新的BGP路由器会将信息重新分发给AS之外的其他BGP路由器，因此，在一个AS中要保持IBGP路由器之间的全互联</p>
</blockquote>

<p>上面的例子中，RTA和RTB运行IBGP，RTA和RTD运行IBGP，RTB的BGP的更新到RTA传到RTE，RTE是外部AS，更新不会传给RTD，因为是内部AS，因此，在RTB和RTD之间建立一个IBGP对等，以避免中断更新信息</p>

<h4 id="the-bgp-decision-algorithm">The BGP Decision Algorithm</h4>

<p>当BGP接收到来自不同自治系统的关于不同目的地的更新后，协议必须选择到达特定目的地的路径。BGP只选择一条路径到达特定的目的地。</p>

<p>BGP基于不同的属性进行决策，例如next hop, administrative weights, local preference, route origin, path length, origin code, metric和其它属性</p>

<p>BGP总是向邻居传递最佳路径,参考  <a href="https://www.cisco.com/en/US/tech/tk365/technologies_tech_note09186a0080094431.shtml">BGP Best Path Selection Algorithm</a></p>]]></content><author><name>Your Name</name></author><category term="RS" /><summary type="html"><![CDATA[BGP案例01 (参考https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/26634-bgp-toc.html#neighborsroutemaps)]]></summary></entry><entry><title type="html">`Python 装饰器 - 02`</title><link href="/python-decorator-02/" rel="alternate" type="text/html" title="`Python 装饰器 - 02`" /><published>2022-08-22T00:00:00+08:00</published><updated>2022-08-22T00:00:00+08:00</updated><id>/python-decorator-02</id><content type="html" xml:base="/python-decorator-02/"><![CDATA[<p>Python装饰器介绍</p>

<h3 id="装饰类">装饰类</h3>

<p>在类中有两种不通的方式使用装饰器，第一个和我们之前做过的函数非常相似:在类的方法上应用。这也是当时引入装饰器的原因之一</p>

<p>一些常用的装饰器已经内置到python中，像@classmethod @staticmethod @property。这三个装饰器我们之前都介绍过，这段就不翻译了(打字手酸，偷懒下)</p>

<p>下面的Circle 类使用了@classmethod @staticmethod和@property三个装饰器</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Circle</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radius</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_radius</span> <span class="o">=</span> <span class="n">radius</span>

    <span class="o">@</span><span class="nb">property</span>
    <span class="k">def</span> <span class="nf">radius</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""Get value of radius"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">_radius</span>

    <span class="o">@</span><span class="n">radius</span><span class="p">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">radius</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="s">"""Set radius, raise error if negative"""</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">_radius</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nb">ValueError</span><span class="p">(</span><span class="s">"Radius must be positive"</span><span class="p">)</span>

    <span class="o">@</span><span class="nb">property</span>
    <span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""Calculate area inside circle"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">pi</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="p">.</span><span class="n">radius</span><span class="o">**</span><span class="mi">2</span>

    <span class="k">def</span> <span class="nf">cylinder_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">height</span><span class="p">):</span>
        <span class="s">"""Calculate volume of cylinder with circle as base"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">area</span> <span class="o">*</span> <span class="n">height</span>

    <span class="o">@</span><span class="nb">classmethod</span>
    <span class="k">def</span> <span class="nf">unit_circle</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="s">"""Factory method creating a circle with radius 1"""</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="o">@</span><span class="nb">staticmethod</span>
    <span class="k">def</span> <span class="nf">pi</span><span class="p">():</span>
        <span class="s">"""Value of π, could use math.pi instead though"""</span>
        <span class="k">return</span> <span class="mf">3.1415926535</span>
</code></pre></div></div>

<p>在这个类中</p>
<blockquote>
  <p>.cylinder_volume()是一个常规函数
.radius是一个可变属性:它可以被设置不同的值.然而通过定义setter方法，我们可以做一些判断来确保它不会被设置成一个没有意义的负数，.radius作为属性访问，不使用括号
.area 是一个不可变的属性:没有.setter()方法的属性是无法更改的，即使它被定义为一个方法，它也被作为不需要括号的属性来使用。
.unit_circle() 是一个类方法。它不被绑定到Circle的实例上.类方法通常用在工厂模式，用来创建类的特殊实例
.pi() 是一个静态方法.除了命名空间外它不依赖Circle类。静态方法可以在实例或类上调用。</p>
</blockquote>

<p>Circle类的使用例子</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">Circle</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">radius</span>
<span class="mi">5</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">area</span>
<span class="mf">78.5398163375</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">radius</span> <span class="o">=</span> <span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">area</span>
<span class="mf">12.566370614</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">area</span> <span class="o">=</span> <span class="mi">100</span>
<span class="nb">AttributeError</span><span class="p">:</span> <span class="n">can</span><span class="s">'t set attribute

&gt;&gt;&gt; c.cylinder_volume(height=4)
50.265482456

&gt;&gt;&gt; c.radius = -1
ValueError: Radius must be positive

&gt;&gt;&gt; c = Circle.unit_circle()
&gt;&gt;&gt; c.radius
1

&gt;&gt;&gt; c.pi()
3.1415926535

&gt;&gt;&gt; Circle.pi()
3.1415926535
</span></code></pre></div></div>

<p>让我们定义一个类，在这个类中，我们会用到前面的@debug和@timer装饰器:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">decorators</span> <span class="kn">import</span> <span class="n">debug</span><span class="p">,</span> <span class="n">timer</span>

<span class="k">class</span> <span class="nc">TimeWaster</span><span class="p">:</span>
    <span class="o">@</span><span class="n">debug</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_num</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">max_num</span> <span class="o">=</span> <span class="n">max_num</span>

    <span class="o">@</span><span class="n">timer</span>
    <span class="k">def</span> <span class="nf">waste_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_times</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_times</span><span class="p">):</span>
            <span class="nb">sum</span><span class="p">([</span><span class="n">i</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">max_num</span><span class="p">)])</span>
</code></pre></div></div>

<p>看一下结果:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">tw</span> <span class="o">=</span> <span class="n">TimeWaster</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
<span class="n">Calling</span> <span class="n">__init__</span><span class="p">(</span><span class="o">&lt;</span><span class="n">time_waster</span><span class="p">.</span><span class="n">TimeWaster</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x7efccce03908</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="s">'__init__'</span> <span class="n">returned</span> <span class="bp">None</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">tw</span><span class="p">.</span><span class="n">waste_time</span><span class="p">(</span><span class="mi">999</span><span class="p">)</span>
<span class="n">Finished</span> <span class="s">'waste_time'</span> <span class="ow">in</span> <span class="mf">0.3376</span> <span class="n">secs</span>
</code></pre></div></div>

<p>另外一种方式是在整个类上使用装饰器.这里有个Python3.7中的dataclasses方法用例:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>

<span class="o">@</span><span class="n">dataclass</span>
<span class="k">class</span> <span class="nc">PlayingCard</span><span class="p">:</span>
    <span class="n">rank</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">suit</span><span class="p">:</span> <span class="nb">str</span>
</code></pre></div></div>

<p>语法的类似于函数装饰器。在上面的例子中，也可以通过PlayingCard = dataclass(PlayingCard)来实现。</p>

<p>类装饰器的一种简单用法是作为元类方式的替代.在两种情况下，你都在动态的改变一个类的定义</p>

<p>类的装饰器和函数的装饰器语法接近，不同的是装饰器需要接收一个类而不是一个函数作为参数.事实上，上面的装饰器都可以作用于类，但当你这么用的时候，你可能得不到预期的结果。下面将@timer装饰器应用到一个类</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">decorators</span> <span class="kn">import</span> <span class="n">timer</span>

<span class="o">@</span><span class="n">timer</span>
<span class="k">class</span> <span class="nc">TimeWaster</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_num</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">max_num</span> <span class="o">=</span> <span class="n">max_num</span>

    <span class="k">def</span> <span class="nf">waste_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_times</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_times</span><span class="p">):</span>
            <span class="nb">sum</span><span class="p">([</span><span class="n">i</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">max_num</span><span class="p">)])</span>
</code></pre></div></div>

<p>@timer只是TimeWaster = timer(TimeWaster)的缩写</p>

<p>在这里@timer只能显示类实例化需要的时间</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">tw</span> <span class="o">=</span> <span class="n">TimeWaster</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
<span class="n">Finished</span> <span class="s">'TimeWaster'</span> <span class="ow">in</span> <span class="mf">0.0000</span> <span class="n">secs</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">tw</span><span class="p">.</span><span class="n">waste_time</span><span class="p">(</span><span class="mi">999</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span>
</code></pre></div></div>
<p>在后面会有一个正确的类装饰器的示例@singleton。它保证一个类只有一个实例</p>

<h3 id="嵌套的装饰器">嵌套的装饰器</h3>

<p>可以将多个装饰器叠加到一个函数上</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">decorators</span> <span class="kn">import</span> <span class="n">debug</span><span class="p">,</span> <span class="n">do_twice</span>

<span class="o">@</span><span class="n">debug</span>
<span class="o">@</span><span class="n">do_twice</span>
<span class="k">def</span> <span class="nf">greet</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Hello </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div>

<p>运行的顺序会按照叠加的顺序, @debug 调用 @do_twice @do_twice 调用greet()，或者debug(do_twice(greet()))</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">greet</span><span class="p">(</span><span class="s">"Eva"</span><span class="p">)</span>
<span class="n">Calling</span> <span class="n">greet</span><span class="p">(</span><span class="s">'Eva'</span><span class="p">)</span>
<span class="n">Hello</span> <span class="n">Eva</span>
<span class="n">Hello</span> <span class="n">Eva</span>
<span class="s">'greet'</span> <span class="n">returned</span> <span class="bp">None</span>
</code></pre></div></div>
<p>更改@debug和@do_twice的顺序:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">decorators</span> <span class="kn">import</span> <span class="n">debug</span><span class="p">,</span> <span class="n">do_twice</span>

<span class="o">@</span><span class="n">do_twice</span>
<span class="o">@</span><span class="n">debug</span>
<span class="k">def</span> <span class="nf">greet</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Hello </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>  
</code></pre></div></div>
<p>在这种情况下，@do_twice也会被应用到@debug中:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">greet</span><span class="p">(</span><span class="s">"Eva"</span><span class="p">)</span>
<span class="n">Calling</span> <span class="n">greet</span><span class="p">(</span><span class="s">'Eva'</span><span class="p">)</span>
<span class="n">Hello</span> <span class="n">Eva</span>
<span class="s">'greet'</span> <span class="n">returned</span> <span class="bp">None</span>
<span class="n">Calling</span> <span class="n">greet</span><span class="p">(</span><span class="s">'Eva'</span><span class="p">)</span>
<span class="n">Hello</span> <span class="n">Eva</span>
<span class="s">'greet'</span> <span class="n">returned</span> <span class="bp">None</span>
</code></pre></div></div>

<h3 id="带参数的装饰器">带参数的装饰器</h3>
<p>在需要传参给你的装饰器是这个例子会非常有用。例如,@do_twice可以扩展到@repeat(num_times)装饰器.然后，可以将执行的被装饰函数的次数作为参数给出。    <br />
可以这么做:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">repeat</span><span class="p">(</span><span class="n">num_times</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">greet</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Hello </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>      
        
<span class="o">&gt;&gt;&gt;</span> <span class="n">greet</span><span class="p">(</span><span class="s">"World"</span><span class="p">)</span>
<span class="n">Hello</span> <span class="n">World</span>
<span class="n">Hello</span> <span class="n">World</span>
<span class="n">Hello</span> <span class="n">World</span>
<span class="n">Hello</span> <span class="n">World</span> 
</code></pre></div></div>

<p>考虑下如何实现这个功能</p>

<p>到目前为止,写在@后面写的名字引用一个可以被另外一个函数调用的函数对象，需要repeat(num_times=4)来返回一个函数对象，这个对象可以被作为装饰器，幸运的是，我们已经知道如何返回函数!一般来说，需要以下内容:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="n">num_times</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">decorator_repeat</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="p">...</span>  <span class="c1"># Create and return a wrapper function
</span>    <span class="k">return</span> <span class="n">decorator_repeat</span>
</code></pre></div></div>

<p>通常，装饰器创建并返回一个内部包装函数，所以完整地写出这个例子会给你一个内部函数</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="n">num_times</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">decorator_repeat</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="o">@</span><span class="n">functools</span><span class="p">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapper_repeat</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_times</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">wrapper_repeat</span>
    <span class="k">return</span> <span class="n">decorator_repeat</span>
</code></pre></div></div>
<p>例子看起来有点乱，但我们只是添加了一个def来接收参数，这个装饰器语法我们之前处理过多次.让我们从最里面的函数开始:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">wrapper_repeat</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_times</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">value</span>
</code></pre></div></div>

<p>wrapper_repeat()函数接收任意参数，并放回被装饰函数的值，func(). 这个包装函数还包括了被装饰函数num_times的循环 ，除了必须要使用外部参数num_times外，和之前看到的装饰器函数没有什么不同，</p>

<p>再走一步，你就会发现装饰器函数:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">decorator_repeat</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="o">@</span><span class="n">functools</span><span class="p">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper_repeat</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="p">...</span>
    <span class="k">return</span> <span class="n">wrapper_repeat</span>
</code></pre></div></div>

<p>decorator_repeat()和我们之前写的装饰器函数非常像,除了他的名字不同,因为我们为最外层的函数保留了基础名称repeat()，这个是用户要调用的函数。</p>

<p>最外层返回装饰器函数的引用</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="n">num_times</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">decorator_repeat</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="p">...</span>
    <span class="k">return</span> <span class="n">decorator_repeat</span>
</code></pre></div></div>

<p>在repeat()中有一些细节:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    将decorator_repeat()作为一个内部函数意味着repeat()将引用一个函数对象-decotator_repeat.之前，我们用没有括号的repeat来引用函数对象.定义带有参数的装饰器，就需要添加括号
    
    num_times参数看起来没有在repeat()本身中使用，但是通过传递num_times，会创建一个闭包，来存储num_times的值，直到wrapper_repeat()使用它为止。
</code></pre></div></div>

<p>一切就绪后，让我们看看结果:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">repeat</span><span class="p">(</span><span class="n">num_times</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">greet</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Hello </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">greet</span><span class="p">(</span><span class="s">"World"</span><span class="p">)</span>
<span class="n">Hello</span> <span class="n">World</span>
<span class="n">Hello</span> <span class="n">World</span>
<span class="n">Hello</span> <span class="n">World</span>
<span class="n">Hello</span> <span class="n">World</span>
</code></pre></div></div>

<p>这是我们想要的结果</p>

<h3 id="both-please-but-never-mind-the-bread">Both Please, But Never Mind the Bread</h3>

<p>稍微注意下.你可以把装饰器同时定义为带参数或者不带参数.你可能不需要这样，但更有灵活性也不错</p>

<p>前面已经看到，当装饰器需要参数的时候，需要有一个额外的外部函数，困难在于，代码需要知道装饰器是否被调用了，是否有参数</p>

<p>因为只有在没有参数的情况下调用装饰器时才会直接传递装饰的函数，这个函数必须是可选参数.意味着装饰器参数必须要友关键字指定，可以使用特殊的*，也就是说，下面的参数都是关键字</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="n">_func</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">kw1</span><span class="o">=</span><span class="n">val1</span><span class="p">,</span> <span class="n">kw2</span><span class="o">=</span><span class="n">val2</span><span class="p">,</span> <span class="p">...):</span>  <span class="c1"># 1
</span>    <span class="k">def</span> <span class="nf">decorator_name</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="p">...</span>  <span class="c1"># Create and return a wrapper function.
</span>
    <span class="k">if</span> <span class="n">_func</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">decorator_name</span>                      <span class="c1"># 2
</span>    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">decorator_name</span><span class="p">(</span><span class="n">_func</span><span class="p">)</span>               <span class="c1"># 3
</span></code></pre></div></div>

<p>_func参数是一个标记，提示装饰器被调用的时候是否有参数
    1.如果name调用的时候没有传参,被装饰函数会被作为_func传入.如果有参数传入,_func会被置为None,一些关键字参数可能已不再是默认值， 参数列表中的*表示其余参数不能作为位置参数调用。
    2.装饰器可以传参调用，返回一个装饰器函数，它可以读取和返回一个函数
    3.装饰器不可以传参调用,会只将装饰器应用到函数上</p>

<p>改造下之前的@repeat装饰器</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="n">_func</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">num_times</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">decorator_repeat</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="o">@</span><span class="n">functools</span><span class="p">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapper_repeat</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_times</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">wrapper_repeat</span>

    <span class="k">if</span> <span class="n">_func</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">decorator_repeat</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">decorator_repeat</span><span class="p">(</span><span class="n">_func</span><span class="p">)</span><span class="n">n</span>
</code></pre></div></div>

<p>和之前的对比,唯一的变化是在末尾添加了_func参数和if-else。
这些例子表明，@repeat现在可以在有或没有参数的情况下使用:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">repeat</span>
<span class="k">def</span> <span class="nf">say_whee</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Whee!"</span><span class="p">)</span>

<span class="o">@</span><span class="n">repeat</span><span class="p">(</span><span class="n">num_times</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">greet</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Hello </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div>

<p>默认情况num_times的值是2</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">say_whee</span><span class="p">()</span>
<span class="n">Whee</span><span class="err">!</span>
<span class="n">Whee</span><span class="err">!</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">greet</span><span class="p">(</span><span class="s">"Penny"</span><span class="p">)</span>
<span class="n">Hello</span> <span class="n">Penny</span>
<span class="n">Hello</span> <span class="n">Penny</span>
<span class="n">Hello</span> <span class="n">Penny</span>
</code></pre></div></div>

<h3 id="有状态的装饰器">有状态的装饰器</h3>
<p>有时候，可以跟踪状态的装饰器也是很有用的.一个简单的例子，我们会创建一个统计函数调用次数的装饰器</p>

<p>注意:在教程的前面，我们讨论了基于给定参数返回值的纯函数.有状态的装饰器正好相反,返回值取决于当前状态以及给定的参数。</p>

<p>在下一节中，您将看到如何使用类来保持状态。但在简单的情况下，也可以使用函数属性</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">functools</span>

<span class="k">def</span> <span class="nf">count_calls</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="o">@</span><span class="n">functools</span><span class="p">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper_count_calls</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">wrapper_count_calls</span><span class="p">.</span><span class="n">num_calls</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Call </span><span class="si">{</span><span class="n">wrapper_count_calls</span><span class="p">.</span><span class="n">num_calls</span><span class="si">}</span><span class="s"> of </span><span class="si">{</span><span class="n">func</span><span class="p">.</span><span class="n">__name__</span><span class="si">!r}</span><span class="s">"</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">wrapper_count_calls</span><span class="p">.</span><span class="n">num_calls</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">wrapper_count_calls</span>

<span class="o">@</span><span class="n">count_calls</span>
<span class="k">def</span> <span class="nf">say_whee</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Whee!"</span><span class="p">)</span>
</code></pre></div></div>

<p>状态——函数的调用次数——存储在包裹函数(wrapper_count_calls)的函数属性.num_calls中。下面是使用它的效果:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">say_whee</span><span class="p">()</span>
<span class="n">Call</span> <span class="mi">1</span> <span class="n">of</span> <span class="s">'say_whee'</span>
<span class="n">Whee</span><span class="err">!</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">say_whee</span><span class="p">()</span>
<span class="n">Call</span> <span class="mi">2</span> <span class="n">of</span> <span class="s">'say_whee'</span>
<span class="n">Whee</span><span class="err">!</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">say_whee</span><span class="p">.</span><span class="n">num_calls</span>
<span class="mi">2</span>
</code></pre></div></div>

<h3 id="类装饰器">类装饰器</h3>
<p>典型的维护状态的方式是使用类。在本节中，将看到如何重写@count_calls的例子来实现类装饰器</p>

<p>回想一下，装饰器语法@my_decorator只是func = my_decorator(func)一种方便快捷的用法.因此，如果my_decorator是一个类，需要在它的.__init__方法中接收func作为一个参数.而且,这个类需要是可以被调用的,这样它就可以替代装饰器函数了</p>

<p>如果需要一个类可以被调用,要实现.__call__方法</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Counter</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">start</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Current count is </span><span class="si">{</span><span class="bp">self</span><span class="p">.</span><span class="n">count</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div>

<p>__call__方法每次运行都会尝试调用一个类的实例：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">counter</span><span class="p">()</span>
<span class="n">Current</span> <span class="n">count</span> <span class="ow">is</span> <span class="mi">1</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">counter</span><span class="p">()</span>
<span class="n">Current</span> <span class="n">count</span> <span class="ow">is</span> <span class="mi">2</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">counter</span><span class="p">.</span><span class="n">count</span>
<span class="mi">2</span>
</code></pre></div></div>

<p>因此，实现类装饰器需要实现.<strong>init__和.__call</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">functools</span>

<span class="k">class</span> <span class="nc">CountCalls</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="n">functools</span><span class="p">.</span><span class="n">update_wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">num_calls</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">num_calls</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Call </span><span class="si">{</span><span class="bp">self</span><span class="p">.</span><span class="n">num_calls</span><span class="si">}</span><span class="s"> of </span><span class="si">{</span><span class="bp">self</span><span class="p">.</span><span class="n">func</span><span class="p">.</span><span class="n">__name__</span><span class="si">!r}</span><span class="s">"</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="o">@</span><span class="n">CountCalls</span>
<span class="k">def</span> <span class="nf">say_whee</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Whee!"</span><span class="p">)</span>
</code></pre></div></div>

<p>.__init__方法必须可以存储一个函数的引用和能够做一些必要的初始化. 调用.__call__方法来替代装饰器函数.它做的和我们之前的 wrapper()函数基本一样，注意，这里使用functools.update_wrapper()函数，而不是@functools.wraps</p>

<p>这个@CountCalls装饰器的工作原理与前一节相同:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">say_whee</span><span class="p">()</span>
<span class="n">Call</span> <span class="mi">1</span> <span class="n">of</span> <span class="s">'say_whee'</span>
<span class="n">Whee</span><span class="err">!</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">say_whee</span><span class="p">()</span>
<span class="n">Call</span> <span class="mi">2</span> <span class="n">of</span> <span class="s">'say_whee'</span>
<span class="n">Whee</span><span class="err">!</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">say_whee</span><span class="p">.</span><span class="n">num_calls</span>
<span class="mi">2</span>
</code></pre></div></div>

<h3 id="更多现实中的例子">更多现实中的例子</h3>

<p>我们已经学到了很多(看了下翻译的行数量，已经1K+了，确实很多)，已经学会如何创建各种各样的装饰师，把我们的新知识应用到创建更多的示例中，这些示例在现实中可能非常有用。</p>

<h4 id="代码降速重新访问">代码降速,重新访问</h4>

<p>我们之前实现的@slow_down一直是保持sleep 1秒.现在你知道了如何给装饰器添加参数,因此，让我们来重写@slow_down，使用一个可选的rate参数来控制它的sleep时间:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">slow_down</span><span class="p">(</span><span class="n">_func</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">rate</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="s">"""Sleep given amount of seconds before calling the function"""</span>
    <span class="k">def</span> <span class="nf">decorator_slow_down</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="o">@</span><span class="n">functools</span><span class="p">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapper_slow_down</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">time</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">rate</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wrapper_slow_down</span>

    <span class="k">if</span> <span class="n">_func</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">decorator_slow_down</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">decorator_slow_down</span><span class="p">(</span><span class="n">_func</span><span class="p">)</span>
</code></pre></div></div>

<p>我们使用  Both Please, But Never Mind the Bread  这里的样例来让@slow_down有参数和没有参数时都可调用，countdown()函数现在在每次计数之间休眠2秒:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">slow_down</span><span class="p">(</span><span class="n">rate</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">countdown</span><span class="p">(</span><span class="n">from_number</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">from_number</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Liftoff!"</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">from_number</span><span class="p">)</span>
        <span class="n">countdown</span><span class="p">(</span><span class="n">from_number</span> <span class="o">-</span> <span class="mi">1</span>
</code></pre></div></div>

<p>和前面一样，你最好自己写写，跑下看看结果</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">countdown</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="mi">3</span>
<span class="mi">2</span>
<span class="mi">1</span>
<span class="n">Liftoff</span><span class="err">!</span>
</code></pre></div></div>

<h4 id="创建单例模式">创建单例模式</h4>

<p>单例模式是一个只有一个实例的类.在Python经常使用的单例对象包括None,True和False.可以使用is来比较,像我们之前在Both Please的章节中:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">_func</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">decorator_name</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">decorator_name</span><span class="p">(</span><span class="n">_func</span><span class="p">)</span>
</code></pre></div></div>

<p>is只对完全相同实例的对象返回True。下面的@singleton装饰器将类的第一个实例存储为属性，从而将类转换为单例对象。之后创建实例只是返回已经存储的实例</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">functools</span>

<span class="k">def</span> <span class="nf">singleton</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
    <span class="s">"""Make a class a Singleton class (only one instance)"""</span>
    <span class="o">@</span><span class="n">functools</span><span class="p">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper_singleton</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">wrapper_singleton</span><span class="p">.</span><span class="n">instance</span><span class="p">:</span>
            <span class="n">wrapper_singleton</span><span class="p">.</span><span class="n">instance</span> <span class="o">=</span> <span class="n">cls</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wrapper_singleton</span><span class="p">.</span><span class="n">instance</span>
    <span class="n">wrapper_singleton</span><span class="p">.</span><span class="n">instance</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">return</span> <span class="n">wrapper_singleton</span>

<span class="o">@</span><span class="n">singleton</span>
<span class="k">class</span> <span class="nc">TheOne</span><span class="p">:</span>
    <span class="k">pass</span>
</code></pre></div></div>

<p>这个类装饰器和我们的函数装饰器基本一样.唯一不同的地方在于使用cls代替了fun来表示这是一个类装饰器</p>

<p>看下运行结果</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">first_one</span> <span class="o">=</span> <span class="n">TheOne</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">another_one</span> <span class="o">=</span> <span class="n">TheOne</span><span class="p">()</span>

<span class="o">&gt;&gt;&gt;</span> <span class="nb">id</span><span class="p">(</span><span class="n">first_one</span><span class="p">)</span>
<span class="mi">140094218762280</span>

<span class="o">&gt;&gt;&gt;</span> <span class="nb">id</span><span class="p">(</span><span class="n">another_one</span><span class="p">)</span>
<span class="mi">140094218762280</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">first_one</span> <span class="ow">is</span> <span class="n">another_one</span>
<span class="bp">True</span>
</code></pre></div></div>
<p>很明显，first_one确实与另一个实例完全相同。</p>

<h4 id="缓存返回值">缓存返回值</h4>

<p>装饰器可以提供很方便的缓存和记忆机制.作为一个例子，我们来看看斐波那契数列的递归定义:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">decorators</span> <span class="kn">import</span> <span class="n">count_calls</span>

<span class="o">@</span><span class="n">count_calls</span>
<span class="k">def</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">num</span>
    <span class="k">return</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">num</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<p>实现很简单，性能很糟糕</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="o">&lt;</span><span class="n">Lots</span> <span class="n">of</span> <span class="n">output</span> <span class="k">from</span> <span class="n">count_calls</span><span class="o">&gt;</span>
<span class="mi">55</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">fibonacci</span><span class="p">.</span><span class="n">num_calls</span>
<span class="mi">177</span>
</code></pre></div></div>
<p>为了计算第10个斐波那契数，你实际上只需要计算前面的斐波那契数，但是这个实现需要177次计算。更糟糕的是:斐波纳契数列(20)需要21891次计算，第30次需要270万次计算。这是因为代码一直在重新计算已知的斐波那契数。</p>

<p>通常的解决方案是使用for循环和查找表来实现斐波那契数。但是，简单的计算缓存也可以做到这一点</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">from</span> <span class="nn">decorators</span> <span class="kn">import</span> <span class="n">count_calls</span>

<span class="k">def</span> <span class="nf">cache</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="s">"""Keep a cache of previous function calls"""</span>
    <span class="o">@</span><span class="n">functools</span><span class="p">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper_cache</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">cache_key</span> <span class="o">=</span> <span class="n">args</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">kwargs</span><span class="p">.</span><span class="n">items</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">cache_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">wrapper_cache</span><span class="p">.</span><span class="n">cache</span><span class="p">:</span>
            <span class="n">wrapper_cache</span><span class="p">.</span><span class="n">cache</span><span class="p">[</span><span class="n">cache_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wrapper_cache</span><span class="p">.</span><span class="n">cache</span><span class="p">[</span><span class="n">cache_key</span><span class="p">]</span>
    <span class="n">wrapper_cache</span><span class="p">.</span><span class="n">cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">wrapper_cache</span>

<span class="o">@</span><span class="n">cache</span>
<span class="o">@</span><span class="n">count_calls</span>
<span class="k">def</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">num</span>
    <span class="k">return</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">num</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<p>缓存作为查找表工作，所以现在fibonacci()只执行一次计算</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="n">Call</span> <span class="mi">1</span> <span class="n">of</span> <span class="s">'fibonacci'</span>
<span class="p">...</span>
<span class="n">Call</span> <span class="mi">11</span> <span class="n">of</span> <span class="s">'fibonacci'</span>
<span class="mi">55</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="mi">21</span>
</code></pre></div></div>
<p>注意，在对fibonacci(8)的最后调用中，没有进行新的计算，因为fibonacci(10)已经计算了第8个fibonacci数。
在标准库中，提供了@functools.lru_cache。</p>

<p>这个装饰器比上面的例子要具备更多特性.我们应该使用@functools.lru_cache来代替我们自己写的缓存装饰器</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">functools</span>

<span class="o">@</span><span class="n">functools</span><span class="p">.</span><span class="n">lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Calculating fibonacci(</span><span class="si">{</span><span class="n">num</span><span class="si">}</span><span class="s">)"</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">num</span>
    <span class="k">return</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">num</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<p>maxsize参数指定缓存了多少次调用。默认值是128，但是可以指定maxsize=None来缓存所有函数调用。但是，请注意，如果正在缓存许多很大的对象，这可能会导致内存问题。</p>

<p>可以使用.cache_info()方法查看缓存的执行情况，并在需要时进行调优。在我们的示例中，我们设定一个小maxsize来查看从缓存中删除元素的效果:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="n">Calculating</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="n">Calculating</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="n">Calculating</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="n">Calculating</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="n">Calculating</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="n">Calculating</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">Calculating</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">Calculating</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">Calculating</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">Calculating</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">Calculating</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="mi">55</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="mi">21</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">Calculating</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">Calculating</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">Calculating</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">Calculating</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">Calculating</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">Calculating</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="mi">5</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="n">Calculating</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="n">Calculating</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="n">Calculating</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="mi">21</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="mi">5</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">fibonacci</span><span class="p">.</span><span class="n">cache_info</span><span class="p">()</span>
<span class="n">CacheInfo</span><span class="p">(</span><span class="n">hits</span><span class="o">=</span><span class="mi">17</span><span class="p">,</span> <span class="n">misses</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">maxsize</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">currsize</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="添加单元信息">添加单元信息</h4>

<p>下面的示例与前面的Registering Plugins示例有点类似，因为它不会真正改变被装饰函数的行为。相反，它只是将unit添加为函数属性</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">set_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">):</span>
    <span class="s">"""Register a unit on a function"""</span>
    <span class="k">def</span> <span class="nf">decorator_set_unit</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="n">func</span><span class="p">.</span><span class="n">unit</span> <span class="o">=</span> <span class="n">unit</span>
        <span class="k">return</span> <span class="n">func</span>
    <span class="k">return</span> <span class="n">decorator_set_unit</span>
</code></pre></div></div>
<p>下面的示例根据圆柱体的半径和高度(以厘米为单位)来计算体积</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">math</span>

<span class="o">@</span><span class="n">set_unit</span><span class="p">(</span><span class="s">"cm^3"</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">volume</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">height</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">math</span><span class="p">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">radius</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">height</span>   
    
<span class="n">这个</span><span class="p">.</span><span class="n">unit函数属性是可以访问的</span><span class="p">:</span>    
<span class="o">&gt;&gt;&gt;</span> <span class="n">volume</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="mf">141.3716694115407</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">volume</span><span class="p">.</span><span class="n">unit</span>
<span class="s">'cm^3'</span> 
</code></pre></div></div>
<p>注意，可以使用函数注释实现类似的功能</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">math</span>

<span class="k">def</span> <span class="nf">volume</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s">"cm^3"</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">math</span><span class="p">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">radius</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">height</span>
</code></pre></div></div>

<p>但是，由于注释用于类型提示，因此很难将注释和静态类型检查相结合。</p>

<p>在连接到一个能够在单位间转换的库，单位可以变得更加强大和有趣.pip install pint,  您可以将体积转换为立方英寸或加仑:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">复制代码</span>

<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">pint</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ureg</span> <span class="o">=</span> <span class="n">pint</span><span class="p">.</span><span class="n">UnitRegistry</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">vol</span> <span class="o">=</span> <span class="n">volume</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="n">ureg</span><span class="p">(</span><span class="n">volume</span><span class="p">.</span><span class="n">unit</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">vol</span>
<span class="o">&lt;</span><span class="n">Quantity</span><span class="p">(</span><span class="mf">141.3716694115407</span><span class="p">,</span> <span class="s">'centimeter ** 3'</span><span class="p">)</span><span class="o">&gt;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">vol</span><span class="p">.</span><span class="n">to</span><span class="p">(</span><span class="s">"cubic inches"</span><span class="p">)</span>
<span class="o">&lt;</span><span class="n">Quantity</span><span class="p">(</span><span class="mf">8.627028576414954</span><span class="p">,</span> <span class="s">'inch ** 3'</span><span class="p">)</span><span class="o">&gt;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">vol</span><span class="p">.</span><span class="n">to</span><span class="p">(</span><span class="s">"gallons"</span><span class="p">).</span><span class="n">m</span>  <span class="c1"># Magnitude
</span><span class="mf">0.0373464440537444</span>  
</code></pre></div></div>

<p>你还可以修改装饰器来直接返回一个Pint数量.数量是通过与单位相乘得到的，在pint中，units必须只能在UnitRegistry中查询.这里注册用来存储函数属性来避免命名空间混乱</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">use_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">):</span>
    <span class="s">"""Have a function return a Quantity with given unit"""</span>
    <span class="n">use_unit</span><span class="p">.</span><span class="n">ureg</span> <span class="o">=</span> <span class="n">pint</span><span class="p">.</span><span class="n">UnitRegistry</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">decorator_use_unit</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="o">@</span><span class="n">functools</span><span class="p">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapper_use_unit</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">value</span> <span class="o">*</span> <span class="n">use_unit</span><span class="p">.</span><span class="n">ureg</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wrapper_use_unit</span>
    <span class="k">return</span> <span class="n">decorator_use_unit</span>

<span class="o">@</span><span class="n">use_unit</span><span class="p">(</span><span class="s">"meters per second"</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">average_speed</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">duration</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">distance</span> <span class="o">/</span> <span class="n">duration</span>
</code></pre></div></div>

<p>使用@use_unit装饰器，转换单位实际上是很容易</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">bolt</span> <span class="o">=</span> <span class="n">average_speed</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mf">9.58</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">bolt</span>
<span class="o">&lt;</span><span class="n">Quantity</span><span class="p">(</span><span class="mf">10.438413361169102</span><span class="p">,</span> <span class="s">'meter / second'</span><span class="p">)</span><span class="o">&gt;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">bolt</span><span class="p">.</span><span class="n">to</span><span class="p">(</span><span class="s">"km per hour"</span><span class="p">)</span>
<span class="o">&lt;</span><span class="n">Quantity</span><span class="p">(</span><span class="mf">37.578288100208766</span><span class="p">,</span> <span class="s">'kilometer / hour'</span><span class="p">)</span><span class="o">&gt;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">bolt</span><span class="p">.</span><span class="n">to</span><span class="p">(</span><span class="s">"mph"</span><span class="p">).</span><span class="n">m</span>  <span class="c1"># Magnitude
</span><span class="mf">23.350065679064745</span>
</code></pre></div></div>

<h4 id="验证json">验证JSON</h4>

<p>让我们看最后一个用例。快速看下Flask路由的管理程序</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">route</span><span class="p">(</span><span class="s">"/grade"</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">"POST"</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">update_grade</span><span class="p">():</span>
    <span class="n">json_data</span> <span class="o">=</span> <span class="n">request</span><span class="p">.</span><span class="n">get_json</span><span class="p">()</span>
    <span class="k">if</span> <span class="s">"student_id"</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">json_data</span><span class="p">:</span>
        <span class="n">abort</span><span class="p">(</span><span class="mi">400</span><span class="p">)</span>
    <span class="c1"># Update database
</span>    <span class="k">return</span> <span class="s">"success!"</span>
</code></pre></div></div>

<p>这里我们确保key student_id是请求的一部分.虽然验证有效，但它实际上并不属于函数本身.另外，可能还有其他使用相同验证的路由。因此，让我们Don’t repeat yourself，来使用装饰器抽象出任何不必要的逻辑，下面的@validate_json装饰器会完成这个工作</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">abort</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">validate_json</span><span class="p">(</span><span class="o">*</span><span class="n">expected_args</span><span class="p">):</span>                  <span class="c1"># 1
</span>    <span class="k">def</span> <span class="nf">decorator_validate_json</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="o">@</span><span class="n">functools</span><span class="p">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapper_validate_json</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">json_object</span> <span class="o">=</span> <span class="n">request</span><span class="p">.</span><span class="n">get_json</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">expected_arg</span> <span class="ow">in</span> <span class="n">expected_args</span><span class="p">:</span>      <span class="c1"># 2
</span>                <span class="k">if</span> <span class="n">expected_arg</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">json_object</span><span class="p">:</span>
                    <span class="n">abort</span><span class="p">(</span><span class="mi">400</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wrapper_validate_json</span>
    <span class="k">return</span> <span class="n">decorator_validate_json</span>
</code></pre></div></div>

<p>在上面的代码中，装饰器采用了一个可变长度列表作为参数，这样我们就可以传递尽可能多的字符串参数，每个参数都代表一个用于验证JSON数据的键:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1.json的keys列表作为参数传递给装饰器
2.包裹函数验证JSON数据中出现的每个预期键
</code></pre></div></div>

<p>然后，路由管理程序可以关注其真正的业务级别——因为它可以安全地假设JSON数据是有效的:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">route</span><span class="p">(</span><span class="s">"/grade"</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">"POST"</span><span class="p">])</span>
<span class="o">@</span><span class="n">validate_json</span><span class="p">(</span><span class="s">"student_id"</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">update_grade</span><span class="p">():</span>
    <span class="n">json_data</span> <span class="o">=</span> <span class="n">request</span><span class="p">.</span><span class="n">get_json</span><span class="p">()</span>
    <span class="c1"># Update database.
</span>    <span class="k">return</span> <span class="s">"success!"</span>
</code></pre></div></div>

<h3 id="引用地址">引用地址</h3>
<p>https://realpython.com/primer-on-python-decorators/</p>]]></content><author><name>Your Name</name></author><category term="Python" /><summary type="html"><![CDATA[Python装饰器介绍]]></summary></entry><entry><title type="html">`Python 装饰器 - 01`</title><link href="/python-decorator-01/" rel="alternate" type="text/html" title="`Python 装饰器 - 01`" /><published>2022-08-21T00:00:00+08:00</published><updated>2022-08-21T00:00:00+08:00</updated><id>/python-decorator-01</id><content type="html" xml:base="/python-decorator-01/"><![CDATA[<p>Python装饰器介绍</p>

<p>这是一篇介绍python装饰器的文章，对比之前看到的类似介绍装饰器的文章，个人认为无人可出其右，文章由浅到深，由函数介绍到装饰器的高级应用，每个介绍必有例子说明。文章太长，看完原文后我计划按照文章作者的划分，将分为两章翻出来和大家分享,如果你觉得干的还不错，就点个赞吧</p>

<p>在本次的装饰器教程中，将介绍何为装饰器以及如何创建和使用它们,装饰器提供了简单的语法来调用高阶函数。
从定义上讲，装饰器是一个函数，它接收另一个函数作为参数并且扩展它的功能，但不会显式的去修改它
说起来可能会让人觉得难理解，但它(装饰器)确实不会这么做，特别是一会你会看到一些装饰器如何工作的例子</p>

<h3 id="函数">函数</h3>
<p>在理解装饰器之前，你首先需要理解函数如何工作。函数会基于给定的参数返回值。这里有一个非常简单的例子:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">add_one</span><span class="p">(</span><span class="n">number</span><span class="p">):</span>
<span class="p">...</span>     <span class="k">return</span> <span class="n">number</span> <span class="o">+</span> <span class="mi">1</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">add_one</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="mi">3</span>
</code></pre></div></div>

<p>通常情况下，函数在python中也会有其它功效而不是仅仅接收输入并返回输出。print()函数是一个例子。在控制台输出的时候它会返回None(1)，然而，为了理解装饰器，
将函数认为是接收参数并返回值就足够了</p>

<p>注意:在面向函数编程,你几乎只会使用纯函数，不会有其它功能，然而python不是一个纯函数式语言，python支持许多函数式编程概念，包括一等对象</p>

<h4 id="一等对象">一等对象</h4>
<p>在python中，函数是一等对象，意思是函数可以作为参数被传递，就像其它的对象(string，int，fload，list和其它)，思考下面的三个函数</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">say_hello</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s">"Hello </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s">"</span>

<span class="k">def</span> <span class="nf">be_awesome</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s">"Yo </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s">, together we are the awesomest!"</span>

<span class="k">def</span> <span class="nf">greet_bob</span><span class="p">(</span><span class="n">greeter_func</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">greeter_func</span><span class="p">(</span><span class="s">"Bob"</span><span class="p">)</span>
</code></pre></div></div>

<p>在这里,say_hello()和be_awsone()是常规函数，接收一个name参数返回一个字符串，然而greet_bob()函数，接收一个函数作为他的参数，我们可以将say_hello()或者be_awesome()函数传递给它</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">greet_bob</span><span class="p">(</span><span class="n">say_hello</span><span class="p">)</span>
<span class="s">'Hello Bob'</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">greet_bob</span><span class="p">(</span><span class="n">be_awesome</span><span class="p">)</span>
<span class="s">'Yo Bob, together we are the awesomest!'</span>
</code></pre></div></div>

<p>注意greet_bob(say_hello) 涉及到两个函数，但是不同的是:greet_bob()和say_hello,say_hello函数并没有使用()，代表只传递了对函数的引用，函数没有运行，greet_bob()函数，是使用了括号，所以它会被正常调用</p>

<h4 id="内部函数">内部函数</h4>
<p>在函数内定义函数是被允许的。这类函数被称为内部函数，这里有一个函数和两个内函数的例子</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">parent</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Printing from the parent() function"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">first_child</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Printing from the first_child() function"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">second_child</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Printing from the second_child() function"</span><span class="p">)</span>

    <span class="n">second_child</span><span class="p">()</span>
    <span class="n">first_child</span><span class="p">()</span>
</code></pre></div></div>

<p>当你调用parent()的时候会发生什么? 请考虑一分钟。会出现下面的输出结果</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">parent</span><span class="p">()</span>
<span class="n">Printing</span> <span class="k">from</span> <span class="n">the</span> <span class="n">parent</span><span class="p">()</span> <span class="n">function</span>
<span class="n">Printing</span> <span class="k">from</span> <span class="n">the</span> <span class="n">second_child</span><span class="p">()</span> <span class="n">function</span>
<span class="n">Printing</span> <span class="k">from</span> <span class="n">the</span> <span class="n">first_child</span><span class="p">()</span> <span class="n">function</span>
</code></pre></div></div>

<p>注意内部函数定义的顺序无关紧要，和其它的函数一样，打印只会发生在内部函数运行的时候</p>

<p>而且，内部函数在父函数被调用之前不会生效，它们的局部作用域是父()，它们只作为局部变量存在在父()函数的内部，尝试调用first_child()，你会得到下面的错误</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s">"&lt;stdin&gt;"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="nb">NameError</span><span class="p">:</span> <span class="n">name</span> <span class="s">'first_child'</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">defined</span>
</code></pre></div></div>

<p>不管你何时调用parent()，内部函数first_child()和second_child()都会被调用，因为它们的局部作用域，它们无法再parent()函数外使用</p>

<h4 id="从函数中返回函数">从函数中返回函数</h4>

<p>python允许使用函数来作为返回值，下面的例子从外部的父函数parent()返回了一个内部函数</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">parent</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">first_child</span><span class="p">():</span>
        <span class="k">return</span> <span class="s">"Hi, I am Emma"</span>

    <span class="k">def</span> <span class="nf">second_child</span><span class="p">():</span>
        <span class="k">return</span> <span class="s">"Call me Liam"</span>

    <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">first_child</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">second_chil</span>
</code></pre></div></div>

<p>注意这里返回的first_child是没有括号的，也就是返回了对函数first_child的引用， 带括号的first_child() 指的是对函数求值的结果，这个可以在下面的实例中看到</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">first</span> <span class="o">=</span> <span class="n">parent</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">second</span> <span class="o">=</span> <span class="n">parent</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">first</span>
<span class="o">&lt;</span><span class="n">function</span> <span class="n">parent</span><span class="p">.</span><span class="o">&lt;</span><span class="nb">locals</span><span class="o">&gt;</span><span class="p">.</span><span class="n">first_child</span> <span class="n">at</span> <span class="mh">0x7f599f1e2e18</span><span class="o">&gt;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">second</span>
<span class="o">&lt;</span><span class="n">function</span> <span class="n">parent</span><span class="p">.</span><span class="o">&lt;</span><span class="nb">locals</span><span class="o">&gt;</span><span class="p">.</span><span class="n">second_child</span> <span class="n">at</span> <span class="mh">0x7f599dad5268</span><span class="o">&gt;</span>
</code></pre></div></div>
<p>这个输出代表first变量引用了在parent()中的本地函数first_child()，second则指向了second_child()</p>

<p>你现在可以像常规函数一样使用first和second，虽然他们指向的函数无法被直接访问</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">first</span><span class="p">()</span>
<span class="s">'Hi, I am Emma'</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">second</span><span class="p">()</span>
<span class="s">'Call me Liam'</span>
</code></pre></div></div>

<p>请注意，在前面的例子中我们在父函数中运行内部函数，例如first_child()，然后在最后的例子中，返回的时候没有给内部函数first_child添加括号。这样，就获取了将来可以调用的函数的引用。这样有意义吗?</p>

<h3 id="简单装饰器">简单装饰器</h3>

<p>现在你已经看到函数和python中的其它对象一样，你已经准备好前进来认识python装饰器，让我们以一个例子开始</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">my_decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Something is happening before the function is called."</span><span class="p">)</span>
        <span class="n">func</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Something is happening after the function is called."</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>

<span class="k">def</span> <span class="nf">say_whee</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Whee!"</span><span class="p">)</span>

<span class="n">say_whee</span> <span class="o">=</span> <span class="n">my_decorator</span><span class="p">(</span><span class="n">say_whee</span><span class="p">)</span>
</code></pre></div></div>
<p>你能猜到当你调用say_whee()的时候回发生什么么？试一下</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">say_whee</span><span class="p">()</span>
<span class="n">Something</span> <span class="ow">is</span> <span class="n">happening</span> <span class="n">before</span> <span class="n">the</span> <span class="n">function</span> <span class="ow">is</span> <span class="n">called</span><span class="p">.</span>
<span class="n">Whee</span><span class="err">!</span>
<span class="n">Something</span> <span class="ow">is</span> <span class="n">happening</span> <span class="n">after</span> <span class="n">the</span> <span class="n">function</span> <span class="ow">is</span> <span class="n">called</span><span class="p">.</span>
</code></pre></div></div>

<p>要理解这里发生了什么，需要回看下之前的例子，我们只是应用了你到目前为止学到的所有东西</p>

<p>所谓的装饰器发生在下面这行</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">say_whee</span> <span class="o">=</span> <span class="n">my_decorator</span><span class="p">(</span><span class="n">say_whee</span><span class="p">)</span>
</code></pre></div></div>

<p>事实上，say_whee现在指向了内部函数wrapper()，当你调用my_decorator(say_whee)的时候会将wrapper作为函数返回</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">say_whee</span>
<span class="o">&lt;</span><span class="n">function</span> <span class="n">my_decorator</span><span class="p">.</span><span class="o">&lt;</span><span class="nb">locals</span><span class="o">&gt;</span><span class="p">.</span><span class="n">wrapper</span> <span class="n">at</span> <span class="mh">0x7f3c5dfd42f0</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>wrapper()引用原始的say_whee()作为func，在两个print()之间调用这个函数</p>

<p>简而言之:装饰器包裹一个函数，并改变它的行为</p>

<p>在继续之前，让我们看下第二个例子。因为wrapper()是一个常规的函数，装饰器可以以一种动态的方式来修改函数。为了不打扰你的邻居，下面的示例演示只会在白天运行的装饰器</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>

<span class="k">def</span> <span class="nf">not_during_the_night</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">():</span>
        <span class="k">if</span> <span class="mi">7</span> <span class="o">&lt;=</span> <span class="n">datetime</span><span class="p">.</span><span class="n">now</span><span class="p">().</span><span class="n">hour</span> <span class="o">&lt;</span> <span class="mi">22</span><span class="p">:</span>
            <span class="n">func</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># Hush, the neighbors are asleep
</span>    <span class="k">return</span> <span class="n">wrapper</span>

<span class="k">def</span> <span class="nf">say_whee</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Whee!"</span><span class="p">)</span>

<span class="n">say_whee</span> <span class="o">=</span> <span class="n">not_during_the_night</span><span class="p">(</span><span class="n">say_whee</span><span class="p">)</span>
</code></pre></div></div>

<p>如果你在睡觉的时间调用say_whee()，不会发生任何事情</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">say_whee</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span>
</code></pre></div></div>

<h4 id="语法糖">语法糖</h4>

<p>上面的装饰器say_whee()用起来有一点笨拙。首先，你键入了三次say_whee，另外，装饰器隐藏在了函数的定义之下</p>

<p>作为替代，python允许你使用@symbol的方式使用装饰器，有时被称为”pie”语法，下面的例子和之前第一个装饰器做了同样的事情</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">my_decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Something is happening before the function is called."</span><span class="p">)</span>
        <span class="n">func</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Something is happening after the function is called."</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>

<span class="o">@</span><span class="n">my_decorator</span>
<span class="k">def</span> <span class="nf">say_whee</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Whee!"</span><span class="p">)</span>
</code></pre></div></div>

<p>所以，@my_decorator 只是say_whee = my_decorator(say_whee)的一种快捷方式，这就是如何将装饰器应用到函数上</p>

<h4 id="复用装饰器">复用装饰器</h4>

<p>回想一下，装饰器只是一个普通的函数。所有常用的工具都是方便重复利用的，让我们将装饰器移动到他自己的模型上以便于在其它的函数上使用</p>

<p>下面创建了一个decorators.py</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">do_twice</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper_do_twice</span><span class="p">():</span>
        <span class="n">func</span><span class="p">()</span>
        <span class="n">func</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">wrapper_do_twice</span>
</code></pre></div></div>

<p>注意:你可以随意定义内部函数的名称，通常像wrapper()用起来是没问题的。你在这篇文章中会遇到许多装饰器。为了区别开它们，我们将使用decorator名称来命名内部函数，但会加上wrapper_前缀。</p>

<p>你可以使用常规导入来使用一个新的装饰器</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">decorators</span> <span class="kn">import</span> <span class="n">do_twice</span>

<span class="o">@</span><span class="n">do_twice</span>
<span class="k">def</span> <span class="nf">say_whee</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Whee!"</span><span class="p">)</span>
</code></pre></div></div>

<p>当你运行这个例子，你会看到原始韩式say_whee()执行两次</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">say_whee</span><span class="p">()</span>
<span class="n">Whee</span><span class="err">!</span>
<span class="n">Whee</span><span class="err">!</span>
</code></pre></div></div>

<h4 id="装饰器传参">装饰器传参</h4>

<p>如果你有一个函数需要接收一些参数，这时候还可以再使用装饰器么，然我们试试</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">decorators</span> <span class="kn">import</span> <span class="n">do_twice</span>

<span class="o">@</span><span class="n">do_twice</span>
<span class="k">def</span> <span class="nf">greet</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Hello </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div>

<p>不幸的是，运行代码抛出了错误</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">greet</span><span class="p">(</span><span class="s">"World"</span><span class="p">)</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s">"&lt;stdin&gt;"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="nb">TypeError</span><span class="p">:</span> <span class="n">wrapper_do_twice</span><span class="p">()</span> <span class="n">takes</span> <span class="mi">0</span> <span class="n">positional</span> <span class="n">arguments</span> <span class="n">but</span> <span class="mi">1</span> <span class="n">was</span> <span class="n">given</span>
</code></pre></div></div>

<p>问题在于内部函数wrapper_do_twice()没有接收任何参数，但是name=”World”却传给了它。你可以让wrapper_do_twice()接收一个参数来修补这个问题，但是这样前面的say_whee()函数就无法工作了</p>

<p>解决方案是在内部函数使用*args和**kwargs ，这样它会允许接收任意个关键参数，下面重写了decorators.py</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">do_twice</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper_do_twice</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper_do_twice</span>
</code></pre></div></div>

<p>内部函数wrapper_do_twice()现在接收任意数量的参数并会传递给装饰的函数，目前say_whee()和greet()都会正常工作</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">say_whee</span><span class="p">()</span>
<span class="n">Whee</span><span class="err">!</span>
<span class="n">Whee</span><span class="err">!</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">greet</span><span class="p">(</span><span class="s">"World"</span><span class="p">)</span>
<span class="n">Hello</span> <span class="n">World</span>
<span class="n">Hello</span> <span class="n">World</span>
</code></pre></div></div>

<h4 id="从装饰器返回值">从装饰器返回值</h4>

<p>被装饰的函数返回值会发生什么？这会由装饰器来决定，我们下面有一个简单的装饰器函数</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">decorators</span> <span class="kn">import</span> <span class="n">do_twice</span>

<span class="o">@</span><span class="n">do_twice</span>
<span class="k">def</span> <span class="nf">return_greeting</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Creating greeting"</span><span class="p">)</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s">"Hi </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s">"</span>
</code></pre></div></div>

<p>尝试运行它</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">hi_adam</span> <span class="o">=</span> <span class="n">return_greeting</span><span class="p">(</span><span class="s">"Adam"</span><span class="p">)</span>
<span class="n">Creating</span> <span class="n">greeting</span>
<span class="n">Creating</span> <span class="n">greeting</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">hi_adam</span><span class="p">)</span>
<span class="bp">None</span>
</code></pre></div></div>

<p>装饰器吃掉了从函数返回的值</p>

<p>因为do_twice_wrapper()没有返回值，调用 return_greeting(“Adam”) 最后返回了None</p>

<p>修复的方式是,需要确认装饰器返回它装饰的函数的值，改变decorators.py文件:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">do_twice</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper_do_twice</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper_do_twice</span>
</code></pre></div></div>

<p>执行这个函数返回的值</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">return_greeting</span><span class="p">(</span><span class="s">"Adam"</span><span class="p">)</span>
<span class="n">Creating</span> <span class="n">greeting</span>
<span class="n">Creating</span> <span class="n">greeting</span>
<span class="s">'Hi Adam'</span>
</code></pre></div></div>

<h4 id="你是谁">你是谁</h4>

<p>在使用Python(尤其是在交互式shell中)时，强大的内省是非常方便的功能。内省是对象在运行时了解其自身属性的能力。例如，函数知道自己的名称和文档:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="k">print</span>
<span class="o">&lt;</span><span class="n">built</span><span class="o">-</span><span class="ow">in</span> <span class="n">function</span> <span class="k">print</span><span class="o">&gt;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">.</span><span class="n">__name__</span>
<span class="s">'print'</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">help</span><span class="p">(</span><span class="k">print</span><span class="p">)</span>
<span class="n">Help</span> <span class="n">on</span> <span class="n">built</span><span class="o">-</span><span class="ow">in</span> <span class="n">function</span> <span class="k">print</span> <span class="ow">in</span> <span class="n">module</span> <span class="n">builtins</span><span class="p">:</span>

<span class="k">print</span><span class="p">(...)</span>
    <span class="o">&lt;</span><span class="n">full</span> <span class="n">help</span> <span class="n">message</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>内省同样适用于你自定义的函数</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">say_whee</span>
<span class="o">&lt;</span><span class="n">function</span> <span class="n">do_twice</span><span class="p">.</span><span class="o">&lt;</span><span class="nb">locals</span><span class="o">&gt;</span><span class="p">.</span><span class="n">wrapper_do_twice</span> <span class="n">at</span> <span class="mh">0x7f43700e52f0</span><span class="o">&gt;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">say_whee</span><span class="p">.</span><span class="n">__name__</span>
<span class="s">'wrapper_do_twice'</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">help</span><span class="p">(</span><span class="n">say_whee</span><span class="p">)</span>
<span class="n">Help</span> <span class="n">on</span> <span class="n">function</span> <span class="n">wrapper_do_twice</span> <span class="ow">in</span> <span class="n">module</span> <span class="n">decorators</span><span class="p">:</span>

<span class="n">wrapper_do_twice</span><span class="p">()</span>
</code></pre></div></div>

<p>然而在被装饰后，say_whee()会对自身感到疑惑。它现在显示为 do_twice()装饰器的内部函数 wrapper_do_twice()</p>

<p>为了修复这个，装饰器需要使用@functools.wraps装饰器，它会保留原始函数的信息，再次更新下decorators.py</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">functools</span>

<span class="k">def</span> <span class="nf">do_twice</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="o">@</span><span class="n">functools</span><span class="p">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper_do_twice</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper_do_twice</span>
</code></pre></div></div>

<p>不需要对被装饰的say_whee()函数做任何更改</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">say_whee</span>
<span class="o">&lt;</span><span class="n">function</span> <span class="n">say_whee</span> <span class="n">at</span> <span class="mh">0x7ff79a60f2f0</span><span class="o">&gt;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">say_whee</span><span class="p">.</span><span class="n">__name__</span>
<span class="s">'say_whee'</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">help</span><span class="p">(</span><span class="n">say_whee</span><span class="p">)</span>
<span class="n">Help</span> <span class="n">on</span> <span class="n">function</span> <span class="n">say_whee</span> <span class="ow">in</span> <span class="n">module</span> <span class="n">whee</span><span class="p">:</span>

<span class="n">say_whee</span><span class="p">()</span>
</code></pre></div></div>
<p>非常好，现在say_whee()在被装饰后可以保持自己</p>

<p>技术细节:@funtools.wraps 装饰器使用函数functools.update_wrapper()来更新指定的属性，像__name__和__doc__来用于自省</p>

<h3 id="一些现实中的例子">一些现实中的例子</h3>

<p>让我们看一些用处更大的装饰器例子。你会注意到他们主要的模式和你现在所学的都是一样的</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">functools</span>

<span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="o">@</span><span class="n">functools</span><span class="p">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper_decorator</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Do something before
</span>        <span class="n">value</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Do something after
</span>        <span class="k">return</span> <span class="n">value</span>
    <span class="k">return</span> <span class="n">wrapper_decorator</span>
</code></pre></div></div>

<p>对于构建更复杂的装饰器，这个是一个很好的模板</p>

<h4 id="时间函数">时间函数</h4>
<p>让我们从@timer装饰器开始，它会测量函数运行的时间并且打印持续时间到控制台，这是代码</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">timer</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="s">"""Print the runtime of the decorated function"""</span>
    <span class="o">@</span><span class="n">functools</span><span class="p">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper_timer</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">perf_counter</span><span class="p">()</span>    <span class="c1"># 1
</span>        <span class="n">value</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">end_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">perf_counter</span><span class="p">()</span>      <span class="c1"># 2
</span>        <span class="n">run_time</span> <span class="o">=</span> <span class="n">end_time</span> <span class="o">-</span> <span class="n">start_time</span>    <span class="c1"># 3
</span>        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Finished </span><span class="si">{</span><span class="n">func</span><span class="p">.</span><span class="n">__name__</span><span class="si">!r}</span><span class="s"> in </span><span class="si">{</span><span class="n">run_time</span><span class="si">:</span><span class="p">.</span><span class="mi">4</span><span class="n">f</span><span class="si">}</span><span class="s"> secs"</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span>
    <span class="k">return</span> <span class="n">wrapper_timer</span>

<span class="o">@</span><span class="n">timer</span>
<span class="k">def</span> <span class="nf">waste_some_time</span><span class="p">(</span><span class="n">num_times</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_times</span><span class="p">):</span>
        <span class="nb">sum</span><span class="p">([</span><span class="n">i</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">)])</span>
</code></pre></div></div>

<p>这个函数是在函数运行之前获取时间(#1行)，并且在函数运行结束之后获取时间(#2行)，我们使用 time.perf_counter() 函数，这个函数可以非常好的计算时间间隔。下面是一个示例</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">waste_some_time</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">Finished</span> <span class="s">'waste_some_time'</span> <span class="ow">in</span> <span class="mf">0.0010</span> <span class="n">secs</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">waste_some_time</span><span class="p">(</span><span class="mi">999</span><span class="p">)</span>
<span class="n">Finished</span> <span class="s">'waste_some_time'</span> <span class="ow">in</span> <span class="mf">0.3260</span> <span class="n">secs</span>
</code></pre></div></div>

<p>自己运行测试下，手敲下这里的代码，确保你理解它的工作原理。如果不明白，也不要担心。装饰器是高级方法，试着思考下或者画下流程图</p>

<p>注意: 如果你只是想获取函数的运行时间，@timer 装饰器可以满足。如果你想获取到更精确的数据，你应该考虑使用timeit 模块来替代它。它临时禁用了垃圾收集并且运行多次以避免函数快速调用带来的噪音数据</p>

<h4 id="调试代码">调试代码</h4>

<p>下面的@debug函数会在每次调用的时候打印函数被调用的参数和它的返回结果</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">functools</span>

<span class="k">def</span> <span class="nf">debug</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="s">"""Print the function signature and return value"""</span>
    <span class="o">@</span><span class="n">functools</span><span class="p">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper_debug</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">args_repr</span> <span class="o">=</span> <span class="p">[</span><span class="nb">repr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>                      <span class="c1"># 1
</span>        <span class="n">kwargs_repr</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s">=</span><span class="si">{</span><span class="n">v</span><span class="si">!r}</span><span class="s">"</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">.</span><span class="n">items</span><span class="p">()]</span>  <span class="c1"># 2
</span>        <span class="n">signature</span> <span class="o">=</span> <span class="s">", "</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">args_repr</span> <span class="o">+</span> <span class="n">kwargs_repr</span><span class="p">)</span>           <span class="c1"># 3
</span>        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Calling </span><span class="si">{</span><span class="n">func</span><span class="p">.</span><span class="n">__name__</span><span class="si">}</span><span class="s">(</span><span class="si">{</span><span class="n">signature</span><span class="si">}</span><span class="s">)"</span><span class="p">)</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">func</span><span class="p">.</span><span class="n">__name__</span><span class="si">!r}</span><span class="s"> returned </span><span class="si">{</span><span class="n">value</span><span class="si">!r}</span><span class="s">"</span><span class="p">)</span>           <span class="c1"># 4
</span>        <span class="k">return</span> <span class="n">value</span>
    <span class="k">return</span> <span class="n">wrapper_debug</span>
</code></pre></div></div>

<p>signature 变量是通过 字符串表示方法 来创建所有的输入参数。下面的数字对应了代码中的注释</p>
<ul>
  <li>将args创建为列表，使用repr修饰</li>
  <li>将kwargs创建为列表，使用f-string格式化参数为key=value，!r表示使用repr()表示值</li>
  <li>args和kwargs转换后会合并在signature变量中，使用逗号分隔每个变量</li>
  <li>函数运行结束后会返回值</li>
</ul>

<p>让我们在一个简单的函数中使用装饰器被观察它是如何运行的，被装饰的函数只有一个位置参数和一个关键字参数</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">debug</span>
<span class="k">def</span> <span class="nf">make_greeting</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">age</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s">"Howdy </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s">!"</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s">"Whoa </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s">! </span><span class="si">{</span><span class="n">age</span><span class="si">}</span><span class="s"> already, you are growing up!"</span>
</code></pre></div></div>

<p>注意@debug装饰器如何打印make_greeting()函数的signature 和返回值</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">make_greeting</span><span class="p">(</span><span class="s">"Benjamin"</span><span class="p">)</span>
<span class="n">Calling</span> <span class="n">make_greeting</span><span class="p">(</span><span class="s">'Benjamin'</span><span class="p">)</span>
<span class="s">'make_greeting'</span> <span class="n">returned</span> <span class="s">'Howdy Benjamin!'</span>
<span class="s">'Howdy Benjamin!'</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">make_greeting</span><span class="p">(</span><span class="s">"Richard"</span><span class="p">,</span> <span class="n">age</span><span class="o">=</span><span class="mi">112</span><span class="p">)</span>
<span class="n">Calling</span> <span class="n">make_greeting</span><span class="p">(</span><span class="s">'Richard'</span><span class="p">,</span> <span class="n">age</span><span class="o">=</span><span class="mi">112</span><span class="p">)</span>
<span class="s">'make_greeting'</span> <span class="n">returned</span> <span class="s">'Whoa Richard! 112 already, you are growing up!'</span>
<span class="s">'Whoa Richard! 112 already, you are growing up!'</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">make_greeting</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">"Dorrisile"</span><span class="p">,</span> <span class="n">age</span><span class="o">=</span><span class="mi">116</span><span class="p">)</span>
<span class="n">Calling</span> <span class="n">make_greeting</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">'Dorrisile'</span><span class="p">,</span> <span class="n">age</span><span class="o">=</span><span class="mi">116</span><span class="p">)</span>
<span class="s">'make_greeting'</span> <span class="n">returned</span> <span class="s">'Whoa Dorrisile! 116 already, you are growing up!'</span>
<span class="s">'Whoa Dorrisile! 116 already, you are growing up!'</span> 
</code></pre></div></div>

<p>@debug修饰符看起来只是重复了我们刚才写的内容 ，并不是非常有用。 但当应用到不能直接修改的其它函数时，它会更加强大。</p>

<p>下面的例子计算了一个数学常数E的近似值</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">decorators</span> <span class="kn">import</span> <span class="n">debug</span>

<span class="c1"># Apply a decorator to a standard library function
</span><span class="n">math</span><span class="p">.</span><span class="n">factorial</span> <span class="o">=</span> <span class="n">debug</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="n">factorial</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">approximate_e</span><span class="p">(</span><span class="n">terms</span><span class="o">=</span><span class="mi">18</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">math</span><span class="p">.</span><span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">terms</span><span class="p">))</span>
</code></pre></div></div>

<p>这个例子还演示了如何将装饰器应用到已经定义了的函数</p>

<p><img src="/assets/images/python/p01.jpg" /></p>

<p>当调用approximate_e()函数，你可以看到@debug函数在工作</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">approximate_e</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">Calling</span> <span class="n">factorial</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="s">'factorial'</span> <span class="n">returned</span> <span class="mi">1</span>
<span class="n">Calling</span> <span class="n">factorial</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="s">'factorial'</span> <span class="n">returned</span> <span class="mi">1</span>
<span class="n">Calling</span> <span class="n">factorial</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="s">'factorial'</span> <span class="n">returned</span> <span class="mi">2</span>
<span class="n">Calling</span> <span class="n">factorial</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="s">'factorial'</span> <span class="n">returned</span> <span class="mi">6</span>
<span class="n">Calling</span> <span class="n">factorial</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="s">'factorial'</span> <span class="n">returned</span> <span class="mi">24</span>
<span class="mf">2.708333333333333</span>
</code></pre></div></div>

<p>在这个例子中，可以得到一个真实值的近似值e = 2.718281828</p>

<h4 id="给代码降速">给代码降速</h4>

<p>下面的例子看起来可能不是很有用。可能最常见的用例是，您希望对一个不断检查资源是否存在的函数进行速率限制 。 @slow_down decorator在调用被修饰的函数之前会暂停一秒钟</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">slow_down</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="s">"""Sleep 1 second before calling the function"""</span>
    <span class="o">@</span><span class="n">functools</span><span class="p">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper_slow_down</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">time</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper_slow_down</span>

<span class="o">@</span><span class="n">slow_down</span>
<span class="k">def</span> <span class="nf">countdown</span><span class="p">(</span><span class="n">from_number</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">from_number</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Liftoff!"</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">from_number</span><span class="p">)</span>
        <span class="n">countdown</span><span class="p">(</span><span class="n">from_number</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>   
</code></pre></div></div>

<p>来看下@slow_down装饰器的效果，你需要自己运行跑下</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">countdown</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="mi">3</span>
<span class="mi">2</span>
<span class="mi">1</span>
<span class="n">Liftoff</span><span class="err">!</span>  
</code></pre></div></div>

<p>countdown()是一个递归函数。也就是说，它是一个调用自身的函数 。</p>

<h4 id="注册插件">注册插件</h4>

<p>装饰器不是必须要修饰被装饰的函数(这句话不太好翻译，看下面的例子理解起来很容易)，它还可以简单地注册一个函数，并将其解包返回，例如，可以使用它来创建一个轻量级插件体系结构:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">random</span>
<span class="n">PLUGINS</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="s">"""Register a function as a plug-in"""</span>
    <span class="n">PLUGINS</span><span class="p">[</span><span class="n">func</span><span class="p">.</span><span class="n">__name__</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span>
    <span class="k">return</span> <span class="n">func</span>

<span class="o">@</span><span class="n">register</span>
<span class="k">def</span> <span class="nf">say_hello</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s">"Hello </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s">"</span>

<span class="o">@</span><span class="n">register</span>
<span class="k">def</span> <span class="nf">be_awesome</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s">"Yo </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s">, together we are the awesomest!"</span>

<span class="k">def</span> <span class="nf">randomly_greet</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="n">greeter</span><span class="p">,</span> <span class="n">greeter_func</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">PLUGINS</span><span class="p">.</span><span class="n">items</span><span class="p">()))</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Using </span><span class="si">{</span><span class="n">greeter</span><span class="si">!r}</span><span class="s">"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">greeter_func</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> 
</code></pre></div></div>

<p>@register装饰器只是在全局PLUGINS 字典中储存了被装饰函数的引用。注意你不需要在例子中写内部函数或者使用@functools.wraps ，因为返回的是一个未经过修改的初始函数</p>

<p>randomly_greet()函数在注册函数中随机选择一个使用。注意PLUGINS字典已经包含了对注册为插件的每个函数对象的引用:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="o">&gt;&gt;&gt;</span> <span class="n">PLUGINS</span>
<span class="p">{</span><span class="s">'say_hello'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">function</span> <span class="n">say_hello</span> <span class="n">at</span> <span class="mh">0x7f768eae6730</span><span class="o">&gt;</span><span class="p">,</span>
 <span class="s">'be_awesome'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">function</span> <span class="n">be_awesome</span> <span class="n">at</span> <span class="mh">0x7f768eae67b8</span><span class="o">&gt;</span><span class="p">}</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">randomly_greet</span><span class="p">(</span><span class="s">"Alice"</span><span class="p">)</span>
<span class="n">Using</span> <span class="s">'say_hello'</span>
<span class="s">'Hello Alice'</span>
</code></pre></div></div>

<p>这个插件的主要用处在于不需要再单独维护一个插件列表。这个列表在插件注册时自动创建，使得添加一个新插件变得很简单，只需定义函数并用@register装饰即可。</p>

<p>如果你对python中的globals()函数熟悉，你可能会看到一些和我们的插件结构相似之处。globals()可以访问当前作用于的所有全局变量</p>

<p>包括我们的插件</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="nb">globals</span><span class="p">()</span>
<span class="p">{...,</span> <span class="c1"># Lots of variables not shown here.
</span> <span class="s">'say_hello'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">function</span> <span class="n">say_hello</span> <span class="n">at</span> <span class="mh">0x7f768eae6730</span><span class="o">&gt;</span><span class="p">,</span>
 <span class="s">'be_awesome'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">function</span> <span class="n">be_awesome</span> <span class="n">at</span> <span class="mh">0x7f768eae67b8</span><span class="o">&gt;</span><span class="p">,</span>
 <span class="s">'randomly_greet'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">function</span> <span class="n">randomly_greet</span> <span class="n">at</span> <span class="mh">0x7f768eae6840</span><span class="o">&gt;</span><span class="p">}</span>
</code></pre></div></div>

<p>使用@register 装饰器，可以创建感兴趣的变量管理列表，有效地从globals()中筛选出一些函数</p>

<h4 id="用户是否登录">用户是否登录</h4>

<p>在继续讨论一些更有趣的装饰器之前，让我们在最后一个示例中演示通常在处理web框架时使用的装饰器。在这个例子中，我们使用Flask去设置一个/secret web页面，这个页面只对登录用户或者其他有权限的用户展示</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">redirect</span><span class="p">,</span> <span class="n">url_for</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">login_required</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="s">"""Make sure user is logged in before proceeding"""</span>
    <span class="o">@</span><span class="n">functools</span><span class="p">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper_login_required</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">g</span><span class="p">.</span><span class="n">user</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">redirect</span><span class="p">(</span><span class="n">url_for</span><span class="p">(</span><span class="s">"login"</span><span class="p">,</span> <span class="nb">next</span><span class="o">=</span><span class="n">request</span><span class="p">.</span><span class="n">url</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper_login_required</span>

<span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">route</span><span class="p">(</span><span class="s">"/secret"</span><span class="p">)</span>
<span class="o">@</span><span class="n">login_required</span>
<span class="k">def</span> <span class="nf">secret</span><span class="p">():</span>
    <span class="p">...</span>    
</code></pre></div></div>

<p>虽然这里演示了如何对web框架添加身份验证吗，但通常不应该自己编写这些类型的装饰器。对于Flask可以使用Flask-login扩展，这里的功能更丰富也更加安全</p>

<p>有想象力的装饰器
到目前为止，你已经看到了如何创建简单的装饰器并且非常了解什么是装饰器以及它们是如何工作的。请从这篇文章中休息一下，练习学到的一切。</p>

<p>在本教程的第二部分中，我们将探索更高级的特性，包括如何使用以下特性:</p>
<ul>
  <li>在类上使用装饰器(装饰类)</li>
  <li>在一个函数上应用多个装饰器</li>
  <li>带参数的装饰器</li>
  <li>可以选择是否接收参数的装饰器</li>
  <li>带状态的装饰器</li>
  <li>类装饰器</li>
</ul>]]></content><author><name>Your Name</name></author><category term="Python" /><summary type="html"><![CDATA[Python装饰器介绍]]></summary></entry><entry><title type="html">路由交换 - RIP - 01</title><link href="/rs-rip-01/" rel="alternate" type="text/html" title="路由交换 - RIP - 01" /><published>2022-08-21T00:00:00+08:00</published><updated>2022-08-21T00:00:00+08:00</updated><id>/rs-rip-01</id><content type="html" xml:base="/rs-rip-01/"><![CDATA[<p>RIP 笔记</p>

<h3 id="rip的基本原理与实现">RIP的基本原理与实现</h3>

<p>RIP的端口: UDP 520</p>

<h4 id="rip的计时器和稳定性">RIP的计时器和稳定性</h4>

<ul>
  <li>启动后，每隔30s从启动协议的接口发送更新信息，包含整个路由表。更新的目的地址是广播地址 255.255.255.255</li>
  <li>rip也使用无效计时器，也成为限时计时器，初始化时间为180s，如果超过这个时间还没有收到这条路有的更新，就将这条路有的跳数设置为16跳</li>
  <li>另一种计时器称为垃圾收集或刷新计时器，一般比限时计时器长240-60s，如果到时，这条路由就会被宣告为一条度量值为不可达的路由</li>
  <li>第三个计时器是抑制计时器。如果一条路由更新的跳数大于路由表已记录的该路由的跳数，那么将会引起该路由进入180s的抑制状态阶段</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>timers basic update invalid holddown flush
</code></pre></div></div>

<blockquote>
  <p>默认不建议更改计时器，如果一台路由器更改，那这个RIP域中的路由器都需要更改</p>
</blockquote>

<p>RIP使用带毒性逆转的水平分隔和触发更新，触发更新只有在路由的度量值发生变化时产生，触发更新会有一个1-5s的随机计时器，以免产生触发更新风暴</p>

<h4 id="rip的消息格式">RIP的消息格式</h4>

<p><img src="/assets/images/rip/r01.png" /></p>

<h4 id="请求消息类型">请求消息类型</h4>

<p>可以请求整个路由表信息，也可以请求某些具体路由信息</p>

<h4 id="有类别路由选择">有类别路由选择</h4>

<p>RIP的管理距离为120
数据包选路过程</p>
<ul>
  <li>读出目的地址的网络部分(A\B\C类)，查看在路由表中是否有匹配的条目，没有则丢弃，同时发出一个ICMP目的不可达的消息给源</li>
  <li>如果存在匹配该数据包网络部分的主类网络，会在路由器的主网络的子网中查找，找到匹配则转发，否则发送ICMP目的不可达消息</li>
</ul>

<p>有类别路由选择:直连的子网络</p>

<p><img src="/assets/images/rip/r02.png" /></p>

<ul>
  <li>192.168.35.3数据包进入路由器，路由器没有发现192.168.35.0的条目，该数据包则丢弃</li>
  <li>172.25.33.89数据包进入路由器，路由器中有一个B类172.25.0.0条目，但没有发现172.25.0.0的子网条目，该数据包丢弃</li>
  <li>172.25.153.220数据包进入路由器，路由器中有172.25.0.0的条目并找到172.25.153.0的条目，该数据包被转发到172.25.15.2</li>
</ul>

<p><strong>有类别路由选择:在边界路由器上汇总路由</strong></p>

<p>如果没有和某个目的网络直连，那么该路由器仅仅需要一条路由指向直接相连的路由器</p>

<h4 id="有类别路由选择小结">有类别路由选择:小结</h4>
<ul>
  <li>特点：在通告目的地址时无法通告它的掩码</li>
  <li>如果目的地址是一个和路由器直接相连的主网络成员，那么该网络的路由器接口上配置的子网掩码将被用来确定目的地址的子网</li>
  <li>如果目的地址不是一个和路由器直接相连的主网络的成员，那么路由器会尝试匹配A\B\C类的主网络号</li>
</ul>

<h3 id="配置rip">配置RIP</h3>

<ul>
  <li>router rip</li>
  <li>network 指定主网络</li>
</ul>

<h4 id="被动接口">被动接口</h4>
<p><img src="/assets/images/rip/r03.png" /></p>

<h4 id="配置单播更新">配置单播更新</h4>
<p><img src="/assets/images/rip/r04.png" /></p>

<p>为了防止广播更新，也需要加上一条passive-interface命令</p>

<h4 id="不连续的子网">不连续的子网</h4>

<p><img src="/assets/images/rip/r05.png" /></p>

<p><img src="/assets/images/rip/r06.png" /></p>

<h4 id="控制rip的度量">控制RIP的度量</h4>
<p>可以使用offset-list来改变路由的度量值</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>offset-list <span class="o">{</span>access-list-number | name<span class="o">}</span> <span class="o">{</span><span class="k">in</span> | out<span class="o">}</span> offset <span class="o">{</span><span class="nb">type </span>number<span class="o">}</span>
</code></pre></div></div>

<p><img src="/assets/images/rip/r07.png" /></p>

<p>将serial0的入方向的10.33.0.0的路由加大2跳</p>

<h4 id="最小化更新信息的影响">最小化更新信息的影响</h4>
<ul>
  <li>调整路由选择协议的计时器频率</li>
  <li>配置触发扩展特性消除周期性的RIP更新</li>
</ul>

<p>链路上的两台路由器都必须配置ip rip triggered命令，仅仅发送路由表最初的交换信息和路由表发生变化使得更新信息，只在串行链路上生效</p>]]></content><author><name>Your Name</name></author><category term="RS" /><summary type="html"><![CDATA[RIP 笔记]]></summary></entry></feed>