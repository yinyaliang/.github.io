<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2022-08-27T22:29:29+08:00</updated><id>/feed.xml</id><title type="html">尹亚亮</title><subtitle>An amazing website.</subtitle><author><name>Your Name</name></author><entry><title type="html">php 配置fcgi 获取监控数据</title><link href="/monitor-php/" rel="alternate" type="text/html" title="php 配置fcgi 获取监控数据" /><published>2022-08-27T00:00:00+08:00</published><updated>2022-08-27T00:00:00+08:00</updated><id>/monitor-php</id><content type="html" xml:base="/monitor-php/"><![CDATA[<p>规避Nginx,通过fcgi接口取值</p>

<h3 id="安装">安装</h3>

<p>在 centos上可以通过下面的方式安装</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>yum <span class="nt">--enablerepo</span><span class="o">=</span>epel <span class="nb">install </span>fcgi
</code></pre></div></div>

<p>FasdCGI在命令行访问需要通过配置环境变量,连接到一个FastCGI接口,需要有–bind和–conect参数:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cgi-fcgi -bind -connect 127.0.0.1:端口
</code></pre></div></div>

<h3 id="配置">配置</h3>

<p>php-fpm的conf 需要配置</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pm.status_path <span class="o">=</span> /status
listen <span class="o">=</span> 61185
listen.allowed_clients <span class="o">=</span> 127.0.0.1
</code></pre></div></div>

<h3 id="测试">测试</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">SCRIPT_NAME</span><span class="o">=</span>/status <span class="nv">SCRIPT_FILENAME</span><span class="o">=</span>/status <span class="nv">REQUEST_METHOD</span><span class="o">=</span>GET <span class="nv">QUERY_STRING</span><span class="o">=</span>xml cgi-fcgi <span class="nt">-bind</span> <span class="nt">-connect</span> 127.0.0.1:61185
Expires: Thu, 01 Jan 1970 00:00:00 GMT
Cache-Control: no-cache, no-store, must-revalidate, max-age<span class="o">=</span>0
Content-Type: text/xml

&lt;?xml <span class="nv">version</span><span class="o">=</span><span class="s2">"1.0"</span> ?&gt;
&lt;status&gt;
&lt;pool&gt;www&lt;/pool&gt;
&lt;process-manager&gt;dynamic&lt;/process-manager&gt;
&lt;start-time&gt;1661607804&lt;/start-time&gt;
&lt;start-since&gt;135&lt;/start-since&gt;
&lt;accepted-conn&gt;21&lt;/accepted-conn&gt;
&lt;listen-queue&gt;0&lt;/listen-queue&gt;
&lt;max-listen-queue&gt;0&lt;/max-listen-queue&gt;
&lt;listen-queue-len&gt;128&lt;/listen-queue-len&gt;
&lt;idle-processes&gt;5&lt;/idle-processes&gt;
&lt;active-processes&gt;1&lt;/active-processes&gt;
&lt;total-processes&gt;6&lt;/total-processes&gt;
&lt;max-active-processes&gt;1&lt;/max-active-processes&gt;
&lt;max-children-reached&gt;0&lt;/max-children-reached&gt;
&lt;slow-requests&gt;0&lt;/slow-requests&gt;
&lt;/status&gt;
</code></pre></div></div>

<p>以上返回值表示正常获取到值,参数还可以支持 json,xml,html</p>

<h3 id="参数说明">参数说明</h3>

<ul>
  <li>pool – 套接字的池的名称，在php-fpm 配置中定义</li>
  <li>process manager: 进程管理器用来控制子进程数量的方法,可以通过pm来配置,有static, dynamic,ondemand</li>
  <li>start time: 服务启动时间相对应的日期,reload后会更新</li>
  <li>start since: 服务运行时长</li>
  <li>accepted conn: 连接池已接受的传入请求数,当一个连接被接受时，它会从监听队列中移除(实时显示)</li>
  <li>listen queue: 当前已启动但尚未接受的连接数。如果此值非零，则通常意味着所有可用的服务器进程当前都处于忙碌状态，并且没有可用于服务下一个请求的进程.通过pm.max_children调整</li>
  <li>max listen queue: 服务启动后listen queue 的最大值</li>
  <li>listen queue len: 排队的连接数的上限,通过listen.backlog 配置,这个值也会受到 net.core.somaxconn 的限制</li>
  <li>idle processes: 处于“等待处理”状态的进程数量。当pm的值为dynamic的时候,这个值会在 pm.min_spare_servers 和 pm.max_spare_servers 值之间</li>
  <li>active processes: 活跃进程数量,最小值为1</li>
  <li>total processes: 空闲进程+活动进程的和。如果pm的值为static 的，这个数字显示 pm.max_children 的值</li>
  <li>max active processes: php-fpm 服务启动后，<em>active processes</em> 的历史最高值。不会超过 pm.max_children</li>
  <li>max children reached: php-fpm 服务器启动后, 到达pm.max_children 的次数,只有pm为 dynamic才有效</li>
</ul>

<h3 id="排错">排错</h3>

<p>如果上面的命令返回空,将listen.allowed_clients的127.0.0.1放在第一位</p>]]></content><author><name>Your Name</name></author><category term="Monitor" /><summary type="html"><![CDATA[规避Nginx,通过fcgi接口取值]]></summary></entry><entry><title type="html">etcd集群监控</title><link href="/monitor-etcd/" rel="alternate" type="text/html" title="etcd集群监控" /><published>2022-08-26T00:00:00+08:00</published><updated>2022-08-26T00:00:00+08:00</updated><id>/monitor-etcd</id><content type="html" xml:base="/monitor-etcd/"><![CDATA[<p>etcd集群监控</p>

<h3 id="系统">系统</h3>
<p>Centos 7</p>

<h3 id="测试接口">测试接口</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">--cert</span> /opt/etcd/ssl/server.pem <span class="nt">--key</span> /opt/etcd/ssl/server-key.pem https://10.0.2.45:2379/metrics <span class="nt">--insecure</span>
</code></pre></div></div>

<h3 id="prometheus-配置">prometheus 配置</h3>

<p>添加 etcd主机组 prometheus.yml</p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="pi">-</span> <span class="na">job_name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">etcd</span><span class="nv"> </span><span class="s">cluster"</span>
    <span class="na">scheme</span><span class="pi">:</span> <span class="s">https</span>
    <span class="na">static_configs</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">targets</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">10.0.2.44:2379"</span><span class="pi">,</span><span class="s2">"</span><span class="s">10.0.2.45:2379"</span><span class="pi">,</span><span class="s2">"</span><span class="s">10.0.2.46:2379"</span><span class="pi">]</span>
    <span class="na">tls_config</span><span class="pi">:</span>
      <span class="na">insecure_skip_verify</span><span class="pi">:</span> <span class="no">true</span>
      <span class="na">cert_file</span><span class="pi">:</span> <span class="s2">"</span><span class="s">/data/config/oss/prometheus/etcd_ca/server.pem"</span>
      <span class="na">key_file</span><span class="pi">:</span> <span class="s2">"</span><span class="s">/data/config/oss/prometheus/etcd_ca/server-key.pem"</span>
</code></pre></div></div>]]></content><author><name>Your Name</name></author><category term="Monitor" /><summary type="html"><![CDATA[etcd集群监控]]></summary></entry><entry><title type="html">路由交换 - BGP案例 - 03</title><link href="/rs-bgp-03/" rel="alternate" type="text/html" title="路由交换 - BGP案例 - 03" /><published>2022-08-26T00:00:00+08:00</published><updated>2022-08-26T00:00:00+08:00</updated><id>/rs-bgp-03</id><content type="html" xml:base="/rs-bgp-03/"><![CDATA[<p>BGP案例03
(参考https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/26634-bgp-toc.html#neighborsroutemaps)</p>

<h3 id="bgp-filtering">BGP Filtering</h3>

<p>有很多方法可以控制发送和接收的BGP更新，可以使用路由信息作为基础过滤BGP更新，或者使用路径信息或社区作为基础过滤BGP更新，这些方法都可以得到一样的结果。使用哪种方法却决于特定的网络情况</p>

<h4 id="route-filtering">Route Filtering</h4>

<p><img src="/assets/images/bgp/b21.png" /></p>

<p>为了可以限制路由学习到的更新或者宣告的更新，你可以从一个特定的邻居使用路由更新过滤BGP，可以定义一个控制访问列表，然后应用到一个邻居的更新中，配置命令:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>neighbor <span class="o">{</span>ip-address | peer-group-name<span class="o">}</span> distribute-list access-list-number <span class="o">{</span><span class="k">in</span> | out<span class="o">}</span> 
</code></pre></div></div>

<p>在这个例子中，RTB作为160.10.0.0的源网络发送 更新到RTC.如果RTC不想发布更新到AS100，需要定义一个访问控制列表，并把这个访问控制列表应用到路由进程配置中</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTC# 
router bgp 300 
network 170.10.0.0 
neighbor 3.3.3.3 remote-as 200 
neighbor 2.2.2.2 remote-as 100 
neighbor 2.2.2.2 distribute-list 1 out 

access-list 1 deny 160.10.0.0 0.0.255.255 

access-list 1 permit 0.0.0.0 255.255.255.255
</code></pre></div></div>

<blockquote>
  <p>过滤掉所有到160.10.0.0的路由更新</p>
</blockquote>

<p>在处理一些超网的时候访问控制列表可能会有一些棘手</p>

<p>假定，在本节的例子中，RTB有160.10.x.x的不同子网，您的目标是过滤更新并只发布160.0.0.0/8</p>

<p>命令 access-list 1 permit 160.0.0.0 0.255.255.255允许60.0.0.0/8, 160.0.0.0/9，为了将更新限制为仅160.0.0.0/8，必须使用这种格式的扩展访问列表</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>access-list 101 permit ip 160.0.0.0 0.255.255.255 255.0.0.0 0.0.0.0.
</code></pre></div></div>

<p>这个列表只允许160.0.0.0/8</p>

<p>参考 <a href="https://www.cisco.com/en/US/tech/tk365/technologies_tech_note09186a00801310cb.shtml">How to Block One or More Networks From a BGP Peer</a> 里面有关如何过滤来自BGP对等的网络的示例配置，该方法使用具有标准和扩展访问控制列表(acl)的distribution -list命令，以及前缀列表过滤</p>

<h4 id="path-filtering">Path Filtering</h4>

<p>另外一种筛选的方法 path filtering</p>

<p><img src="/assets/images/bgp/b22.png" /></p>

<p>可以使用BGP AS 路径信息 在访问控制列表中应用到出方向和入方向的更新.本节的图中，你可以阻止160.10.0.0的更新去往AS100，若要阻止更新，在RTC上定义一个访问列表，防止将源自AS200的任何更新传输到AS100</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ip as-path access-list access-list-number <span class="o">{</span>permit | deny<span class="o">}</span> as-regular-expression
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>neighbor <span class="o">{</span>ip-address | peer-group-name<span class="o">}</span> filter-list access-list-number <span class="o">{</span><span class="k">in</span> | out<span class="o">}</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTC# 
router bgp 300 
neighbor 3.3.3.3 remote-as 200 
neighbor 2.2.2.2 remote-as 100 
neighbor 2.2.2.2 filter-list 1 out

<span class="o">!</span><span class="nt">---</span> The 1 is the access list number below.

ip as-path access-list 1 deny ^200<span class="nv">$ </span>
ip as-path access-list 1 permit .<span class="k">*</span>
</code></pre></div></div>

<p>本例中的access-list 1命令强制拒绝包含以200开头和以200结尾的路径信息的任何更新，命令中的^200$是一个“正则表达式”，其中^表示匹配开头，$表示匹配结尾，因为RTB发送关于160.10.0.0的更新，其中包含以200开头和以200结尾的路径信息，更新与访问列表匹配。访问列表拒绝这些更新。</p>

<p>：*是另一个正则表达式，.表示“任何字符”，<em>表示“该字符的重复”。所以.</em>表示任何路径信息，这是允许传输所有其他更新所必需的。</p>

<p>如果不是使用^200$，而是使用^200，这本章的图中显示，AS400源的更新具有的路径信息(200,400)。200在前，400在后，这些更新与访问列表^200匹配，因为路径信息以200开头，访问列表阻止将这些更新传输到RTA</p>

<p><a href="https://www.cisco.com/en/US/docs/ios/iproute_bgp/command/reference/irg_bgp5.html#wp1161831">show ip bgp regexp regular-expression</a>命令显示与正则表达式配置匹配的所有路径</p>

<h3 id="as-regular-expression">AS Regular Expression</h3>

<p>正则表达式是与输入字符串匹配的模式。当构建正则表达式时，指定输入必须匹配的字符串。对于BGP，指定一个字符串，该字符串包含输入必须匹配的路径信息</p>

<p>在 <a href="https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/26634-bgp-toc.html#pathfilter">Path Filtering</a>的示例中，指定了字符串^200$。需要更新内部的路径信息来匹配字符串，以便做出决策</p>

<p>正则表达式包括</p>

<p>Range</p>

<p>范围是左方括号和右方括号中的字符序列。例如[abcd]</p>

<p>Atom</p>

<p>Piece</p>

<p>Branch</p>

<p><a href="https://www.cisco.com/en/US/tech/tk365/technologies_tech_note09186a0080094a92.shtml">Using Regular Expressions in BGP</a>   参考提供的样例</p>

<h4 id="bgp-community-filtering">BGP Community Filtering</h4>

<p>本文档介绍路由过滤和AS-path过滤的内容，还有一个方法是community过滤.  <a href="https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/26634-bgp-toc.html#communityattribute">Community Attribute</a>  讨论community，本章提供一些使用community的例子</p>

<p><img src="/assets/images/bgp/b23.png" /></p>

<p>在例子中，你希望RTB为BGP路由设置community属性，使RTC不能传递路由到外部对等体，使用no-export 的community 属性</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTB# 
router bgp 200 
network 160.10.0.0 
neighbor 3.3.3.1 remote-as 300 
neighbor 3.3.3.1 send-community 
neighbor 3.3.3.1 route-map setcommunity out 

route-map setcommunity 
match ip address 1 
<span class="nb">set </span>community no-export  

access-list 1 permit 0.0.0.0 255.255.255.255 
</code></pre></div></div>

<blockquote>
  <p>本例使用route-map setcommunity命令将community设置为no-export</p>
</blockquote>

<blockquote>
  <p>要将此属性发送到RTC，必须使用 neighbor send-community 命令</p>
</blockquote>

<p>当RTC使用NO_EXPORT属性获取更新时，RTC不会将更新传播给外部对等方RTA</p>

<p>在本例中，RTB将community属性设置为 100 200 additive。在向RTC传输之前会在已经存在的community 的值添加100 200</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTB# 
   router bgp 200 
   network 160.10.0.0 
   neighbor 3.3.3.1 remote-as 300 
   neighbor 3.3.3.1 send-community 
   neighbor 3.3.3.1 route-map setcommunity out 

route-map setcommunity 
match ip address 2 
<span class="nb">set </span>community 100 200 additive 

access-list 2 permit 0.0.0.0 255.255.255.255
</code></pre></div></div>

<p>community list是route map的match子句中使用的一组communities。community list 允许根据不同的community 号码 列表 筛选或设置属性</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ip community-list community-list-number <span class="o">{</span>permit | deny<span class="o">}</span> community-number
</code></pre></div></div>

<p>例如，你可以定义route map，match-on-community:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>route-map match-on-community 
match community 10

<span class="o">!</span><span class="nt">---</span> The community list number is 10.

<span class="nb">set </span>weight 20
ip community-list 10 permit 200 300

<span class="o">!</span><span class="nt">---</span> The community number is 200 300.
</code></pre></div></div>

<p>可以使用community列表来过滤或设置某些参数，比如权重和度量，以community值作为基础进行某些更新,在本节的第二个示例中，RTB向RTC发送了一个community为100 200的更新。如果RTC希望以这些值为基础设置权重,可以做如下操作</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTC# 
router bgp 300 
neighbor 3.3.3.3 remote-as 200 
neighbor 3.3.3.3 route-map check-community <span class="k">in 

</span>route-map check-community permit 10 
match community 1 
<span class="nb">set </span>weight 20 

route-map check-community permit 20 
match community 2 exact 
<span class="nb">set </span>weight 10 

route-map check-community permit 30 
match community 3 

ip community-list 1 permit 100 
ip community-list 2 permit 200 
ip community-list 3 permit internet 
</code></pre></div></div>

<p>任何在community属性中包含100的路由都匹配列表1，这条路由的权重设为20。任何只有200的路由匹配community的列表2，并且权重为20。关键字 exact 说明社区只由200个成员组成，没有其他内容。这里是最后一个社区列表，以确保不会删除其他更新，在默认情况下，任何不匹配的内容都会自动删除，关键字internet表示所有路由，因为所有路由都是internet社区的成员</p>

<p>参考   <a href="https://www.cisco.com/en/US/tech/tk365/technologies_configuration_example09186a00801475b2.shtml">Using BGP Community Values to Control Routing Policy in an Upstream Provider Network</a> 获取更多信息</p>

<h3 id="bgp-neighbors-and-route-maps">BGP Neighbors and Route Maps</h3>

<p><img src="/assets/images/bgp/b24.png" /></p>

<p>可以使用neighbor命令和route map结合在一起对进入或者出去的更新进行过滤或者设置参数</p>

<p>当基于IP做匹配的时候，route maps 和 neighbor对进入的更新不起作用</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>neighbor ip-address route-map route-map-name
</code></pre></div></div>

<p>假定图中你想RTC只学习到AS200的网络，并且设置权重为20，可以联合使用neighbor和as-path 访问控制列表</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTC# 
   router bgp 300 
   network 170.10.0.0 
   neighbor 3.3.3.3 remote-as 200 
   neighbor 3.3.3.3 route-map stamp <span class="k">in 

</span>route-map stamp 
match as-path 1 
<span class="nb">set </span>weight 20 

ip as-path access-list 1 permit ^200<span class="err">$</span>
</code></pre></div></div>

<p>任何源自AS200的更新都具有以200开头、以200结尾的路径信息。这些更新是允许的。任何其他更新都会丢弃。</p>

<p>假定你希望实现下面的功能:</p>
<ul>
  <li>接受来自AS200的、权重为20的更新</li>
  <li>删除源自AS400的更新</li>
  <li>其他更新的权重为10</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTC# 
router bgp 300 
network 170.10.0.0 
neighbor 3.3.3.3 remote-as 200 
neighbor 3.3.3.3 route-map stamp <span class="k">in 

</span>route-map stamp permit 10 
match as-path 1 
<span class="nb">set </span>weight 20 

route-map stamp permit 20 
match as-path 2 
<span class="nb">set </span>weight 10 

ip as-path access-list 1 permit ^200<span class="nv">$ </span>
ip as-path access-list 2 permit ^200 600 .<span class="k">*</span>
</code></pre></div></div>

<p>该语句将本地更新的权重设置为20。该语句还为AS400后面的更新设置了10的权重，并丢弃了来自AS400的更新。</p>

<h4 id="use-of-set-as-path-prepend-command">Use of set as-path prepend Command</h4>

<p>在某些情况下，为了操作BGP决策过程，必须要操作路径信息。可以在route map中使用下面的命令:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">set </span>as-path prepend as-path# as-path#
</code></pre></div></div>

<p>假设，在  <a href="https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/26634-bgp-toc.html#neighborsroutemaps">BGP Neighbors and Route Maps</a>  这章中，RTC向两个不同的ASs (AS100和AS200)宣告自己的网络170.10.0.0。当信息传播到AS600时，AS600到170.10.0.0网络在的路由器可以通过两条不同的路由到达。第一个路由是通过AS100(100,300)，第二个路由是通过AS400(400,200,300)。如果所有其它属性都相同，AS600选择最短路径并通过AS100选择路由</p>

<p>AS300通过AS100获得所有的流量。如果您想从AS300改变路由，可以使通过AS100的路径看起来比通过AS400的路径长。如果将宣告中的现有路径信息作为数字添加到AS100中，则可以这样做。一个常见的做法是这样重复你自己的AS号码</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTC# 
router bgp 300 
network 170.10.0.0 
neighbor 2.2.2.2 remote-as 100 
neighbor 2.2.2.2 route-map SETPATH out 

route-map SETPATH 
<span class="nb">set </span>as-path prepend 300 300
</code></pre></div></div>

<p>由于这个配置，AS600通过AS100接收关于170.10.0.0的更新，路径信息为:(100,300,300,300)。这个路径信息比AS600从AS400接收到的(400、200、300)长</p>

<h4 id="bgp-peer-groups">BGP Peer Groups</h4>

<p><img src="/assets/images/bgp/b25.png" /></p>

<p>BGP对等组是一组具有相同更新策略的BGP邻居。roupte maps、distribute lists和filter lists通常设置更新策略。不能为每个单独的邻居定义相同的策略;但可以定义一个对等组名称并将这些策略分配给对等组</p>

<p>对等组的成员继承对等组的所有配置选项。如果这些选项不影响出站更新，还可以配置成员覆盖这些选项。但只能覆盖入站设置的选项</p>

<p>要定义对等组的命令:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>neighbor peer-group-name peer-group
</code></pre></div></div>

<p>此示例将对等组应用于内部和外部BGP邻居</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTC# 
   router bgp 300 
   neighbor internalmap peer-group 
   neighbor internalmap remote-as 300 
   neighbor internalmap route-map SETMETRIC out 
   neighbor internalmap filter-list 1 out 
   neighbor internalmap filter-list 2 <span class="k">in 
   </span>neighbor 5.5.5.2 peer-group internalmap 
   neighbor 5.6.6.2 peer-group internalmap 
   neighbor 3.3.3.2 peer-group internalmap 
   neighbor 3.3.3.2 filter-list 3 <span class="k">in</span>
</code></pre></div></div>

<p>这个配置定义了一个名为internalmap的对等组。该配置为组定义了一些策略，例如将度量设置为5的route map SETMETRIC和两个不同的filter-list 1和2。该配置将对等组应用于所有内部邻居RTE、RTF和RTG。此外，该配置还为邻居RTE定义了一个单独的列表3。此列表覆盖对等组中的列表2</p>

<blockquote>
  <p>只能覆盖影响入站更新的选项</p>
</blockquote>

<p>现在，看看如何使用外部邻居的对等组。可以使用对等组externalmap配置RTC，并将对等组应用于外部邻居</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTC# 
   router bgp 300 
   neighbor externalmap peer-group 
   neighbor externalmap route-map SETMETRIC 
   neighbor externalmap filter-list 1 out 
   neighbor externalmap filter-list 2 <span class="k">in 
   </span>neighbor 2.2.2.2 remote-as 100 
   neighbor 2.2.2.2 peer-group externalmap 
   neighbor 4.4.4.2 remote-as 600 
   neighbor 4.4.4.2 peer-group externalmap 
   neighbor 1.1.1.2 remote-as 200 
   neighbor 1.1.1.2 peer-group externalmap 
   neighbor 1.1.1.2 filter-list 3 <span class="k">in</span>
</code></pre></div></div>

<blockquote>
  <p>在这些配置中，将remote定义为对等组之外的语句，因为必须定义不同的外部ASs</p>
</blockquote>

<p>更多关于对等体组的信息请参考 <a href="https://www.cisco.com/en/US/tech/tk365/technologies_tech_note09186a0080093fb7.shtml">BGP Peer Groups</a>.</p>

<blockquote>
  <p>在Cisco IOS软件发布12.0(24)S中，Cisco引入了BGP动态更新对等组特性。该功能也可以在以后的Cisco IOS软件版本中使用。该特性引入了一种新的算法，详细信息参考  <a href="https://www.cisco.com/univercd/cc/td/doc/product/software/ios120/120newft/120limit/120s/120s24/s_bgpdpg.htm">BGP Dynamic Update Peer-Groups</a></p>
</blockquote>]]></content><author><name>Your Name</name></author><category term="RS" /><summary type="html"><![CDATA[BGP案例03 (参考https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/26634-bgp-toc.html#neighborsroutemaps)]]></summary></entry><entry><title type="html">路由交换 - BGP案例 - 02</title><link href="/rs-bgp-02/" rel="alternate" type="text/html" title="路由交换 - BGP案例 - 02" /><published>2022-08-24T00:00:00+08:00</published><updated>2022-08-24T00:00:00+08:00</updated><id>/rs-bgp-02</id><content type="html" xml:base="/rs-bgp-02/"><![CDATA[<p>BGP案例02
(参考https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/26634-bgp-toc.html#neighborsroutemaps)</p>

<h3 id="as_path-attribute">AS_PATH Attribute</h3>

<p><img src="/assets/images/bgp/b10.png" /></p>

<p>当路由更新通过一个AS的时候，AS的编号会成为这个更新的前缀，AS_PATH属性实际上是一个路由为到达目的地而穿过的AS编号列表.AS_SET是已穿过的所有AS的有序数学集合{}。AS_SET示例: <a href="https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/26634-bgp-toc.html#ex2">CIDR Example 2 (as-set)</a></p>

<p>在本小节的例子中，RTB在AS200中宣告网络190.10.0.0，当路由穿过AS300，RTC添加它自己的AS号码到network，所以当190.10.0.0到达RTA，这个network会被添加两个AS号码，第一个是200，然后是300，RTA上到达190.10.0.0是(300,200)</p>

<p>同样的过程也适用于170.10.0.0和180.10.0.0。RTB必须选择path (300,100)，为了达到170.10.0.0,RTB穿过AS300和AS100。RTC必须穿过路径(200)才能达到190.10.0.0，路径(100)才能达到170.10.0.0</p>

<h3 id="origin-attribute">Origin Attribute</h3>

<p>origin是一个强制性属性，定义路径信息的起源，origion属性能够假定三个值</p>

<ul>
  <li>IGP     网络层可达性信息(NLRI)是网络产生之初的内部信息。这通常发生在发出 bgp network 命令时。BGP表中的i表示IGP。</li>
  <li>EBGP      NLRI是通过外部网关协议(EGP)学习的。BGP表中的e表示EGP</li>
  <li>INCOMPLETE      NLRI是未知的，或者是通过其他方式习得的。当您将路由从其他路由协议重新分发到BGP并且路由的起源不完整时，通常会产生不完整的情况。一个?在BGP表中表示INCOMPLETE</li>
</ul>

<p><img src="/assets/images/bgp/b11.png" /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTA# 
router bgp 100 
neighbor 190.10.50.1 remote-as 100 
neighbor 170.10.20.2 remote-as 300 
network 150.10.0.0 
redistribute static 
 
ip route 190.10.0.0 255.255.0.0 null0 
 
RTB# 
router bgp 100 
neighbor 150.10.30.1 remote-as 100 
network 190.10.50.0 
RTE# 
router bgp 300 
neighbor 170.10.20.1 remote-as 100 
network 170.10.0.0
</code></pre></div></div>

<p>RTA通过300i到达170.10.0.0，“300i”表示下一个AS路径为300，路由为IGP。RTA通过i也达到190.10.50，这个“i”表示这个路由条目在同一个AS内，源也是IGP。RTE通过100i达到150.10.0.0，“100i”表示下一个AS为100，源为IGP，通过100 ? RTE达到190.10.0.0。“100”表示下一个AS是100，源是不完整的，来自静态路由。</p>

<h3 id="bgp-next-hop-attribute">BGP Next Hop Attribute</h3>

<p><img src="/assets/images/bgp/b12.png" /></p>

<p>BGP下一跳属性是为了到达某个目的地而使用的下一跳IP地址</p>

<p>对于EBGP，下一跳总是neighbor 命令指定的邻居的IP地址，在这个例子中，RTC宣告170.10.0.0到RTA，下一跳为170.10.20.2。RTA向RTC宣告150.10.0.0，下一跳是170.10.20.1.对于IBGP，协议规定EBGP宣告的下一跳应该被带到IBGP中。由于这个规则，RTA向它的IBGP对等RTB宣告170.10.0.0，下一跳为170.10.20.2。因此，根据RTB，下一跳到达170.10.0.0的路由是170.10.20.2，而不是150.10.30.1</p>

<p>通过IGP来保证RTB可以到达170.10.20.2，否则，RTB会因为无法访问下一跳地址而将目的地为170.10.0.0的数据包丢弃，例如，如果RTB运行iGRP，在RTA网络170.10.0.0上运行iGRP。可以在和RTC互联的链路上使用被动模式，所以只会有BGP的信息和RTC进行交换</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTA# 
router bgp 100 
neighbor 170.10.20.2 remote-as 300 
neighbor 150.10.50.1 remote-as 100 
network 150.10.0.0 
RTB# 
router bgp 100 
neighbor 150.10.30.1 remote-as 100 
RTC# 
router bgp 300 
neighbor 170.10.20.1 remote-as 100 
network 170.10.0.0 
</code></pre></div></div>

<blockquote>
  <p>RTC宣告170.10.0.0到RTA，下一跳170.10.20.2</p>
</blockquote>

<blockquote>
  <p>RTA宣告170.10.0.0到RTB，下一条170.10.20.2，EBGP的下一跳携带进了IBGP</p>
</blockquote>

<p>在处理多路(multiaccess)和非广播多路(NBMA)网络时要特别小心， <a href="https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/26634-bgp-toc.html#bgpmultiaccess">BGP Next Hop (Multiaccess Networks)</a> 和 <a href="https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/26634-bgp-toc.html#bgpnbma">BGP Next Hop (NBMA)</a> 提供了更详细的信息</p>

<h4 id="bgp-next-hop-multiaccess-networks">BGP Next Hop (Multiaccess Networks)</h4>

<p><img src="/assets/images/bgp/b13.png" /></p>

<p>这个示例显示了下一跳在多路访问(如以太网)上的行为</p>

<p>假定RTC和RTD在AS300中运行OSPF，RTC和RTA运行BGP，RTC可以通过网络170.10.20.3到达180.20.0.0，当RTC向RTA发送关于180.20.0.0的BGP更新时,RTC使用170.10.20.3作为下一跳,RTC没有使用它自己的IP地址，170.10.20.2。RTC使用这个地址是因为RTA、RTC和RTD之间的网络是一个多路网络，RTA使用RTD作为下一跳达到180.20.0.0比通过RTC更合理。</p>

<blockquote>
  <p>RTC向RTA宣告180.20.0.0的下一跳是170.10.20.3</p>
</blockquote>

<p>如果RTA、RTC和RTD的共同介质不是多路访问的，而是NBMA，则会发生进一步的问题</p>

<h4 id="bgp-next-hop-nbma">BGP Next Hop (NBMA)</h4>

<p><img src="/assets/images/bgp/b14.png" /></p>

<p>公共的介质在图中以云的方式出现，如果是帧中继或者其它的NBMA云，RTC向RTA宣告了180.20.0.0，下一跳为170.10.20.3。</p>

<p>问题是RTA没有直接的永久性虚拟电路(PVC)到RTD，并且不能到达下一跳。在这种情况下，路由失败</p>

<p>next-hop-self 命令可以解决这个问题</p>

<p>对于下一跳的情况，例如在BGP下一跳(NBMA)示例中，您可以使用next-hop-self命令。的语法是:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>neighbor <span class="o">{</span>ip-address | peer-group-name<span class="o">}</span> next-hop-self 
</code></pre></div></div>

<p>next-hop-self命令允许强制BGP使用特定的IP地址作为下一跳</p>

<p>对于<a href="https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/26634-bgp-toc.html#bgpnbma">BGP Next Hop (NBMA)</a>示例，这种配置解决了这个问题</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTC# 
router bgp 300 
neighbor 170.10.20.1 remote-as 100 
neighbor 170.10.20.1 next-hop-self 
</code></pre></div></div>

<p>RTC宣告180.20.0.0，下一跳170.10.20.2</p>

<h4 id="bgp-backdoor">BGP Backdoor</h4>

<p><img src="/assets/images/bgp/b15.png" /></p>

<p>在图中，RTA和RTC运行EBGP，RTB和RTC运行EBGP，RTA和RTB运行一种IGP，可以是RIP,IGRP或者其它协议，根据定义，EBGP的更新的AS值是20，小于IGP的AD值，AD值如下：</p>

<ul>
  <li>120 for RIP</li>
  <li>100 for IGRP</li>
  <li>90 for EIGRP</li>
  <li>110 for OSPF</li>
</ul>

<p>RTA接到160.10.0.0的更新来自两个路由协议</p>

<ul>
  <li>eBGP with a distance of 20</li>
  <li>IGP with a distance that is greater than 20</li>
</ul>

<p>默认情况下的BGP AD值</p>

<ul>
  <li>External distance—20</li>
  <li>Internal distance—200</li>
  <li>Local distance—200</li>
</ul>

<p>但你可以使用distance命令来改变默认距离:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>distance bgp external-distance internal-distance local-distance
</code></pre></div></div>

<p>RTA选择了EBGP通过RTC，因为AD值更短</p>

<p>如果你需要RTA通过RTB的IGP学习到160.10.0.0，你有两个选择</p>

<ul>
  <li>改变eBGP的外部AD或IGP AD</li>
  <li>使用BGP backdoor</li>
</ul>

<blockquote>
  <p>不推荐改变eBGP的外部AD或IGP AD</p>
</blockquote>

<p>BGP backdoor使IGP路由优选</p>

<p>使用 <a href="https://www.cisco.com/en/US/docs/ios/iproute_bgp/command/reference/irg_bgp4.html#wp1145478">network address backdoor</a> 命令</p>

<p>配置的网络是你希望通过IDP到达的网络，在BGP中，这个配置的网络会与本地分配的网络同样，除非BGP不宣告这个网络</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTA# 
router eigrp 10 

network 150.10.0.0 

router bgp 100 
neighbor 2.2.2.1 remote-as 300 
network 160.10.0.0 backdoor 
</code></pre></div></div>

<p>Network 160.10.0.0被视为一个本地条目，但不作为一个普通的网络条目进行宣传</p>

<p>RTA通过AD为90的EIGRP向RTB学习到160.10.0.0，RTA还通过AD为20的eBGP向RTC学习到这个地址，正常情况下,EBGP会更优，但是使用了 network backdoor命令，EIGRP会更优</p>

<h3 id="synchronization">Synchronization</h3>

<p><img src="/assets/images/bgp/b16.png" /></p>

<p>在讨论同步前，看下这个情景，RTC在AS300内发出170.10.0.0的更新，RTA和RTB运行IBGP，RTB会得到可以通过2.2.2.1的下一跳到达170.10.0.0的更新，记住这个下一跳是通过IBGP携带的，为了到达下一跳，RTB必须发送流量到RTE</p>

<p>假定没有重分布网络170.10.0.0到IGP，RTE不会知道170.10.0.0是否存在</p>

<p>如果RTB开始向AS400宣告RTB可以到达170.10.0.0，从RTD到RTB 目的为170.10.0.0的流量会被RTE丢弃</p>

<p>如果你的AS传递流量从一个AS到另外一个AS，BGP不能再AS内部的路由器通过IBGP学习到路由之前宣告这条路由，BGP要等待IGP在AS内传播这条路由，然后BGP宣告这条路由到外部对等</p>

<p>在这个例子中，RTB等待IGP的170.10.0.0，然后RTB发送更新到RTD，如果你添加了一条静态路由在RTB中到170.10.0.0，可以使RTB认为IGP已经传播了这条路由，要确保其它路由器可以到达170.10.0.0</p>

<h3 id="disable-synchronization">Disable Synchronization</h3>

<p>在一些情况中，你不需要同步信息，如果你不允许一个其它AS的流量通过你的AS，你可以关闭同步，如果所有的路由器都在你的AS中运行BGP，你可以关闭同步，这样IGP中可以减少路由条目，并且BGP可以更快的收敛</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>router bgp 100 
no synchronization
</code></pre></div></div>

<blockquote>
  <p>设置完成后一定要运行clear ip bgp命令</p>
</blockquote>

<p><img src="/assets/images/bgp/b17.png" /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTB# 
router bgp 100 
network 150.10.0.0 
neighbor 1.1.1.2 remote-as 400 
neighbor 3.3.3.3 remote-as 100 
no synchronization 

<span class="o">!</span><span class="nt">---</span> RTB puts 170.10.0.0 <span class="k">in </span>its IP routing table and advertises the network 
<span class="o">!</span><span class="nt">---</span> to RTD, even <span class="k">if </span>RTB does not have an IGP path to 170.10.0.0.

RTD# 
router bgp 400 
neighbor 1.1.1.1 remote-as 100 
network 175.10.0.0 

RTA# 
   router bgp 100 
   network 150.10.0.0 
   neighbor 3.3.3.4 remote-as 100
</code></pre></div></div>

<h3 id="weight-attribute">Weight Attribute</h3>

<p><img src="/assets/images/bgp/b18.png" /></p>

<p>weight属性是思科的私有属性，这个属性使用weigth值选择最佳路径，weight在本地分配给路由器，只会对特定的路由器有意义，不会通过任何路由更新传播，weight可以是0到65,535之间的数字，初始值为32768，其它的路径为0</p>

<p>同一个目的地由多条路由的时候，权重越高优先级越高，请看下这节的例子，RTA从AS4中学习到175.10.0.0，RTA通告更新到RTC，RTB也从AS4中学习到175.10.0.0，RTB也通告更新到RTC，RTC现在由两条路径到175.10.0.0，需要在两条路中选择一条，如果你在RTC上设置来自RTA的更新权重，强制RTC使用RTA作为到达175.10.0.0的下一跳，有几种方法可以实现</p>

<ul>
  <li>使用 neighbor 命令
    <blockquote>
      <table>
        <tbody>
          <tr>
            <td>neighbor {ip-address</td>
            <td>peer-group} weight weight</td>
          </tr>
        </tbody>
      </table>
    </blockquote>
  </li>
  <li>AS_PATH
    <blockquote>
      <table>
        <tbody>
          <tr>
            <td>ip as-path access-list access-list-number {permit</td>
            <td>deny} as-regular-expression neighbor ip-address filter-list access-list-number weight weight</td>
          </tr>
        </tbody>
      </table>
    </blockquote>
  </li>
  <li>route maps</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTC# 
router bgp 300 
neighbor 1.1.1.1 remote-as 100 
neighbor 1.1.1.1 weight 200 

<span class="o">!</span><span class="nt">---</span> The route to 175.10.0.0 from RTA has a 200 weight.

neighbor 2.2.2.2 remote-as 200 
neighbor 2.2.2.2 weight 100 

<span class="o">!</span><span class="nt">---</span> The route to 175.10.0.0 from RTB has a 100 weight.
</code></pre></div></div>

<p>RTA，具有更高的weight值，是优选的下一跳，同样也可以使用AS_PATH</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTC# 
router bgp 300 
neighbor 1.1.1.1 remote-as 100 
neighbor 1.1.1.1 filter-list 5 weight 200 
neighbor 2.2.2.2 remote-as 200 
neighbor 2.2.2.2 filter-list 6 weight 100 
... 
ip as-path access-list 5 permit ^100<span class="nv">$ </span>

<span class="o">!</span><span class="nt">---</span> This only permits path 100.

ip as-path access-list 6 permit ^200<span class="nv">$ </span>
... 
</code></pre></div></div>

<p>使用route maps</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTC# 
router bgp 300 
neighbor 1.1.1.1 remote-as 100 
neighbor 1.1.1.1 route-map setweightin <span class="k">in 
</span>neighbor 2.2.2.2 remote-as 200 
neighbor 2.2.2.2 route-map setweightin <span class="k">in</span> 
... 
ip as-path access-list 5 permit ^100<span class="nv">$ </span>
... 

route-map setweightin permit 10 
match as-path 5 
<span class="nb">set </span>weight 200 

<span class="o">!</span><span class="nt">---</span> Anything that applies to access list 5, such as packets from AS100, has weight 200.


route-map setweightin permit 20 
   <span class="nb">set </span>weight 100 

<span class="o">!</span><span class="nt">---</span> Anything <span class="k">else </span>has weight 100.
</code></pre></div></div>

<blockquote>
  <p>可以修改权重，以选择MPLS VPN BGP路径  将IGP路径作为备份</p>
</blockquote>

<h4 id="local-preference-attribute">Local Preference Attribute</h4>

<p><img src="/assets/images/bgp/b19.png" /></p>

<p>Local preference 是向AS指明哪条路径对于到达目的网络优先选择，具有高优先级的路径会优先选择，默认的Local preference 是100</p>

<p>不像weight属性，只在本地路由器起作用，Local preference 会在同一个AS内部交换传递</p>

<p>使用 <a href="https://www.cisco.com/en/US/docs/ios/12_3t/ip_route/command/reference/ip2_b1gt.html#wp1078941">bgp default local-preference value</a>设置local preference，也可以使用local preference配合route map使用，就像本节中的实例:</p>

<blockquote>
  <p>如果有变化，必要情况下需要执行软重置(就是清除路由器上的bgp进程),使用clear ip bgp [soft][in/out]清除bgp进程，soft不会重置bgp邻居， [in/out]代表接口方向，如果没有指明in或者out，默认都会重置</p>
</blockquote>

<blockquote>
  <p>bgp default local-preference 命令再路由器更新上设置本地优先级去往同AS内的对等，本节的图中显示，AS256从两个不同的组织接受170.10.0.0更新，Local preference帮助你决定使用哪条路径离开AS256到达目的网络，假如RTD是优先离开地点，这个配置对来自AS300的更新设置local preference为200，对来自AS100 的更新设置为150</p>
</blockquote>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTC# 
router bgp 256 
neighbor 1.1.1.1 remote-as 100 
neighbor 128.213.11.2 remote-as 256 
bgp default local-preference 150 

RTD# 
router bgp 256 
neighbor 3.3.3.4 remote-as 300 
neighbor 128.213.11.1 remote-as 256 
bgp default local-preference 200
</code></pre></div></div>

<p>在这个配置中RTC设置所有更新的local preference 为150，设置RTD所有更新的local preference为200，local preference 会在AS256中交换，因此，RTC和RTD认为来自AS300的170.10.0.0的更新比来自AS100的更新具有更高的优先级，所有去往AS256的流量或通过ETD出去</p>

<p>使用route map可以提供更加灵活的方法，在本章的例子中，当更新到达RTD的时候，所有RTD收到的更新都将Local preference 标记为200，来自AS34更新的local preference也被标记为200，tag不是必须的，你可以使用tag标记为特定的路由设置特定的local preference。下面是示例:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTD# 
router bgp 256 
neighbor 3.3.3.4 remote-as 300 
neighbor 3.3.3.4 route-map setlocalin <span class="k">in 
</span>neighbor 128.213.11.1 remote-as 256 
.... 
ip as-path access-list 7 permit ^300<span class="nv">$ </span>
... 

route-map setlocalin permit 10 
match as-path 7 
<span class="nb">set </span>local-preference 200 

route-map setlocalin permit 20 
<span class="nb">set </span>local-preference 150 
</code></pre></div></div>

<p>在这个配置中，任何来自AS300的更新会将local preference设置为200，其它的更新，比如来自AS34的，会将值设置为150</p>

<h4 id="metric-attribute">Metric Attribute</h4>

<p><img src="/assets/images/bgp/b20.png" /></p>

<p>metric属性也被称作MULTI_EXIT_DISCRIMINATOR，MED (BGP4), 或者 INTER_AS (BGP3),这个属性是向外部的邻居指明哪条路径进入AS更优，metric可以在另一个AS中有多个入口点时到达某个路由时提供了一种动态的方法来改变另一个AS的选路，较低的metric会更优</p>

<p>不像local preference，metric在AS间交换，metric会携带进入一个AS内部，但不会在这个AS中再向其它AS发送，当一个更新携带一个给定的metric进入到一个AS，这个metric会在这个AS中用于选路决策，当同样的更新通过第三个AS的时候，metric会归为0,图中显示了一组度量，metric默认为0</p>

<p>除非路由器接收到其它的信息，路由器会根据来自同一个AS内邻居metric对比来产生路径，为了方便对比来自不同邻居的metrics，你需要在路由器上指明 <a href="https://www.cisco.com/en/US/docs/ios/iproute_bgp/command/reference/irg_bgp1.html#wp1112034">bgp always-compare-med</a> 命令</p>

<blockquote>
  <p>有两个BGP配置命令可以影响基于多出口(MED)的路径选择，<a href="https://www.cisco.com/en/US/docs/ios/iproute_bgp/command/reference/irg_bgp1.html#wp1113816">bgp deterministic-med</a>命令和 bgp always-compare-med命令， bgp deterministic-med 命令确保当不同的对等在相同的AS中发布宣告时，在路由选择时比较MED。 bgp always-compare-med确保不同ASs中邻居路径的MED比较， bgp always-compare-med一般使用在 有多个服务提供者或者是企业要统一设置MED的策略。参考  <a href="https://www.cisco.com/en/US/tech/tk365/technologies_tech_note09186a0080094925.shtml">How the bgp deterministic-med Command Differs from the bgp always-compare-med Command</a>了解这些命令如何影响BGP路径选择</p>
</blockquote>

<p>在本节的图表中，AS100通过三个不同的路由器:RTC、RTD和RTB获取关于网络180.10.0.0的信息。RTC和RTD在AS300中，RTB在AS400中</p>

<p>在本例中，将因为命令  <a href="https://www.cisco.com/en/US/docs/ios/iproute_bgp/command/reference/irg_bgp1.html#wp1112361">bgp bestpath as-path ignore</a> 忽略对RTA的AS-Path比较，它被配置为强制BGP使用下一个属性进行路由比较(在本例中为metric或MED)，如果省略掉该命令，BGP将从路由器RTC路由到180.10.0.0，因为它具有最短的as - path。</p>

<p>假定你将来自RTC的metric设置为120，RTD的metric设置为200，RTB的metric设置为50，默认下，路由器会比较来自同一个AS内邻居的metrics，因此，RTA只能比较来自RTC的metric和来自RTD的metric,RTA选择RTC作为最佳下一跳，因为120小于200.当RTA从RTB获得度量为50的更新时,RTA无法将该指标与120进行比较，因为RTC和RTB在不同的ASs中,RTA必须根据其他一些属性进行选择。</p>

<p>为了强制RTA比较指标，您必须在RTA上发出bgp always-compare-med命令。这些配置说明了这个过程</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTA# 
   router bgp 100 
   neighbor 2.2.2.1 remote-as 300 
   neighbor 3.3.3.3 remote-as 300 
   neighbor 4.4.4.3 remote-as 400 
   bgp bestpath as-path ignore
   .... 

RTC# 
   router bgp 300 
   neighbor 2.2.2.2 remote-as 100 
   neighbor 2.2.2.2 route-map setmetricout out 
   neighbor 1.1.1.2 remote-as 300 

route-map setmetricout permit 10 
   <span class="nb">set </span>metric 120 

RTD# 
   router bgp 300 
   neighbor 3.3.3.2 remote-as 100 
   neighbor 3.3.3.2 route-map setmetricout out 
   neighbor 1.1.1.1 remote-as 300 

route-map setmetricout permit 10 
   <span class="nb">set </span>metric 200 

RTB# 
   router bgp 400 
   neighbor 4.4.4.4 remote-as 100 
   neighbor 4.4.4.4 route-map setmetricout out 

route-map setmetricout permit 10 
   <span class="nb">set </span>metric 50
</code></pre></div></div>

<p>上面的配置,RTA会选择RTC作为下一跳，考虑到所有其他属性都是相同的，为了在度量比较中包含RTB，必须以这种方式配置RTA</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTA# 
router bgp 100 
neighbor 2.2.21 remote-as 300 
neighbor 3.3.3.3 remote-as 300 
neighbor 4.4.4.3 remote-as 400 
bgp always-compare-med
</code></pre></div></div>

<p>在本例中，RTA选择RTB作为下一跳到达网络180.10.0.0</p>

<p>可以使用default-metric命令设置重分布路由的metric</p>

<p>假设在本节的示例中，RTB通过静态将网络引入AS100</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTB# 
router bgp 400 
redistribute static 
default-metric 50 
 
ip route 180.10.0.0 255.255.0.0 null 0 
</code></pre></div></div>

<h4 id="community-attribute">Community Attribute</h4>

<p>community属性是一个可传递的可选属性，范围在0到4,294,967,200之间。community属性是一种在特定community中对目标进行分组并根据这些community应用路由决策的方法。路由决策包括accept, prefer, and redistribute以及其它</p>

<p>您可以使用route map来设置community属性。route map set命令具有以下语法</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">set </span>community community-number <span class="o">[</span>additive] <span class="o">[</span>well-known-community] 
</code></pre></div></div>

<p>一些预定义的</p>
<ul>
  <li>no-export   不向EBGP对等做宣告。将此路由保存在一个AS内</li>
  <li>no-advertise  不要向任何对等(内部或外部)宣传此路由</li>
  <li>internet   在因特网community宣告这条路线。任何路由器都属于这个社区</li>
  <li>local-as  在联合场景中使用，以防止在本地AS之外传输数据包。</li>
</ul>

<p>两个通过route map 设置community的场景</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>route-map communitymap 
match ip address 1 
<span class="nb">set </span>community no-advertise
or

route-map setcommunity 
match as-path 1 
<span class="nb">set </span>community 200 additive 
</code></pre></div></div>

<p>如果你没有使用 additive 关键字,200替换任何已存在的旧的community，如果你设置了additive，community会追加200，即使设置了community属性，默认情况下该属性也不会传输给邻居，要将属性发送给邻居，必须使用此命令</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>neighbor <span class="o">{</span>ip-address | peer-group-name<span class="o">}</span> send-community 
</code></pre></div></div>

<p>例子:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTA# 
router bgp 100 
neighbor 3.3.3.3 remote-as 300 
neighbor 3.3.3.3 send-community 
neighbor 3.3.3.3 route-map setcommunity out
</code></pre></div></div>

<p>在Cisco IOS软件发行版12.0及更高版本中，您可以使用三种不同的格式配置community,decimal, hexadecimal, and AA:NN,默认情况下，思科IOS软件使用的是较老的decimal格式，如果想使用AA:NN的显示和配置，使用  ip bgp-community new-format全局配置命令，AA:NN的第一部分表示AS，第二部分表示2字节数</p>

<p>例子:</p>

<p>如果全局配置中没有ip bgp-community new-format命令，则show ip bgp 6.0.0.0命令将以decimal格式显示community属性值。在本例中，community属性值显示为6553620。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Router# show ip bgp 6.0.0.0
BGP routing table entry <span class="k">for </span>6.0.0.0/8, version 7
Paths: <span class="o">(</span>1 available, best <span class="c">#1, table Default-IP-Routing-Table)</span>
  Not advertised to any peer
  1
    10.10.10.1 from 10.10.10.1 <span class="o">(</span>200.200.200.1<span class="o">)</span>
      Origin IGP, metric 0, localpref 100, valid, external, best
      Community: 6553620
</code></pre></div></div>

<p>配置全局的 ip bgp-community new-format 命令</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Router# configure terminal
Enter configuration commands, one per line.  End with CNTL/Z.
Router<span class="o">(</span>config<span class="o">)</span><span class="c"># ip bgp-community new-format </span>
Router<span class="o">(</span>config<span class="o">)</span><span class="c"># exit</span>
</code></pre></div></div>

<p>使用ip bgp-community new-format 全局配置命令，community值以AA:NN格式显示。该值在本例中的show ip bgp 6.0.0.0命令的输出中显示为100:20</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Router# show ip bgp 6.0.0.0
BGP routing table entry <span class="k">for </span>6.0.0.0/8, version 9
Paths: <span class="o">(</span>1 available, best <span class="c">#1, table Default-IP-Routing-Table)</span>
  Not advertised to any peer
  1
    10.10.10.1 from 10.10.10.1 <span class="o">(</span>200.200.200.1<span class="o">)</span>
      Origin IGP, metric 0, localpref 100, valid, external, best
      Community: 100:20
</code></pre></div></div>]]></content><author><name>Your Name</name></author><category term="RS" /><summary type="html"><![CDATA[BGP案例02 (参考https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/26634-bgp-toc.html#neighborsroutemaps)]]></summary></entry><entry><title type="html">路由交换 - BGP案例 - 01</title><link href="/rs-bgp-01/" rel="alternate" type="text/html" title="路由交换 - BGP案例 - 01" /><published>2022-08-23T00:00:00+08:00</published><updated>2022-08-23T00:00:00+08:00</updated><id>/rs-bgp-01</id><content type="html" xml:base="/rs-bgp-01/"><![CDATA[<p>BGP案例01
(参考https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/26634-bgp-toc.html#neighborsroutemaps)</p>

<h3 id="bgp如何工作">BGP如何工作?</h3>
<p>BGP使用TCP 179端口作为传输协议，两台BGP路由器基于TCP建立连接，建立连接后的路由器成为对等(peer)，对等路由器通过交换信息打开和确认连接参数
BGP路由器交换网络可达信息，信息主要指示出路由必须经过的完整路径，以便到达目标网络。使用BGP的AS号标记路径，用于构建无环的AS图，还显示了在何处应用路由策略，以便对路由行为实施一些限制
为了交换BGP路由信息而形成TCP连接的任何两个路由器都是“对等”或“邻居”，BGP对等初始会交换完整的BGP路由表，交换之后，当路由表发生更改时，对等只会发送增量更新，BGP会对BGP表维持一个版本号，所有的BGP对等都会保持版本号一致，每当BGP路由信息发生更改而更新表时，版本号就会随之更改，keepalive数据包用来确保BGP对等之间的连接是活动的，通知包会在出现错误或特殊情况时发出</p>

<h3 id="ebgp-和-ibgp">EBGP 和 IBGP</h3>

<p>如果一个AS自治系统内有许多BGP路由器(speakers),这个AS可以为其它AS提供过境服务(传递路由)，如图所示，AS200 作为AS100和AS300的过境AS</p>

<p>为了发送信息到外部的AS，必须要保证网络的可达性，为了保证网络的可达性，会发生以下的过程:</p>

<ul>
  <li>内部BGP(ibgp)对等会在一个AS的路由器上运行</li>
  <li>将BGP信息重新分发给运行在AS中的IGP协议</li>
</ul>

<p>当BGP在属于两个不同AS的路由器之间运行时，这称为外部BGP (eBGP)。当BGP在路由器之间以相同的方式运行时，这称为iBGP</p>

<p><img src="/assets/images/bgp/b1.png" /></p>

<h3 id="启用bgp路由">启用BGP路由</h3>

<p>完成下面的配置以启用和配置BGP</p>

<p>假定你有两台路由器RTA和RTB，在第一个例子中，RTA和RTB在不同的AS中，在第二个例子中，两台路由器在一样的AS中</p>

<p>定义路由器进程和路由器所属的AS号。 使用下面的命令在路由器上启用BGP</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTA#
router bgp 100

RTB#
router bgp 200
</code></pre></div></div>

<blockquote>
  <p>这些语句表明RTA运行BGP，属于AS100。RTB运行BGP，属于AS200</p>
</blockquote>

<p>定义BGP邻居</p>

<p>BGP邻居结构表示试图通过BGP通信的路由器，BGP邻居的部分解释了这个过程</p>

<h3 id="bgp邻居">BGP邻居</h3>

<p>路由器之间建立TCP连接后，两个BGP路由器成为邻居。为了让两个对等路由器开始交换路由更新，TCP连接是必不可少的</p>

<p>在TCP连接成功后，路由器会发送open信息来交换值，路由器交换的值包括AS号、路由器运行的BGP版本、BGP路由器ID和keepalive保持时间，在确认和接受这些值之后，会建立邻居，除了Established状态外，任何状态都表明这两个路由器没有成为邻居，并且路由器不能交换BGP更新。</p>

<p>使用neighbor命令建立TCP连接</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>neighbor ip-address remote-as number
</code></pre></div></div>

<p>命令中的number表示要连接到的路由器的AS号， ip-address为直接连接eBGP的下一跳地址，在ibgp中，ip-address可以是其它路由器的任何IP地址，在对等路由器上的neighbor命令后面的Ip地址要相互可达，可以使用扩展ping来验证可达性，扩展ping要使用neighbor的IP地址来作为ping的源地址，而不能使用路由器的数据包发出地址</p>

<p>如果BGP的配置有任何的变化，你必须重置邻居连接以使新的参数生效</p>

<ul>
  <li>clear ip bgp address</li>
  <li>clear ip bgp *</li>
</ul>

<blockquote>
  <p>第一个命令的address 代表邻居的地址，第二个命令表示清楚所有的邻居连接</p>
</blockquote>

<p>默认情况下，BGP会话使用BGP 4版本并且向下兼容，如果需要，可以通过在路由器上强制设置BGP版本来实现邻居间的通信而避免协商，可以在路由器上使用下面的命令配置</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>neighbor <span class="o">{</span>ip address | peer-group-name<span class="o">}</span> version value
</code></pre></div></div>

<p>这是一个neighbor命令配置的例子</p>

<p><img src="/assets/images/bgp/b2.png" /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTA#
router bgp 100
neighbor 129.213.1.1 remote-as 200

RTB#
router bgp 200
neighbor 129.213.1.2 remote-as 100
neighbor 175.220.1.2 remote-as 200

RTC#
router bgp 200
neighbor 175.220.212.1 remote-as 200
</code></pre></div></div>

<p>在这个例子中，RTA和RTB运行EBGP,RTB和RTC运行IBGP,  remote-as后面的as号码指向外部或者内部的AS，表示是EBGP或者IBGP，而且，EBGP对等是直连，IBGP对等没有直连，IBGP路由器不需要直连，单数，它们之间不许有一些IGP运行来确保两个邻居之间可达</p>

<p>show ip bgp neighbors命令显示信息的样例</p>

<blockquote>
  <p>特别需要注意BGP的状态，除了Established，其它状态都代表对等(peers)之间没有UP</p>
</blockquote>

<blockquote>
  <p>同样，注意下面几项:</p>
  <ul>
    <li>BGP的版本，4</li>
    <li>远程路由器的router id，这个数字是路由器上最大的IP地址，或者是最高的环回接口(如果存在的话)</li>
    <li>表的版本，表版本提供表的状态。每当新信息出现时，该表都会增加版本。一个不断增加的版本表示有一些路由抖动导致路由的不断更新</li>
  </ul>
</blockquote>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># show ip bgp neighbors</span>
     BGP neighbor is 129.213.1.1, remote AS 200, external <span class="nb">link 
     </span>BGP version 4, remote router ID 175.220.12.1 
     BGP state <span class="o">=</span> Established, table version <span class="o">=</span> 3, up <span class="k">for </span>0:10:59 
     Last <span class="nb">read </span>0:00:29, hold <span class="nb">time </span>is 180, keepalive interval is 60 seconds 
     Minimum <span class="nb">time </span>between advertisement runs is 30 seconds 
     Received 2828 messages, 0 notifications, 0 <span class="k">in </span>queue 
     Sent 2826 messages, 0 notifications, 0 <span class="k">in </span>queue 
     Connections established 11<span class="p">;</span> dropped 10 
</code></pre></div></div>

<h4 id="bgp-and-loopback-interfaces">BGP and Loopback Interfaces</h4>

<p>在IBGP中通常使用loopback来定义邻居，但在EBGP中却不常见，通常，在IBGP中，使用loopback接口来确保邻居的IP地址保持正常，并且独立于正常运行的硬件。在eBGP的情况下，对等路由器经常具有直接连接，所以， 环回口不适用EBGP</p>

<p>如果你在neighbor命令中使用loopback接口的IP地址，你需要在邻居路由器中敲一些额外的配置，邻居路由器需要通知BGP使用环回接口而不是物理接口来启动BGP邻居TCP连接，为了指明使用环回口，参考下面的命令</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>neighbor ip-address update-source interface
</code></pre></div></div>

<p>这个例子演示了命令的用法</p>

<p><img src="/assets/images/bgp/b3.png" /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTA# 
     router bgp 100 
     neighbor 190.225.11.1 remote-as 100 
     neighbor 190.225.11.1 update-source loopback 1 
RTB# 
     router bgp 100 
     neighbor 150.212.1.1 remote-as 100 
</code></pre></div></div>

<p>这个例子中，RTA和RTB运行IBGP，AS号是100。在neighbor命令中，RTB使用RTA的loopback接口，150.212.1.1，这种情况下，RTA必须强制BGP在TCP邻居连接中使用loopback IP地址作为源,为了可以执行这个动作(将loopback作为源)，RTA添加了  update-source interface-type interface-number命令，也就是 neighbor 190.225.11.1 update-source loopback 1，这句话表示，当BGP和邻居190.225.11.1 通话的时候，强制使用loopback接口的IP地址</p>

<blockquote>
  <p>RTA使用RTB的物理接口190.224.11.1，作为邻居，使用物理接口地址 RTB不需要任何其它的配置，有关完整的网络场景示例配置，请参考  <a href="https://www.cisco.com/en/US/tech/tk365/technologies_configuration_example09186a0080093f25.shtml">Sample Configuration for iBGP and eBGP With or Without a Loopback Address</a></p>
</blockquote>

<h3 id="ebgp-multihop">EBGP Multihop</h3>

<p>有一些情况，思科路由器可以和不允许直连的其它路由器之间运行EBGP，为了实现这种连接，你可以使用EBGP多跳，EBGP多跳可以将两台无法直连的外部对等中间实现连接，多跳只可以在ebgp中实现，不支持ibgp，下面是ebgp 多跳的例子</p>

<p><img src="/assets/images/bgp/b4.png" /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTA# 
router bgp 100 
neighbor 180.225.11.1 remote-as 300 
neighbor 180.225.11.1 ebgp-multihop 
RTB# 
router bgp 300 
neighbor 129.213.1.2 remote-as 100
</code></pre></div></div>

<p>RTA显示没有直接连接的外部邻居，RTA需要使用 <a href="https://www.cisco.com/en/US/docs/ios/iproute_bgp/command/reference/irg_bgp3.html#wp1106590">neighbor ebgp-multihop</a>命令，在另一边，RTB指出直连的邻居，129.213.1.2，因为是直连，RTB不需要使用 neighbor ebgp-multihop命令，你还应该配置IGP或静态路由，以允许没有连接的邻居彼此连接。</p>

<p><a href="https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/26634-bgp-toc.html#ebgpmulithoploadbal">eBGP Multihop (Load Balancing)</a> 演示如何在使用EBGP平行连接的情况下使用BGP实现负载平衡。</p>

<p>eBGP Multihop (Load Balancing)</p>

<p><img src="/assets/images/bgp/b5.png" /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTA# 
int loopback 0 
ip address 150.10.1.1 255.255.255.0 
router bgp 100 
neighbor 160.10.1.1 remote-as 200 
neighbor 160.10.1.1 ebgp-multihop 
neighbor 160.10.1.1 update-source loopback 0 
network 150.10.0.0 
 
ip route 160.10.0.0 255.255.0.0 1.1.1.2 
ip route 160.10.0.0 255.255.0.0 2.2.2.2 
RTB# 
int loopback 0 
ip address 160.10.1.1 255.255.255.0 
router bgp 200 
neighbor 150.10.1.1 remote-as 100 
neighbor 150.10.1.1 update-source loopback 0 
neighbor 150.10.1.1 ebgp-multihop 
network 160.10.0.0 
 
ip route 150.10.0.0 255.255.0.0 1.1.1.1 
ip route 150.10.0.0 255.255.0.0 2.2.2.1
</code></pre></div></div>

<p>这个例子演示了使用 loopback interfaces, update-source, and ebgp-multihop,该示例是一个解决方案，目的是在并行串行线路上实现两个EBGP路由器之间的负载平衡。在正常情况下，BGP会选择一条线路发包，不会发生负载均衡的情况，但引入了环回口，EBGP的吓一跳是环回口，你使用静态路由，或者是IGP,引入两条相等cost路径到达目的地,RTA有两个选择到达下一跳160.10.1.1,一条路径通过1.1.1.2，另一条路径通过2.2.2.2。RTB也有同样的选择</p>

<h3 id="route-maps">Route Maps</h3>

<p>在BGP中大量使用route maps,在BGP的环境中，route map是一种控制和修改路由信息的方法。路由信息的控制和修改是通过定义从一个路由协议到另一个路由协议的路由重分发条件来实现的，或者路由信息的控制可以在BGP进入和发出的时候，route map的命令格式如下</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>route-map map-tag <span class="o">[[</span>permit | deny] | <span class="o">[</span>sequence-number]] 
</code></pre></div></div>

<p>map tag 是给route map起个名字。可以为相同名字或者route map定义多个实例，序列号用来指明在route map中的位置</p>

<p>在这个例子中，为route map定义了两个实例，使用MYMAP的名字.洗一个实例使用10的序号，第二个实例使用20的序号</p>

<ul>
  <li>route-map MYMAP permit 10 (这里设置第一个条件)</li>
  <li>route-map MYMAP permit 20 (这里设置第二个条件)</li>
</ul>

<p>当将route map应用到路由的出方向或者入方向，第一个条件通过实例10来应用，如果第一个条件没有满足，则会继续匹配更高序号的条件</p>

<h4 id="match-and-set-configuration-commands">match and set Configuration Commands</h4>

<p>每个route map 由一组match 和set配置命令组成。match指定匹配条件，set 指定一个set操作，如果match匹配则会执行set操作</p>

<p>例如，你可以定义一个route map检查发出去的更新，如果匹配ip 1.1.1.1的地址，就把这个更新的metric设置为5</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>match ip address 1.1.1.1 
<span class="nb">set </span>metric 5
</code></pre></div></div>

<p>现在，如果你匹配了条件并且添加了permit，就会对路由重新发布，进行set的操作，并且退出</p>

<p>如果你匹配到了条件，并且添加了deny，没有对路由的重新分配或控制，并且退出</p>

<p>如果match没有匹配到并且你设置了permit或者deny，会检查route map的下一个实例。例如，检查实例20。下一个实例检查将继续进行，直到断开或完成route map的所有实例。如果所有的实例都检查完却没有匹配上，则不会接受这条路由或者不转发这条路由</p>

<p>在思科的IOS 11.2之前的版本，如果你使用route maps过滤BGP更新而不是使用在协议间使用重分发,在IP地址上使用match命令时，无法对入站进行筛选，出站可以过滤，11.2之后的版本没有这个限制</p>

<p>相关的match命令</p>
<ul>
  <li>match as-path</li>
  <li>match community</li>
  <li>match clns</li>
  <li>match interface</li>
  <li>match ip address</li>
  <li>match ip next-hop</li>
  <li>match ip route-source</li>
  <li>match metric</li>
  <li>match route-type</li>
  <li>match tag</li>
</ul>

<p>set相关</p>
<ul>
  <li>set as-path</li>
  <li>set clns</li>
  <li>set automatic-tag</li>
  <li>set community</li>
  <li>set interface</li>
  <li>set default interface</li>
  <li>set ip default next-hop</li>
  <li>set level</li>
  <li>set local-preference</li>
  <li>set metric</li>
  <li>set metric-type</li>
  <li>set next-hop</li>
  <li>set origin</li>
  <li>set tag set weight</li>
</ul>

<p>看一个route map的例子</p>

<p><img src="/assets/images/bgp/b6.png" /></p>

<p>假设RTA和RTB运行路由信息协议(RIP)， RTA和RTC运行BGP。RTA通过BGP获取更新并将更新重新分发到RIP。假设RTA希望将170.10.0.0路由重分发到RTB设置度量为2，而所有其他路由的度量为5。在这种情况下，可以使用这种配置</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTA#
router rip
network 3.0.0.0
network 2.0.0.0
network 150.10.0.0
passive-interface Serial0
redistribute bgp 100 route-map SETMETRIC

router bgp 100
neighbor 2.2.2.3 remote-as 300
network 150.10.0.0

route-map SETMETRIC permit 10
match ip-address 1
<span class="nb">set </span>metric 2

route-map SETMETRIC permit 20
<span class="nb">set </span>metric 5

access-list 1 permit 170.10.0.0 0.0.255.255

</code></pre></div></div>

<p>在本例中，如果路由匹配IP地址170.10.0.0，则该路由的度量为2。然后，退出route map。如果没有匹配，您将继续执行route map，会将其他所有的metric 设置为 5(也就是没有match 默认匹配所有)</p>

<blockquote>
  <p>不匹配任何匹配语句的路由会发生什么情况? 默认情况下，这些路由将被删除</p>
</blockquote>

<p>例子2</p>

<p>假设，在示例1中，不希望AS100接受关于170.10.0.0的更新。当将IP地址作为基础匹配时，不能将route map应用于入站方向。因此，你必须在RTC上的出站方向使用route map:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTC#

router bgp 300
network 170.10.0.0
neighbor 2.2.2.2 remote-as 100
neighbor 2.2.2.2 route-map STOPUPDATES out

route-map STOPUPDATES permit 10
match ip address 1

access-list 1 deny 170.10.0.0 0.0.255.255
access-list 1 permit 0.0.0.0 255.255.255.255
</code></pre></div></div>

<p>现在，已经对如何启动BGP和如何定义邻居已经比较熟悉了，接下来看看如何启动网络信息交换。
使用BGP发送网络信息有多种方式。这些部分将逐一介绍这些方法</p>

<ul>
  <li>Network Command</li>
  <li>Redistribution</li>
  <li>Static Routes and Redistribution</li>
</ul>

<h3 id="network-command">network Command</h3>

<p>network 的命令</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>network network-number <span class="o">[</span>mask network-mask]
</code></pre></div></div>

<p>network命令不同于IGRP和RIP，不要尝试在接口上运行BGP，network命令使用mask部分,因为BGP version 4 (BGP4)可以处理子网和上网。最多可以接受200个网络命令条目。</p>

<p>如果路由器知道要宣告的网络，无论是连接的、静态的还是动态学习的，network命令都可以工作。</p>

<p>一个network命令的例子</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTA#
router bgp 1
network 192.213.0.0 mask 255.255.0.0
ip route 192.213.0.0 255.255.0.0 null 0
</code></pre></div></div>

<p>这个例子表明路由器A为192.213.0.0/16生成一个网络条目。/16表示您使用了一个类C地址的超网络，并为前两个八位或前16位做了宣告</p>

<blockquote>
  <p>需要使用静态路由使路由器生成192.213.0.0，因为静态路由会在路由表中放入一个匹配的条目</p>
</blockquote>

<h4 id="redistribution">Redistribution</h4>

<p>network命令是通过BGP宣告网络的一种方式，另外一种方式是重发布你的IGP到BGP中，IGP可以是IGRP\OSPF\RIP\EIGRP\或者其它协议.重发布看起来很恐怖，因为会将所有内部路由都转储到BGP中。其中一些路由是通过BGP学习的，所以不需要再次发送它们，要仔细筛选路由信息，以确保你想发布到internet的是唯一的路由，而不是发送有的的路由出去</p>

<p>RTA宣布129.213.1.0,RTC宣布175.220.0.0。看看RTC配置</p>

<p><img src="/assets/images/bgp/b7.png" /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTC#
router eigrp 10
network 175.220.0.0
redistribute bgp 200
default-metric 1000 100 250 100 1500

router bgp 200
neighbor 1.1.1.1 remote-as 300
network 175.220.0.0 mask 255.255.0.0 
</code></pre></div></div>

<p>如果你使用重发布</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTC#
router eigrp 10
network 175.220.0.0
redistribute bgp 200
default-metric 1000 100 250 100 1500

router bgp 200
neighbor 1.1.1.1 remote-as 300
redistribute eigrp 10
</code></pre></div></div>

<blockquote>
  <p>EIGRP注入129.213.1.0到BGP中</p>
</blockquote>

<p>这种重新分配会导致AS生成129.213.1.0网段。但你不是129.213.1.0的来源，AS100是源。因此，必须使用过滤器来防止AS将源从网络中删除。正确的配置是</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTC#
router eigrp 10
network 175.220.0.0
redistribute bgp 200
default-metric 1000 100 250 100 1500

router bgp 200
neighbor 1.1.1.1 remote-as 300
neighbor 1.1.1.1 distribute-list 1 out
redistribute eigrp 10

access-list 1 permit 175.220.0.0 0.0.255.255
</code></pre></div></div>

<p>可以使用access-list命令来控制源自AS200的网络</p>

<p>OSPF在BGP中的重分布与在其他igp中的重分布略有不同，redistribute ospf 1 在router bgp下不会生效，需要指明 internal, external, 和nssa-external，参考  <a href="https://www.cisco.com/en/US/tech/tk365/technologies_tech_note09186a00800943c5.shtml">Understanding Redistribution of OSPF Routes into BGP</a></p>

<h4 id="static-routes-and-redistribution">Static Routes and Redistribution</h4>

<p>可以使用静态路由去创建一个网络或者子网的路由，唯一不同的是BGP会认为这个路由是未知的或者是不完整的，下面是和重分布例子一样的结果</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTC#
router eigrp 10
network 175.220.0.0
redistribute bgp 200
default-metric 1000 100 250 100 1500

router bgp 200
neighbor 1.1.1.1 remote-as 300
redistribute static
...
ip route 175.220.0.0 255.255.255.0 null0
....

</code></pre></div></div>

<p>null0接口会忽略掉这个包，所以，如果你接收到一个包，而且可以匹配到比175.220.0.0更精确的路由，路由器会通过这个更精确的路由发送包，然而，如果匹配不到，路由器会忽略这个包，这个办法是宣告超网的好办法</p>

<p>本文讨论了如何使用不同的方法从AS中创建路由，请记住，这些路由是在BGP通过邻居学习的其他BGP路由之外生成的(内部或者外部),BGP将通过BGP从其它对等学习到的信息传递给其它对等，不同之处在于，路由是从network命令、重发布，或者是静态作为这些路由器的源，重分布一直都是将BGP引入IGP的方法</p>

<p><img src="/assets/images/bgp/b8.png" /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTA#
router bgp 100
neighbor 150.10.20.2 remote-as 300
network 150.10.0.0

RTB#
router bgp 200
neighbor 160.10.20.2 remote-as 300
network 160.10.0.0

RTC#
router bgp 300
neighbor 150.10.20.1 remote-as 100
neighbor 160.10.20.1 remote-as 200
network 170.10.00
</code></pre></div></div>

<blockquote>
  <p>在RTC中，不需要网络150.10.0.0或网络160.10.0.0，除非希望RTC生成这些网络，并在这些网络从AS100和AS200传入时传递这些网络。同样，区别在于network命令为这些相同的网络添加了一个额外的宣告，这表明AS300也是这些路由的来源</p>
</blockquote>

<blockquote>
  <p>请记住，BGP不接受源自其自身的AS更新。确保无环的域间拓扑</p>
</blockquote>

<p>例如，例子中的AS200和AS100有一个直连，RTA产生一个路由150.10.0.0并且发送这个路由到AS300，然后，RTC将路由传递到AS200，源为AS100，RTB传递150.10.0.0到AS100，源仍然是AS100。RTA注意到更新源自它自己的AS，忽略了更新</p>

<h3 id="ibgp">IBGP</h3>

<p>可以使用IBGP作为其它AS的中转AS.通过学习EBGP，重新分布到IGP中，然后再重新分布到另一个AS中，可以实现同样的功能麽?是的，但是IBGP提供了更灵活和更有效的方法来在AS中交换信息,例如BGP提供一种方式控制local preference来作为AS的出口，<a href="https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/26634-bgp-toc.html#localpref">Local Preference Attribute</a>提供更多的信息</p>

<p><img src="/assets/images/bgp/b9.png" /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RTA#
router bgp 100
neighbor 190.10.50.1 remote-as 100
neighbor 170.10.20.2 remote-as 300
network 150.10.0.0

RTB#
router bgp 100
neighbor 150.10.30.1 remote-as 100
neighbor 175.10.40.1 remote-as 400
network 190.10.50.0

RTC#
router bgp 400
neighbor 175.10.40.2 remote-as 100
network 175.10.0.0
</code></pre></div></div>

<blockquote>
  <p>记住，当一个自治系统中的BGP路由器接收到来自其它路由器的更新信息，收到更新信息的BGP路由器不会将该信息重新分发给其它BGP路由器(同一个AS内)，接收更新的BGP路由器会将信息重新分发给AS之外的其他BGP路由器，因此，在一个AS中要保持IBGP路由器之间的全互联</p>
</blockquote>

<p>上面的例子中，RTA和RTB运行IBGP，RTA和RTD运行IBGP，RTB的BGP的更新到RTA传到RTE，RTE是外部AS，更新不会传给RTD，因为是内部AS，因此，在RTB和RTD之间建立一个IBGP对等，以避免中断更新信息</p>

<h4 id="the-bgp-decision-algorithm">The BGP Decision Algorithm</h4>

<p>当BGP接收到来自不同自治系统的关于不同目的地的更新后，协议必须选择到达特定目的地的路径。BGP只选择一条路径到达特定的目的地。</p>

<p>BGP基于不同的属性进行决策，例如next hop, administrative weights, local preference, route origin, path length, origin code, metric和其它属性</p>

<p>BGP总是向邻居传递最佳路径,参考  <a href="https://www.cisco.com/en/US/tech/tk365/technologies_tech_note09186a0080094431.shtml">BGP Best Path Selection Algorithm</a></p>]]></content><author><name>Your Name</name></author><category term="RS" /><summary type="html"><![CDATA[BGP案例01 (参考https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/26634-bgp-toc.html#neighborsroutemaps)]]></summary></entry><entry><title type="html">`Python 装饰器 - 02`</title><link href="/python-decorator-02/" rel="alternate" type="text/html" title="`Python 装饰器 - 02`" /><published>2022-08-22T00:00:00+08:00</published><updated>2022-08-22T00:00:00+08:00</updated><id>/python-decorator-02</id><content type="html" xml:base="/python-decorator-02/"><![CDATA[<p>Python装饰器介绍</p>

<h3 id="装饰类">装饰类</h3>

<p>在类中有两种不通的方式使用装饰器，第一个和我们之前做过的函数非常相似:在类的方法上应用。这也是当时引入装饰器的原因之一</p>

<p>一些常用的装饰器已经内置到python中，像@classmethod @staticmethod @property。这三个装饰器我们之前都介绍过，这段就不翻译了(打字手酸，偷懒下)</p>

<p>下面的Circle 类使用了@classmethod @staticmethod和@property三个装饰器</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Circle</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radius</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_radius</span> <span class="o">=</span> <span class="n">radius</span>

    <span class="o">@</span><span class="nb">property</span>
    <span class="k">def</span> <span class="nf">radius</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""Get value of radius"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">_radius</span>

    <span class="o">@</span><span class="n">radius</span><span class="p">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">radius</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="s">"""Set radius, raise error if negative"""</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">_radius</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nb">ValueError</span><span class="p">(</span><span class="s">"Radius must be positive"</span><span class="p">)</span>

    <span class="o">@</span><span class="nb">property</span>
    <span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""Calculate area inside circle"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">pi</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="p">.</span><span class="n">radius</span><span class="o">**</span><span class="mi">2</span>

    <span class="k">def</span> <span class="nf">cylinder_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">height</span><span class="p">):</span>
        <span class="s">"""Calculate volume of cylinder with circle as base"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">area</span> <span class="o">*</span> <span class="n">height</span>

    <span class="o">@</span><span class="nb">classmethod</span>
    <span class="k">def</span> <span class="nf">unit_circle</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="s">"""Factory method creating a circle with radius 1"""</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="o">@</span><span class="nb">staticmethod</span>
    <span class="k">def</span> <span class="nf">pi</span><span class="p">():</span>
        <span class="s">"""Value of π, could use math.pi instead though"""</span>
        <span class="k">return</span> <span class="mf">3.1415926535</span>
</code></pre></div></div>

<p>在这个类中</p>
<blockquote>
  <p>.cylinder_volume()是一个常规函数
.radius是一个可变属性:它可以被设置不同的值.然而通过定义setter方法，我们可以做一些判断来确保它不会被设置成一个没有意义的负数，.radius作为属性访问，不使用括号
.area 是一个不可变的属性:没有.setter()方法的属性是无法更改的，即使它被定义为一个方法，它也被作为不需要括号的属性来使用。
.unit_circle() 是一个类方法。它不被绑定到Circle的实例上.类方法通常用在工厂模式，用来创建类的特殊实例
.pi() 是一个静态方法.除了命名空间外它不依赖Circle类。静态方法可以在实例或类上调用。</p>
</blockquote>

<p>Circle类的使用例子</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">Circle</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">radius</span>
<span class="mi">5</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">area</span>
<span class="mf">78.5398163375</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">radius</span> <span class="o">=</span> <span class="mi">2</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">area</span>
<span class="mf">12.566370614</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">area</span> <span class="o">=</span> <span class="mi">100</span>
<span class="nb">AttributeError</span><span class="p">:</span> <span class="n">can</span><span class="s">'t set attribute

&gt;&gt;&gt; c.cylinder_volume(height=4)
50.265482456

&gt;&gt;&gt; c.radius = -1
ValueError: Radius must be positive

&gt;&gt;&gt; c = Circle.unit_circle()
&gt;&gt;&gt; c.radius
1

&gt;&gt;&gt; c.pi()
3.1415926535

&gt;&gt;&gt; Circle.pi()
3.1415926535
</span></code></pre></div></div>

<p>让我们定义一个类，在这个类中，我们会用到前面的@debug和@timer装饰器:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">decorators</span> <span class="kn">import</span> <span class="n">debug</span><span class="p">,</span> <span class="n">timer</span>

<span class="k">class</span> <span class="nc">TimeWaster</span><span class="p">:</span>
    <span class="o">@</span><span class="n">debug</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_num</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">max_num</span> <span class="o">=</span> <span class="n">max_num</span>

    <span class="o">@</span><span class="n">timer</span>
    <span class="k">def</span> <span class="nf">waste_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_times</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_times</span><span class="p">):</span>
            <span class="nb">sum</span><span class="p">([</span><span class="n">i</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">max_num</span><span class="p">)])</span>
</code></pre></div></div>

<p>看一下结果:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">tw</span> <span class="o">=</span> <span class="n">TimeWaster</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
<span class="n">Calling</span> <span class="n">__init__</span><span class="p">(</span><span class="o">&lt;</span><span class="n">time_waster</span><span class="p">.</span><span class="n">TimeWaster</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x7efccce03908</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="s">'__init__'</span> <span class="n">returned</span> <span class="bp">None</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">tw</span><span class="p">.</span><span class="n">waste_time</span><span class="p">(</span><span class="mi">999</span><span class="p">)</span>
<span class="n">Finished</span> <span class="s">'waste_time'</span> <span class="ow">in</span> <span class="mf">0.3376</span> <span class="n">secs</span>
</code></pre></div></div>

<p>另外一种方式是在整个类上使用装饰器.这里有个Python3.7中的dataclasses方法用例:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>

<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>

<span class="o">@</span><span class="n">dataclass</span>
<span class="k">class</span> <span class="nc">PlayingCard</span><span class="p">:</span>
    <span class="n">rank</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">suit</span><span class="p">:</span> <span class="nb">str</span>
</code></pre></div></div>

<p>语法的类似于函数装饰器。在上面的例子中，也可以通过PlayingCard = dataclass(PlayingCard)来实现。</p>

<p>类装饰器的一种简单用法是作为元类方式的替代.在两种情况下，你都在动态的改变一个类的定义</p>

<p>类的装饰器和函数的装饰器语法接近，不同的是装饰器需要接收一个类而不是一个函数作为参数.事实上，上面的装饰器都可以作用于类，但当你这么用的时候，你可能得不到预期的结果。下面将@timer装饰器应用到一个类</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">decorators</span> <span class="kn">import</span> <span class="n">timer</span>

<span class="o">@</span><span class="n">timer</span>
<span class="k">class</span> <span class="nc">TimeWaster</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_num</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">max_num</span> <span class="o">=</span> <span class="n">max_num</span>

    <span class="k">def</span> <span class="nf">waste_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_times</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_times</span><span class="p">):</span>
            <span class="nb">sum</span><span class="p">([</span><span class="n">i</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">max_num</span><span class="p">)])</span>
</code></pre></div></div>

<p>@timer只是TimeWaster = timer(TimeWaster)的缩写</p>

<p>在这里@timer只能显示类实例化需要的时间</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">tw</span> <span class="o">=</span> <span class="n">TimeWaster</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
<span class="n">Finished</span> <span class="s">'TimeWaster'</span> <span class="ow">in</span> <span class="mf">0.0000</span> <span class="n">secs</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">tw</span><span class="p">.</span><span class="n">waste_time</span><span class="p">(</span><span class="mi">999</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span>
</code></pre></div></div>
<p>在后面会有一个正确的类装饰器的示例@singleton。它保证一个类只有一个实例</p>

<h3 id="嵌套的装饰器">嵌套的装饰器</h3>

<p>可以将多个装饰器叠加到一个函数上</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">decorators</span> <span class="kn">import</span> <span class="n">debug</span><span class="p">,</span> <span class="n">do_twice</span>

<span class="o">@</span><span class="n">debug</span>
<span class="o">@</span><span class="n">do_twice</span>
<span class="k">def</span> <span class="nf">greet</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Hello </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div>

<p>运行的顺序会按照叠加的顺序, @debug 调用 @do_twice @do_twice 调用greet()，或者debug(do_twice(greet()))</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">greet</span><span class="p">(</span><span class="s">"Eva"</span><span class="p">)</span>
<span class="n">Calling</span> <span class="n">greet</span><span class="p">(</span><span class="s">'Eva'</span><span class="p">)</span>
<span class="n">Hello</span> <span class="n">Eva</span>
<span class="n">Hello</span> <span class="n">Eva</span>
<span class="s">'greet'</span> <span class="n">returned</span> <span class="bp">None</span>
</code></pre></div></div>
<p>更改@debug和@do_twice的顺序:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">decorators</span> <span class="kn">import</span> <span class="n">debug</span><span class="p">,</span> <span class="n">do_twice</span>

<span class="o">@</span><span class="n">do_twice</span>
<span class="o">@</span><span class="n">debug</span>
<span class="k">def</span> <span class="nf">greet</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Hello </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>  
</code></pre></div></div>
<p>在这种情况下，@do_twice也会被应用到@debug中:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">greet</span><span class="p">(</span><span class="s">"Eva"</span><span class="p">)</span>
<span class="n">Calling</span> <span class="n">greet</span><span class="p">(</span><span class="s">'Eva'</span><span class="p">)</span>
<span class="n">Hello</span> <span class="n">Eva</span>
<span class="s">'greet'</span> <span class="n">returned</span> <span class="bp">None</span>
<span class="n">Calling</span> <span class="n">greet</span><span class="p">(</span><span class="s">'Eva'</span><span class="p">)</span>
<span class="n">Hello</span> <span class="n">Eva</span>
<span class="s">'greet'</span> <span class="n">returned</span> <span class="bp">None</span>
</code></pre></div></div>

<h3 id="带参数的装饰器">带参数的装饰器</h3>
<p>在需要传参给你的装饰器是这个例子会非常有用。例如,@do_twice可以扩展到@repeat(num_times)装饰器.然后，可以将执行的被装饰函数的次数作为参数给出。    <br />
可以这么做:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">repeat</span><span class="p">(</span><span class="n">num_times</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">greet</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Hello </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>      
        
<span class="o">&gt;&gt;&gt;</span> <span class="n">greet</span><span class="p">(</span><span class="s">"World"</span><span class="p">)</span>
<span class="n">Hello</span> <span class="n">World</span>
<span class="n">Hello</span> <span class="n">World</span>
<span class="n">Hello</span> <span class="n">World</span>
<span class="n">Hello</span> <span class="n">World</span> 
</code></pre></div></div>

<p>考虑下如何实现这个功能</p>

<p>到目前为止,写在@后面写的名字引用一个可以被另外一个函数调用的函数对象，需要repeat(num_times=4)来返回一个函数对象，这个对象可以被作为装饰器，幸运的是，我们已经知道如何返回函数!一般来说，需要以下内容:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="n">num_times</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">decorator_repeat</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="p">...</span>  <span class="c1"># Create and return a wrapper function
</span>    <span class="k">return</span> <span class="n">decorator_repeat</span>
</code></pre></div></div>

<p>通常，装饰器创建并返回一个内部包装函数，所以完整地写出这个例子会给你一个内部函数</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="n">num_times</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">decorator_repeat</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="o">@</span><span class="n">functools</span><span class="p">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapper_repeat</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_times</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">wrapper_repeat</span>
    <span class="k">return</span> <span class="n">decorator_repeat</span>
</code></pre></div></div>
<p>例子看起来有点乱，但我们只是添加了一个def来接收参数，这个装饰器语法我们之前处理过多次.让我们从最里面的函数开始:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">wrapper_repeat</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_times</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">value</span>
</code></pre></div></div>

<p>wrapper_repeat()函数接收任意参数，并放回被装饰函数的值，func(). 这个包装函数还包括了被装饰函数num_times的循环 ，除了必须要使用外部参数num_times外，和之前看到的装饰器函数没有什么不同，</p>

<p>再走一步，你就会发现装饰器函数:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">decorator_repeat</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="o">@</span><span class="n">functools</span><span class="p">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper_repeat</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="p">...</span>
    <span class="k">return</span> <span class="n">wrapper_repeat</span>
</code></pre></div></div>

<p>decorator_repeat()和我们之前写的装饰器函数非常像,除了他的名字不同,因为我们为最外层的函数保留了基础名称repeat()，这个是用户要调用的函数。</p>

<p>最外层返回装饰器函数的引用</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="n">num_times</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">decorator_repeat</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="p">...</span>
    <span class="k">return</span> <span class="n">decorator_repeat</span>
</code></pre></div></div>

<p>在repeat()中有一些细节:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    将decorator_repeat()作为一个内部函数意味着repeat()将引用一个函数对象-decotator_repeat.之前，我们用没有括号的repeat来引用函数对象.定义带有参数的装饰器，就需要添加括号
    
    num_times参数看起来没有在repeat()本身中使用，但是通过传递num_times，会创建一个闭包，来存储num_times的值，直到wrapper_repeat()使用它为止。
</code></pre></div></div>

<p>一切就绪后，让我们看看结果:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">repeat</span><span class="p">(</span><span class="n">num_times</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">greet</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Hello </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">greet</span><span class="p">(</span><span class="s">"World"</span><span class="p">)</span>
<span class="n">Hello</span> <span class="n">World</span>
<span class="n">Hello</span> <span class="n">World</span>
<span class="n">Hello</span> <span class="n">World</span>
<span class="n">Hello</span> <span class="n">World</span>
</code></pre></div></div>

<p>这是我们想要的结果</p>

<h3 id="both-please-but-never-mind-the-bread">Both Please, But Never Mind the Bread</h3>

<p>稍微注意下.你可以把装饰器同时定义为带参数或者不带参数.你可能不需要这样，但更有灵活性也不错</p>

<p>前面已经看到，当装饰器需要参数的时候，需要有一个额外的外部函数，困难在于，代码需要知道装饰器是否被调用了，是否有参数</p>

<p>因为只有在没有参数的情况下调用装饰器时才会直接传递装饰的函数，这个函数必须是可选参数.意味着装饰器参数必须要友关键字指定，可以使用特殊的*，也就是说，下面的参数都是关键字</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="n">_func</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">kw1</span><span class="o">=</span><span class="n">val1</span><span class="p">,</span> <span class="n">kw2</span><span class="o">=</span><span class="n">val2</span><span class="p">,</span> <span class="p">...):</span>  <span class="c1"># 1
</span>    <span class="k">def</span> <span class="nf">decorator_name</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="p">...</span>  <span class="c1"># Create and return a wrapper function.
</span>
    <span class="k">if</span> <span class="n">_func</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">decorator_name</span>                      <span class="c1"># 2
</span>    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">decorator_name</span><span class="p">(</span><span class="n">_func</span><span class="p">)</span>               <span class="c1"># 3
</span></code></pre></div></div>

<p>_func参数是一个标记，提示装饰器被调用的时候是否有参数
    1.如果name调用的时候没有传参,被装饰函数会被作为_func传入.如果有参数传入,_func会被置为None,一些关键字参数可能已不再是默认值， 参数列表中的*表示其余参数不能作为位置参数调用。
    2.装饰器可以传参调用，返回一个装饰器函数，它可以读取和返回一个函数
    3.装饰器不可以传参调用,会只将装饰器应用到函数上</p>

<p>改造下之前的@repeat装饰器</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="n">_func</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">num_times</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">decorator_repeat</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="o">@</span><span class="n">functools</span><span class="p">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapper_repeat</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_times</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">wrapper_repeat</span>

    <span class="k">if</span> <span class="n">_func</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">decorator_repeat</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">decorator_repeat</span><span class="p">(</span><span class="n">_func</span><span class="p">)</span><span class="n">n</span>
</code></pre></div></div>

<p>和之前的对比,唯一的变化是在末尾添加了_func参数和if-else。
这些例子表明，@repeat现在可以在有或没有参数的情况下使用:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">repeat</span>
<span class="k">def</span> <span class="nf">say_whee</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Whee!"</span><span class="p">)</span>

<span class="o">@</span><span class="n">repeat</span><span class="p">(</span><span class="n">num_times</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">greet</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Hello </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div>

<p>默认情况num_times的值是2</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">say_whee</span><span class="p">()</span>
<span class="n">Whee</span><span class="err">!</span>
<span class="n">Whee</span><span class="err">!</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">greet</span><span class="p">(</span><span class="s">"Penny"</span><span class="p">)</span>
<span class="n">Hello</span> <span class="n">Penny</span>
<span class="n">Hello</span> <span class="n">Penny</span>
<span class="n">Hello</span> <span class="n">Penny</span>
</code></pre></div></div>

<h3 id="有状态的装饰器">有状态的装饰器</h3>
<p>有时候，可以跟踪状态的装饰器也是很有用的.一个简单的例子，我们会创建一个统计函数调用次数的装饰器</p>

<p>注意:在教程的前面，我们讨论了基于给定参数返回值的纯函数.有状态的装饰器正好相反,返回值取决于当前状态以及给定的参数。</p>

<p>在下一节中，您将看到如何使用类来保持状态。但在简单的情况下，也可以使用函数属性</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">functools</span>

<span class="k">def</span> <span class="nf">count_calls</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="o">@</span><span class="n">functools</span><span class="p">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper_count_calls</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">wrapper_count_calls</span><span class="p">.</span><span class="n">num_calls</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Call </span><span class="si">{</span><span class="n">wrapper_count_calls</span><span class="p">.</span><span class="n">num_calls</span><span class="si">}</span><span class="s"> of </span><span class="si">{</span><span class="n">func</span><span class="p">.</span><span class="n">__name__</span><span class="si">!r}</span><span class="s">"</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">wrapper_count_calls</span><span class="p">.</span><span class="n">num_calls</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">wrapper_count_calls</span>

<span class="o">@</span><span class="n">count_calls</span>
<span class="k">def</span> <span class="nf">say_whee</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Whee!"</span><span class="p">)</span>
</code></pre></div></div>

<p>状态——函数的调用次数——存储在包裹函数(wrapper_count_calls)的函数属性.num_calls中。下面是使用它的效果:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">say_whee</span><span class="p">()</span>
<span class="n">Call</span> <span class="mi">1</span> <span class="n">of</span> <span class="s">'say_whee'</span>
<span class="n">Whee</span><span class="err">!</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">say_whee</span><span class="p">()</span>
<span class="n">Call</span> <span class="mi">2</span> <span class="n">of</span> <span class="s">'say_whee'</span>
<span class="n">Whee</span><span class="err">!</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">say_whee</span><span class="p">.</span><span class="n">num_calls</span>
<span class="mi">2</span>
</code></pre></div></div>

<h3 id="类装饰器">类装饰器</h3>
<p>典型的维护状态的方式是使用类。在本节中，将看到如何重写@count_calls的例子来实现类装饰器</p>

<p>回想一下，装饰器语法@my_decorator只是func = my_decorator(func)一种方便快捷的用法.因此，如果my_decorator是一个类，需要在它的.__init__方法中接收func作为一个参数.而且,这个类需要是可以被调用的,这样它就可以替代装饰器函数了</p>

<p>如果需要一个类可以被调用,要实现.__call__方法</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Counter</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">start</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Current count is </span><span class="si">{</span><span class="bp">self</span><span class="p">.</span><span class="n">count</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div>

<p>__call__方法每次运行都会尝试调用一个类的实例：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">counter</span><span class="p">()</span>
<span class="n">Current</span> <span class="n">count</span> <span class="ow">is</span> <span class="mi">1</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">counter</span><span class="p">()</span>
<span class="n">Current</span> <span class="n">count</span> <span class="ow">is</span> <span class="mi">2</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">counter</span><span class="p">.</span><span class="n">count</span>
<span class="mi">2</span>
</code></pre></div></div>

<p>因此，实现类装饰器需要实现.<strong>init__和.__call</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">functools</span>

<span class="k">class</span> <span class="nc">CountCalls</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="n">functools</span><span class="p">.</span><span class="n">update_wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">num_calls</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">num_calls</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Call </span><span class="si">{</span><span class="bp">self</span><span class="p">.</span><span class="n">num_calls</span><span class="si">}</span><span class="s"> of </span><span class="si">{</span><span class="bp">self</span><span class="p">.</span><span class="n">func</span><span class="p">.</span><span class="n">__name__</span><span class="si">!r}</span><span class="s">"</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="o">@</span><span class="n">CountCalls</span>
<span class="k">def</span> <span class="nf">say_whee</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Whee!"</span><span class="p">)</span>
</code></pre></div></div>

<p>.__init__方法必须可以存储一个函数的引用和能够做一些必要的初始化. 调用.__call__方法来替代装饰器函数.它做的和我们之前的 wrapper()函数基本一样，注意，这里使用functools.update_wrapper()函数，而不是@functools.wraps</p>

<p>这个@CountCalls装饰器的工作原理与前一节相同:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">say_whee</span><span class="p">()</span>
<span class="n">Call</span> <span class="mi">1</span> <span class="n">of</span> <span class="s">'say_whee'</span>
<span class="n">Whee</span><span class="err">!</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">say_whee</span><span class="p">()</span>
<span class="n">Call</span> <span class="mi">2</span> <span class="n">of</span> <span class="s">'say_whee'</span>
<span class="n">Whee</span><span class="err">!</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">say_whee</span><span class="p">.</span><span class="n">num_calls</span>
<span class="mi">2</span>
</code></pre></div></div>

<h3 id="更多现实中的例子">更多现实中的例子</h3>

<p>我们已经学到了很多(看了下翻译的行数量，已经1K+了，确实很多)，已经学会如何创建各种各样的装饰师，把我们的新知识应用到创建更多的示例中，这些示例在现实中可能非常有用。</p>

<h4 id="代码降速重新访问">代码降速,重新访问</h4>

<p>我们之前实现的@slow_down一直是保持sleep 1秒.现在你知道了如何给装饰器添加参数,因此，让我们来重写@slow_down，使用一个可选的rate参数来控制它的sleep时间:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">slow_down</span><span class="p">(</span><span class="n">_func</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">rate</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="s">"""Sleep given amount of seconds before calling the function"""</span>
    <span class="k">def</span> <span class="nf">decorator_slow_down</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="o">@</span><span class="n">functools</span><span class="p">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapper_slow_down</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">time</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">rate</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wrapper_slow_down</span>

    <span class="k">if</span> <span class="n">_func</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">decorator_slow_down</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">decorator_slow_down</span><span class="p">(</span><span class="n">_func</span><span class="p">)</span>
</code></pre></div></div>

<p>我们使用  Both Please, But Never Mind the Bread  这里的样例来让@slow_down有参数和没有参数时都可调用，countdown()函数现在在每次计数之间休眠2秒:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">slow_down</span><span class="p">(</span><span class="n">rate</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">countdown</span><span class="p">(</span><span class="n">from_number</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">from_number</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Liftoff!"</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">from_number</span><span class="p">)</span>
        <span class="n">countdown</span><span class="p">(</span><span class="n">from_number</span> <span class="o">-</span> <span class="mi">1</span>
</code></pre></div></div>

<p>和前面一样，你最好自己写写，跑下看看结果</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">countdown</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="mi">3</span>
<span class="mi">2</span>
<span class="mi">1</span>
<span class="n">Liftoff</span><span class="err">!</span>
</code></pre></div></div>

<h4 id="创建单例模式">创建单例模式</h4>

<p>单例模式是一个只有一个实例的类.在Python经常使用的单例对象包括None,True和False.可以使用is来比较,像我们之前在Both Please的章节中:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">_func</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">decorator_name</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">decorator_name</span><span class="p">(</span><span class="n">_func</span><span class="p">)</span>
</code></pre></div></div>

<p>is只对完全相同实例的对象返回True。下面的@singleton装饰器将类的第一个实例存储为属性，从而将类转换为单例对象。之后创建实例只是返回已经存储的实例</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">functools</span>

<span class="k">def</span> <span class="nf">singleton</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
    <span class="s">"""Make a class a Singleton class (only one instance)"""</span>
    <span class="o">@</span><span class="n">functools</span><span class="p">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper_singleton</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">wrapper_singleton</span><span class="p">.</span><span class="n">instance</span><span class="p">:</span>
            <span class="n">wrapper_singleton</span><span class="p">.</span><span class="n">instance</span> <span class="o">=</span> <span class="n">cls</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wrapper_singleton</span><span class="p">.</span><span class="n">instance</span>
    <span class="n">wrapper_singleton</span><span class="p">.</span><span class="n">instance</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">return</span> <span class="n">wrapper_singleton</span>

<span class="o">@</span><span class="n">singleton</span>
<span class="k">class</span> <span class="nc">TheOne</span><span class="p">:</span>
    <span class="k">pass</span>
</code></pre></div></div>

<p>这个类装饰器和我们的函数装饰器基本一样.唯一不同的地方在于使用cls代替了fun来表示这是一个类装饰器</p>

<p>看下运行结果</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">first_one</span> <span class="o">=</span> <span class="n">TheOne</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">another_one</span> <span class="o">=</span> <span class="n">TheOne</span><span class="p">()</span>

<span class="o">&gt;&gt;&gt;</span> <span class="nb">id</span><span class="p">(</span><span class="n">first_one</span><span class="p">)</span>
<span class="mi">140094218762280</span>

<span class="o">&gt;&gt;&gt;</span> <span class="nb">id</span><span class="p">(</span><span class="n">another_one</span><span class="p">)</span>
<span class="mi">140094218762280</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">first_one</span> <span class="ow">is</span> <span class="n">another_one</span>
<span class="bp">True</span>
</code></pre></div></div>
<p>很明显，first_one确实与另一个实例完全相同。</p>

<h4 id="缓存返回值">缓存返回值</h4>

<p>装饰器可以提供很方便的缓存和记忆机制.作为一个例子，我们来看看斐波那契数列的递归定义:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">decorators</span> <span class="kn">import</span> <span class="n">count_calls</span>

<span class="o">@</span><span class="n">count_calls</span>
<span class="k">def</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">num</span>
    <span class="k">return</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">num</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<p>实现很简单，性能很糟糕</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="o">&lt;</span><span class="n">Lots</span> <span class="n">of</span> <span class="n">output</span> <span class="k">from</span> <span class="n">count_calls</span><span class="o">&gt;</span>
<span class="mi">55</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">fibonacci</span><span class="p">.</span><span class="n">num_calls</span>
<span class="mi">177</span>
</code></pre></div></div>
<p>为了计算第10个斐波那契数，你实际上只需要计算前面的斐波那契数，但是这个实现需要177次计算。更糟糕的是:斐波纳契数列(20)需要21891次计算，第30次需要270万次计算。这是因为代码一直在重新计算已知的斐波那契数。</p>

<p>通常的解决方案是使用for循环和查找表来实现斐波那契数。但是，简单的计算缓存也可以做到这一点</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">from</span> <span class="nn">decorators</span> <span class="kn">import</span> <span class="n">count_calls</span>

<span class="k">def</span> <span class="nf">cache</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="s">"""Keep a cache of previous function calls"""</span>
    <span class="o">@</span><span class="n">functools</span><span class="p">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper_cache</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">cache_key</span> <span class="o">=</span> <span class="n">args</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">kwargs</span><span class="p">.</span><span class="n">items</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">cache_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">wrapper_cache</span><span class="p">.</span><span class="n">cache</span><span class="p">:</span>
            <span class="n">wrapper_cache</span><span class="p">.</span><span class="n">cache</span><span class="p">[</span><span class="n">cache_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wrapper_cache</span><span class="p">.</span><span class="n">cache</span><span class="p">[</span><span class="n">cache_key</span><span class="p">]</span>
    <span class="n">wrapper_cache</span><span class="p">.</span><span class="n">cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">wrapper_cache</span>

<span class="o">@</span><span class="n">cache</span>
<span class="o">@</span><span class="n">count_calls</span>
<span class="k">def</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">num</span>
    <span class="k">return</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">num</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<p>缓存作为查找表工作，所以现在fibonacci()只执行一次计算</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="n">Call</span> <span class="mi">1</span> <span class="n">of</span> <span class="s">'fibonacci'</span>
<span class="p">...</span>
<span class="n">Call</span> <span class="mi">11</span> <span class="n">of</span> <span class="s">'fibonacci'</span>
<span class="mi">55</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="mi">21</span>
</code></pre></div></div>
<p>注意，在对fibonacci(8)的最后调用中，没有进行新的计算，因为fibonacci(10)已经计算了第8个fibonacci数。
在标准库中，提供了@functools.lru_cache。</p>

<p>这个装饰器比上面的例子要具备更多特性.我们应该使用@functools.lru_cache来代替我们自己写的缓存装饰器</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">functools</span>

<span class="o">@</span><span class="n">functools</span><span class="p">.</span><span class="n">lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">fibonacci</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Calculating fibonacci(</span><span class="si">{</span><span class="n">num</span><span class="si">}</span><span class="s">)"</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">num</span>
    <span class="k">return</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">num</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<p>maxsize参数指定缓存了多少次调用。默认值是128，但是可以指定maxsize=None来缓存所有函数调用。但是，请注意，如果正在缓存许多很大的对象，这可能会导致内存问题。</p>

<p>可以使用.cache_info()方法查看缓存的执行情况，并在需要时进行调优。在我们的示例中，我们设定一个小maxsize来查看从缓存中删除元素的效果:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="n">Calculating</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="n">Calculating</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="n">Calculating</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="n">Calculating</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="n">Calculating</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="n">Calculating</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">Calculating</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">Calculating</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">Calculating</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">Calculating</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">Calculating</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="mi">55</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="mi">21</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">Calculating</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">Calculating</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">Calculating</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">Calculating</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">Calculating</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">Calculating</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="mi">5</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="n">Calculating</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="n">Calculating</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="n">Calculating</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="mi">21</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">fibonacci</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="mi">5</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">fibonacci</span><span class="p">.</span><span class="n">cache_info</span><span class="p">()</span>
<span class="n">CacheInfo</span><span class="p">(</span><span class="n">hits</span><span class="o">=</span><span class="mi">17</span><span class="p">,</span> <span class="n">misses</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">maxsize</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">currsize</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="添加单元信息">添加单元信息</h4>

<p>下面的示例与前面的Registering Plugins示例有点类似，因为它不会真正改变被装饰函数的行为。相反，它只是将unit添加为函数属性</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">set_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">):</span>
    <span class="s">"""Register a unit on a function"""</span>
    <span class="k">def</span> <span class="nf">decorator_set_unit</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="n">func</span><span class="p">.</span><span class="n">unit</span> <span class="o">=</span> <span class="n">unit</span>
        <span class="k">return</span> <span class="n">func</span>
    <span class="k">return</span> <span class="n">decorator_set_unit</span>
</code></pre></div></div>
<p>下面的示例根据圆柱体的半径和高度(以厘米为单位)来计算体积</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">math</span>

<span class="o">@</span><span class="n">set_unit</span><span class="p">(</span><span class="s">"cm^3"</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">volume</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">height</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">math</span><span class="p">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">radius</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">height</span>   
    
<span class="n">这个</span><span class="p">.</span><span class="n">unit函数属性是可以访问的</span><span class="p">:</span>    
<span class="o">&gt;&gt;&gt;</span> <span class="n">volume</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="mf">141.3716694115407</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">volume</span><span class="p">.</span><span class="n">unit</span>
<span class="s">'cm^3'</span> 
</code></pre></div></div>
<p>注意，可以使用函数注释实现类似的功能</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">math</span>

<span class="k">def</span> <span class="nf">volume</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s">"cm^3"</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">math</span><span class="p">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">radius</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">height</span>
</code></pre></div></div>

<p>但是，由于注释用于类型提示，因此很难将注释和静态类型检查相结合。</p>

<p>在连接到一个能够在单位间转换的库，单位可以变得更加强大和有趣.pip install pint,  您可以将体积转换为立方英寸或加仑:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">复制代码</span>

<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">pint</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ureg</span> <span class="o">=</span> <span class="n">pint</span><span class="p">.</span><span class="n">UnitRegistry</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">vol</span> <span class="o">=</span> <span class="n">volume</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="n">ureg</span><span class="p">(</span><span class="n">volume</span><span class="p">.</span><span class="n">unit</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">vol</span>
<span class="o">&lt;</span><span class="n">Quantity</span><span class="p">(</span><span class="mf">141.3716694115407</span><span class="p">,</span> <span class="s">'centimeter ** 3'</span><span class="p">)</span><span class="o">&gt;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">vol</span><span class="p">.</span><span class="n">to</span><span class="p">(</span><span class="s">"cubic inches"</span><span class="p">)</span>
<span class="o">&lt;</span><span class="n">Quantity</span><span class="p">(</span><span class="mf">8.627028576414954</span><span class="p">,</span> <span class="s">'inch ** 3'</span><span class="p">)</span><span class="o">&gt;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">vol</span><span class="p">.</span><span class="n">to</span><span class="p">(</span><span class="s">"gallons"</span><span class="p">).</span><span class="n">m</span>  <span class="c1"># Magnitude
</span><span class="mf">0.0373464440537444</span>  
</code></pre></div></div>

<p>你还可以修改装饰器来直接返回一个Pint数量.数量是通过与单位相乘得到的，在pint中，units必须只能在UnitRegistry中查询.这里注册用来存储函数属性来避免命名空间混乱</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">use_unit</span><span class="p">(</span><span class="n">unit</span><span class="p">):</span>
    <span class="s">"""Have a function return a Quantity with given unit"""</span>
    <span class="n">use_unit</span><span class="p">.</span><span class="n">ureg</span> <span class="o">=</span> <span class="n">pint</span><span class="p">.</span><span class="n">UnitRegistry</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">decorator_use_unit</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="o">@</span><span class="n">functools</span><span class="p">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapper_use_unit</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">value</span> <span class="o">*</span> <span class="n">use_unit</span><span class="p">.</span><span class="n">ureg</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wrapper_use_unit</span>
    <span class="k">return</span> <span class="n">decorator_use_unit</span>

<span class="o">@</span><span class="n">use_unit</span><span class="p">(</span><span class="s">"meters per second"</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">average_speed</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">duration</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">distance</span> <span class="o">/</span> <span class="n">duration</span>
</code></pre></div></div>

<p>使用@use_unit装饰器，转换单位实际上是很容易</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">bolt</span> <span class="o">=</span> <span class="n">average_speed</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mf">9.58</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">bolt</span>
<span class="o">&lt;</span><span class="n">Quantity</span><span class="p">(</span><span class="mf">10.438413361169102</span><span class="p">,</span> <span class="s">'meter / second'</span><span class="p">)</span><span class="o">&gt;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">bolt</span><span class="p">.</span><span class="n">to</span><span class="p">(</span><span class="s">"km per hour"</span><span class="p">)</span>
<span class="o">&lt;</span><span class="n">Quantity</span><span class="p">(</span><span class="mf">37.578288100208766</span><span class="p">,</span> <span class="s">'kilometer / hour'</span><span class="p">)</span><span class="o">&gt;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">bolt</span><span class="p">.</span><span class="n">to</span><span class="p">(</span><span class="s">"mph"</span><span class="p">).</span><span class="n">m</span>  <span class="c1"># Magnitude
</span><span class="mf">23.350065679064745</span>
</code></pre></div></div>

<h4 id="验证json">验证JSON</h4>

<p>让我们看最后一个用例。快速看下Flask路由的管理程序</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">route</span><span class="p">(</span><span class="s">"/grade"</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">"POST"</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">update_grade</span><span class="p">():</span>
    <span class="n">json_data</span> <span class="o">=</span> <span class="n">request</span><span class="p">.</span><span class="n">get_json</span><span class="p">()</span>
    <span class="k">if</span> <span class="s">"student_id"</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">json_data</span><span class="p">:</span>
        <span class="n">abort</span><span class="p">(</span><span class="mi">400</span><span class="p">)</span>
    <span class="c1"># Update database
</span>    <span class="k">return</span> <span class="s">"success!"</span>
</code></pre></div></div>

<p>这里我们确保key student_id是请求的一部分.虽然验证有效，但它实际上并不属于函数本身.另外，可能还有其他使用相同验证的路由。因此，让我们Don’t repeat yourself，来使用装饰器抽象出任何不必要的逻辑，下面的@validate_json装饰器会完成这个工作</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">abort</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">validate_json</span><span class="p">(</span><span class="o">*</span><span class="n">expected_args</span><span class="p">):</span>                  <span class="c1"># 1
</span>    <span class="k">def</span> <span class="nf">decorator_validate_json</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="o">@</span><span class="n">functools</span><span class="p">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapper_validate_json</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">json_object</span> <span class="o">=</span> <span class="n">request</span><span class="p">.</span><span class="n">get_json</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">expected_arg</span> <span class="ow">in</span> <span class="n">expected_args</span><span class="p">:</span>      <span class="c1"># 2
</span>                <span class="k">if</span> <span class="n">expected_arg</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">json_object</span><span class="p">:</span>
                    <span class="n">abort</span><span class="p">(</span><span class="mi">400</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wrapper_validate_json</span>
    <span class="k">return</span> <span class="n">decorator_validate_json</span>
</code></pre></div></div>

<p>在上面的代码中，装饰器采用了一个可变长度列表作为参数，这样我们就可以传递尽可能多的字符串参数，每个参数都代表一个用于验证JSON数据的键:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1.json的keys列表作为参数传递给装饰器
2.包裹函数验证JSON数据中出现的每个预期键
</code></pre></div></div>

<p>然后，路由管理程序可以关注其真正的业务级别——因为它可以安全地假设JSON数据是有效的:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">route</span><span class="p">(</span><span class="s">"/grade"</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">"POST"</span><span class="p">])</span>
<span class="o">@</span><span class="n">validate_json</span><span class="p">(</span><span class="s">"student_id"</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">update_grade</span><span class="p">():</span>
    <span class="n">json_data</span> <span class="o">=</span> <span class="n">request</span><span class="p">.</span><span class="n">get_json</span><span class="p">()</span>
    <span class="c1"># Update database.
</span>    <span class="k">return</span> <span class="s">"success!"</span>
</code></pre></div></div>

<h3 id="引用地址">引用地址</h3>
<p>https://realpython.com/primer-on-python-decorators/</p>]]></content><author><name>Your Name</name></author><category term="Python" /><summary type="html"><![CDATA[Python装饰器介绍]]></summary></entry><entry><title type="html">`Python 装饰器 - 01`</title><link href="/python-decorator-01/" rel="alternate" type="text/html" title="`Python 装饰器 - 01`" /><published>2022-08-21T00:00:00+08:00</published><updated>2022-08-21T00:00:00+08:00</updated><id>/python-decorator-01</id><content type="html" xml:base="/python-decorator-01/"><![CDATA[<p>Python装饰器介绍</p>

<p>这是一篇介绍python装饰器的文章，对比之前看到的类似介绍装饰器的文章，个人认为无人可出其右，文章由浅到深，由函数介绍到装饰器的高级应用，每个介绍必有例子说明。文章太长，看完原文后我计划按照文章作者的划分，将分为两章翻出来和大家分享,如果你觉得干的还不错，就点个赞吧</p>

<p>在本次的装饰器教程中，将介绍何为装饰器以及如何创建和使用它们,装饰器提供了简单的语法来调用高阶函数。
从定义上讲，装饰器是一个函数，它接收另一个函数作为参数并且扩展它的功能，但不会显式的去修改它
说起来可能会让人觉得难理解，但它(装饰器)确实不会这么做，特别是一会你会看到一些装饰器如何工作的例子</p>

<h3 id="函数">函数</h3>
<p>在理解装饰器之前，你首先需要理解函数如何工作。函数会基于给定的参数返回值。这里有一个非常简单的例子:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">add_one</span><span class="p">(</span><span class="n">number</span><span class="p">):</span>
<span class="p">...</span>     <span class="k">return</span> <span class="n">number</span> <span class="o">+</span> <span class="mi">1</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">add_one</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="mi">3</span>
</code></pre></div></div>

<p>通常情况下，函数在python中也会有其它功效而不是仅仅接收输入并返回输出。print()函数是一个例子。在控制台输出的时候它会返回None(1)，然而，为了理解装饰器，
将函数认为是接收参数并返回值就足够了</p>

<p>注意:在面向函数编程,你几乎只会使用纯函数，不会有其它功能，然而python不是一个纯函数式语言，python支持许多函数式编程概念，包括一等对象</p>

<h4 id="一等对象">一等对象</h4>
<p>在python中，函数是一等对象，意思是函数可以作为参数被传递，就像其它的对象(string，int，fload，list和其它)，思考下面的三个函数</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">say_hello</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s">"Hello </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s">"</span>

<span class="k">def</span> <span class="nf">be_awesome</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s">"Yo </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s">, together we are the awesomest!"</span>

<span class="k">def</span> <span class="nf">greet_bob</span><span class="p">(</span><span class="n">greeter_func</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">greeter_func</span><span class="p">(</span><span class="s">"Bob"</span><span class="p">)</span>
</code></pre></div></div>

<p>在这里,say_hello()和be_awsone()是常规函数，接收一个name参数返回一个字符串，然而greet_bob()函数，接收一个函数作为他的参数，我们可以将say_hello()或者be_awesome()函数传递给它</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">greet_bob</span><span class="p">(</span><span class="n">say_hello</span><span class="p">)</span>
<span class="s">'Hello Bob'</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">greet_bob</span><span class="p">(</span><span class="n">be_awesome</span><span class="p">)</span>
<span class="s">'Yo Bob, together we are the awesomest!'</span>
</code></pre></div></div>

<p>注意greet_bob(say_hello) 涉及到两个函数，但是不同的是:greet_bob()和say_hello,say_hello函数并没有使用()，代表只传递了对函数的引用，函数没有运行，greet_bob()函数，是使用了括号，所以它会被正常调用</p>

<h4 id="内部函数">内部函数</h4>
<p>在函数内定义函数是被允许的。这类函数被称为内部函数，这里有一个函数和两个内函数的例子</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">parent</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Printing from the parent() function"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">first_child</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Printing from the first_child() function"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">second_child</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Printing from the second_child() function"</span><span class="p">)</span>

    <span class="n">second_child</span><span class="p">()</span>
    <span class="n">first_child</span><span class="p">()</span>
</code></pre></div></div>

<p>当你调用parent()的时候会发生什么? 请考虑一分钟。会出现下面的输出结果</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">parent</span><span class="p">()</span>
<span class="n">Printing</span> <span class="k">from</span> <span class="n">the</span> <span class="n">parent</span><span class="p">()</span> <span class="n">function</span>
<span class="n">Printing</span> <span class="k">from</span> <span class="n">the</span> <span class="n">second_child</span><span class="p">()</span> <span class="n">function</span>
<span class="n">Printing</span> <span class="k">from</span> <span class="n">the</span> <span class="n">first_child</span><span class="p">()</span> <span class="n">function</span>
</code></pre></div></div>

<p>注意内部函数定义的顺序无关紧要，和其它的函数一样，打印只会发生在内部函数运行的时候</p>

<p>而且，内部函数在父函数被调用之前不会生效，它们的局部作用域是父()，它们只作为局部变量存在在父()函数的内部，尝试调用first_child()，你会得到下面的错误</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s">"&lt;stdin&gt;"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="nb">NameError</span><span class="p">:</span> <span class="n">name</span> <span class="s">'first_child'</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">defined</span>
</code></pre></div></div>

<p>不管你何时调用parent()，内部函数first_child()和second_child()都会被调用，因为它们的局部作用域，它们无法再parent()函数外使用</p>

<h4 id="从函数中返回函数">从函数中返回函数</h4>

<p>python允许使用函数来作为返回值，下面的例子从外部的父函数parent()返回了一个内部函数</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">parent</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">first_child</span><span class="p">():</span>
        <span class="k">return</span> <span class="s">"Hi, I am Emma"</span>

    <span class="k">def</span> <span class="nf">second_child</span><span class="p">():</span>
        <span class="k">return</span> <span class="s">"Call me Liam"</span>

    <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">first_child</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">second_chil</span>
</code></pre></div></div>

<p>注意这里返回的first_child是没有括号的，也就是返回了对函数first_child的引用， 带括号的first_child() 指的是对函数求值的结果，这个可以在下面的实例中看到</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">first</span> <span class="o">=</span> <span class="n">parent</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">second</span> <span class="o">=</span> <span class="n">parent</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">first</span>
<span class="o">&lt;</span><span class="n">function</span> <span class="n">parent</span><span class="p">.</span><span class="o">&lt;</span><span class="nb">locals</span><span class="o">&gt;</span><span class="p">.</span><span class="n">first_child</span> <span class="n">at</span> <span class="mh">0x7f599f1e2e18</span><span class="o">&gt;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">second</span>
<span class="o">&lt;</span><span class="n">function</span> <span class="n">parent</span><span class="p">.</span><span class="o">&lt;</span><span class="nb">locals</span><span class="o">&gt;</span><span class="p">.</span><span class="n">second_child</span> <span class="n">at</span> <span class="mh">0x7f599dad5268</span><span class="o">&gt;</span>
</code></pre></div></div>
<p>这个输出代表first变量引用了在parent()中的本地函数first_child()，second则指向了second_child()</p>

<p>你现在可以像常规函数一样使用first和second，虽然他们指向的函数无法被直接访问</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">first</span><span class="p">()</span>
<span class="s">'Hi, I am Emma'</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">second</span><span class="p">()</span>
<span class="s">'Call me Liam'</span>
</code></pre></div></div>

<p>请注意，在前面的例子中我们在父函数中运行内部函数，例如first_child()，然后在最后的例子中，返回的时候没有给内部函数first_child添加括号。这样，就获取了将来可以调用的函数的引用。这样有意义吗?</p>

<h3 id="简单装饰器">简单装饰器</h3>

<p>现在你已经看到函数和python中的其它对象一样，你已经准备好前进来认识python装饰器，让我们以一个例子开始</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">my_decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Something is happening before the function is called."</span><span class="p">)</span>
        <span class="n">func</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Something is happening after the function is called."</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>

<span class="k">def</span> <span class="nf">say_whee</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Whee!"</span><span class="p">)</span>

<span class="n">say_whee</span> <span class="o">=</span> <span class="n">my_decorator</span><span class="p">(</span><span class="n">say_whee</span><span class="p">)</span>
</code></pre></div></div>
<p>你能猜到当你调用say_whee()的时候回发生什么么？试一下</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">say_whee</span><span class="p">()</span>
<span class="n">Something</span> <span class="ow">is</span> <span class="n">happening</span> <span class="n">before</span> <span class="n">the</span> <span class="n">function</span> <span class="ow">is</span> <span class="n">called</span><span class="p">.</span>
<span class="n">Whee</span><span class="err">!</span>
<span class="n">Something</span> <span class="ow">is</span> <span class="n">happening</span> <span class="n">after</span> <span class="n">the</span> <span class="n">function</span> <span class="ow">is</span> <span class="n">called</span><span class="p">.</span>
</code></pre></div></div>

<p>要理解这里发生了什么，需要回看下之前的例子，我们只是应用了你到目前为止学到的所有东西</p>

<p>所谓的装饰器发生在下面这行</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">say_whee</span> <span class="o">=</span> <span class="n">my_decorator</span><span class="p">(</span><span class="n">say_whee</span><span class="p">)</span>
</code></pre></div></div>

<p>事实上，say_whee现在指向了内部函数wrapper()，当你调用my_decorator(say_whee)的时候会将wrapper作为函数返回</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">say_whee</span>
<span class="o">&lt;</span><span class="n">function</span> <span class="n">my_decorator</span><span class="p">.</span><span class="o">&lt;</span><span class="nb">locals</span><span class="o">&gt;</span><span class="p">.</span><span class="n">wrapper</span> <span class="n">at</span> <span class="mh">0x7f3c5dfd42f0</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>wrapper()引用原始的say_whee()作为func，在两个print()之间调用这个函数</p>

<p>简而言之:装饰器包裹一个函数，并改变它的行为</p>

<p>在继续之前，让我们看下第二个例子。因为wrapper()是一个常规的函数，装饰器可以以一种动态的方式来修改函数。为了不打扰你的邻居，下面的示例演示只会在白天运行的装饰器</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>

<span class="k">def</span> <span class="nf">not_during_the_night</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">():</span>
        <span class="k">if</span> <span class="mi">7</span> <span class="o">&lt;=</span> <span class="n">datetime</span><span class="p">.</span><span class="n">now</span><span class="p">().</span><span class="n">hour</span> <span class="o">&lt;</span> <span class="mi">22</span><span class="p">:</span>
            <span class="n">func</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># Hush, the neighbors are asleep
</span>    <span class="k">return</span> <span class="n">wrapper</span>

<span class="k">def</span> <span class="nf">say_whee</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Whee!"</span><span class="p">)</span>

<span class="n">say_whee</span> <span class="o">=</span> <span class="n">not_during_the_night</span><span class="p">(</span><span class="n">say_whee</span><span class="p">)</span>
</code></pre></div></div>

<p>如果你在睡觉的时间调用say_whee()，不会发生任何事情</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">say_whee</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span>
</code></pre></div></div>

<h4 id="语法糖">语法糖</h4>

<p>上面的装饰器say_whee()用起来有一点笨拙。首先，你键入了三次say_whee，另外，装饰器隐藏在了函数的定义之下</p>

<p>作为替代，python允许你使用@symbol的方式使用装饰器，有时被称为”pie”语法，下面的例子和之前第一个装饰器做了同样的事情</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">my_decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Something is happening before the function is called."</span><span class="p">)</span>
        <span class="n">func</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Something is happening after the function is called."</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>

<span class="o">@</span><span class="n">my_decorator</span>
<span class="k">def</span> <span class="nf">say_whee</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Whee!"</span><span class="p">)</span>
</code></pre></div></div>

<p>所以，@my_decorator 只是say_whee = my_decorator(say_whee)的一种快捷方式，这就是如何将装饰器应用到函数上</p>

<h4 id="复用装饰器">复用装饰器</h4>

<p>回想一下，装饰器只是一个普通的函数。所有常用的工具都是方便重复利用的，让我们将装饰器移动到他自己的模型上以便于在其它的函数上使用</p>

<p>下面创建了一个decorators.py</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">do_twice</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper_do_twice</span><span class="p">():</span>
        <span class="n">func</span><span class="p">()</span>
        <span class="n">func</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">wrapper_do_twice</span>
</code></pre></div></div>

<p>注意:你可以随意定义内部函数的名称，通常像wrapper()用起来是没问题的。你在这篇文章中会遇到许多装饰器。为了区别开它们，我们将使用decorator名称来命名内部函数，但会加上wrapper_前缀。</p>

<p>你可以使用常规导入来使用一个新的装饰器</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">decorators</span> <span class="kn">import</span> <span class="n">do_twice</span>

<span class="o">@</span><span class="n">do_twice</span>
<span class="k">def</span> <span class="nf">say_whee</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Whee!"</span><span class="p">)</span>
</code></pre></div></div>

<p>当你运行这个例子，你会看到原始韩式say_whee()执行两次</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">say_whee</span><span class="p">()</span>
<span class="n">Whee</span><span class="err">!</span>
<span class="n">Whee</span><span class="err">!</span>
</code></pre></div></div>

<h4 id="装饰器传参">装饰器传参</h4>

<p>如果你有一个函数需要接收一些参数，这时候还可以再使用装饰器么，然我们试试</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">decorators</span> <span class="kn">import</span> <span class="n">do_twice</span>

<span class="o">@</span><span class="n">do_twice</span>
<span class="k">def</span> <span class="nf">greet</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Hello </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div>

<p>不幸的是，运行代码抛出了错误</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">greet</span><span class="p">(</span><span class="s">"World"</span><span class="p">)</span>
<span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="n">File</span> <span class="s">"&lt;stdin&gt;"</span><span class="p">,</span> <span class="n">line</span> <span class="mi">1</span><span class="p">,</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="nb">TypeError</span><span class="p">:</span> <span class="n">wrapper_do_twice</span><span class="p">()</span> <span class="n">takes</span> <span class="mi">0</span> <span class="n">positional</span> <span class="n">arguments</span> <span class="n">but</span> <span class="mi">1</span> <span class="n">was</span> <span class="n">given</span>
</code></pre></div></div>

<p>问题在于内部函数wrapper_do_twice()没有接收任何参数，但是name=”World”却传给了它。你可以让wrapper_do_twice()接收一个参数来修补这个问题，但是这样前面的say_whee()函数就无法工作了</p>

<p>解决方案是在内部函数使用*args和**kwargs ，这样它会允许接收任意个关键参数，下面重写了decorators.py</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">do_twice</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper_do_twice</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper_do_twice</span>
</code></pre></div></div>

<p>内部函数wrapper_do_twice()现在接收任意数量的参数并会传递给装饰的函数，目前say_whee()和greet()都会正常工作</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">say_whee</span><span class="p">()</span>
<span class="n">Whee</span><span class="err">!</span>
<span class="n">Whee</span><span class="err">!</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">greet</span><span class="p">(</span><span class="s">"World"</span><span class="p">)</span>
<span class="n">Hello</span> <span class="n">World</span>
<span class="n">Hello</span> <span class="n">World</span>
</code></pre></div></div>

<h4 id="从装饰器返回值">从装饰器返回值</h4>

<p>被装饰的函数返回值会发生什么？这会由装饰器来决定，我们下面有一个简单的装饰器函数</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">decorators</span> <span class="kn">import</span> <span class="n">do_twice</span>

<span class="o">@</span><span class="n">do_twice</span>
<span class="k">def</span> <span class="nf">return_greeting</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Creating greeting"</span><span class="p">)</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s">"Hi </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s">"</span>
</code></pre></div></div>

<p>尝试运行它</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">hi_adam</span> <span class="o">=</span> <span class="n">return_greeting</span><span class="p">(</span><span class="s">"Adam"</span><span class="p">)</span>
<span class="n">Creating</span> <span class="n">greeting</span>
<span class="n">Creating</span> <span class="n">greeting</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">hi_adam</span><span class="p">)</span>
<span class="bp">None</span>
</code></pre></div></div>

<p>装饰器吃掉了从函数返回的值</p>

<p>因为do_twice_wrapper()没有返回值，调用 return_greeting(“Adam”) 最后返回了None</p>

<p>修复的方式是,需要确认装饰器返回它装饰的函数的值，改变decorators.py文件:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">do_twice</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper_do_twice</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper_do_twice</span>
</code></pre></div></div>

<p>执行这个函数返回的值</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">return_greeting</span><span class="p">(</span><span class="s">"Adam"</span><span class="p">)</span>
<span class="n">Creating</span> <span class="n">greeting</span>
<span class="n">Creating</span> <span class="n">greeting</span>
<span class="s">'Hi Adam'</span>
</code></pre></div></div>

<h4 id="你是谁">你是谁</h4>

<p>在使用Python(尤其是在交互式shell中)时，强大的内省是非常方便的功能。内省是对象在运行时了解其自身属性的能力。例如，函数知道自己的名称和文档:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="k">print</span>
<span class="o">&lt;</span><span class="n">built</span><span class="o">-</span><span class="ow">in</span> <span class="n">function</span> <span class="k">print</span><span class="o">&gt;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">.</span><span class="n">__name__</span>
<span class="s">'print'</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">help</span><span class="p">(</span><span class="k">print</span><span class="p">)</span>
<span class="n">Help</span> <span class="n">on</span> <span class="n">built</span><span class="o">-</span><span class="ow">in</span> <span class="n">function</span> <span class="k">print</span> <span class="ow">in</span> <span class="n">module</span> <span class="n">builtins</span><span class="p">:</span>

<span class="k">print</span><span class="p">(...)</span>
    <span class="o">&lt;</span><span class="n">full</span> <span class="n">help</span> <span class="n">message</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>内省同样适用于你自定义的函数</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">say_whee</span>
<span class="o">&lt;</span><span class="n">function</span> <span class="n">do_twice</span><span class="p">.</span><span class="o">&lt;</span><span class="nb">locals</span><span class="o">&gt;</span><span class="p">.</span><span class="n">wrapper_do_twice</span> <span class="n">at</span> <span class="mh">0x7f43700e52f0</span><span class="o">&gt;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">say_whee</span><span class="p">.</span><span class="n">__name__</span>
<span class="s">'wrapper_do_twice'</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">help</span><span class="p">(</span><span class="n">say_whee</span><span class="p">)</span>
<span class="n">Help</span> <span class="n">on</span> <span class="n">function</span> <span class="n">wrapper_do_twice</span> <span class="ow">in</span> <span class="n">module</span> <span class="n">decorators</span><span class="p">:</span>

<span class="n">wrapper_do_twice</span><span class="p">()</span>
</code></pre></div></div>

<p>然而在被装饰后，say_whee()会对自身感到疑惑。它现在显示为 do_twice()装饰器的内部函数 wrapper_do_twice()</p>

<p>为了修复这个，装饰器需要使用@functools.wraps装饰器，它会保留原始函数的信息，再次更新下decorators.py</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">functools</span>

<span class="k">def</span> <span class="nf">do_twice</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="o">@</span><span class="n">functools</span><span class="p">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper_do_twice</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper_do_twice</span>
</code></pre></div></div>

<p>不需要对被装饰的say_whee()函数做任何更改</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">say_whee</span>
<span class="o">&lt;</span><span class="n">function</span> <span class="n">say_whee</span> <span class="n">at</span> <span class="mh">0x7ff79a60f2f0</span><span class="o">&gt;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">say_whee</span><span class="p">.</span><span class="n">__name__</span>
<span class="s">'say_whee'</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">help</span><span class="p">(</span><span class="n">say_whee</span><span class="p">)</span>
<span class="n">Help</span> <span class="n">on</span> <span class="n">function</span> <span class="n">say_whee</span> <span class="ow">in</span> <span class="n">module</span> <span class="n">whee</span><span class="p">:</span>

<span class="n">say_whee</span><span class="p">()</span>
</code></pre></div></div>
<p>非常好，现在say_whee()在被装饰后可以保持自己</p>

<p>技术细节:@funtools.wraps 装饰器使用函数functools.update_wrapper()来更新指定的属性，像__name__和__doc__来用于自省</p>

<h3 id="一些现实中的例子">一些现实中的例子</h3>

<p>让我们看一些用处更大的装饰器例子。你会注意到他们主要的模式和你现在所学的都是一样的</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">functools</span>

<span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="o">@</span><span class="n">functools</span><span class="p">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper_decorator</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Do something before
</span>        <span class="n">value</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Do something after
</span>        <span class="k">return</span> <span class="n">value</span>
    <span class="k">return</span> <span class="n">wrapper_decorator</span>
</code></pre></div></div>

<p>对于构建更复杂的装饰器，这个是一个很好的模板</p>

<h4 id="时间函数">时间函数</h4>
<p>让我们从@timer装饰器开始，它会测量函数运行的时间并且打印持续时间到控制台，这是代码</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">timer</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="s">"""Print the runtime of the decorated function"""</span>
    <span class="o">@</span><span class="n">functools</span><span class="p">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper_timer</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">perf_counter</span><span class="p">()</span>    <span class="c1"># 1
</span>        <span class="n">value</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">end_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">perf_counter</span><span class="p">()</span>      <span class="c1"># 2
</span>        <span class="n">run_time</span> <span class="o">=</span> <span class="n">end_time</span> <span class="o">-</span> <span class="n">start_time</span>    <span class="c1"># 3
</span>        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Finished </span><span class="si">{</span><span class="n">func</span><span class="p">.</span><span class="n">__name__</span><span class="si">!r}</span><span class="s"> in </span><span class="si">{</span><span class="n">run_time</span><span class="si">:</span><span class="p">.</span><span class="mi">4</span><span class="n">f</span><span class="si">}</span><span class="s"> secs"</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span>
    <span class="k">return</span> <span class="n">wrapper_timer</span>

<span class="o">@</span><span class="n">timer</span>
<span class="k">def</span> <span class="nf">waste_some_time</span><span class="p">(</span><span class="n">num_times</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_times</span><span class="p">):</span>
        <span class="nb">sum</span><span class="p">([</span><span class="n">i</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">)])</span>
</code></pre></div></div>

<p>这个函数是在函数运行之前获取时间(#1行)，并且在函数运行结束之后获取时间(#2行)，我们使用 time.perf_counter() 函数，这个函数可以非常好的计算时间间隔。下面是一个示例</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">waste_some_time</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">Finished</span> <span class="s">'waste_some_time'</span> <span class="ow">in</span> <span class="mf">0.0010</span> <span class="n">secs</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">waste_some_time</span><span class="p">(</span><span class="mi">999</span><span class="p">)</span>
<span class="n">Finished</span> <span class="s">'waste_some_time'</span> <span class="ow">in</span> <span class="mf">0.3260</span> <span class="n">secs</span>
</code></pre></div></div>

<p>自己运行测试下，手敲下这里的代码，确保你理解它的工作原理。如果不明白，也不要担心。装饰器是高级方法，试着思考下或者画下流程图</p>

<p>注意: 如果你只是想获取函数的运行时间，@timer 装饰器可以满足。如果你想获取到更精确的数据，你应该考虑使用timeit 模块来替代它。它临时禁用了垃圾收集并且运行多次以避免函数快速调用带来的噪音数据</p>

<h4 id="调试代码">调试代码</h4>

<p>下面的@debug函数会在每次调用的时候打印函数被调用的参数和它的返回结果</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">functools</span>

<span class="k">def</span> <span class="nf">debug</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="s">"""Print the function signature and return value"""</span>
    <span class="o">@</span><span class="n">functools</span><span class="p">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper_debug</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">args_repr</span> <span class="o">=</span> <span class="p">[</span><span class="nb">repr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>                      <span class="c1"># 1
</span>        <span class="n">kwargs_repr</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s">=</span><span class="si">{</span><span class="n">v</span><span class="si">!r}</span><span class="s">"</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">.</span><span class="n">items</span><span class="p">()]</span>  <span class="c1"># 2
</span>        <span class="n">signature</span> <span class="o">=</span> <span class="s">", "</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">args_repr</span> <span class="o">+</span> <span class="n">kwargs_repr</span><span class="p">)</span>           <span class="c1"># 3
</span>        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Calling </span><span class="si">{</span><span class="n">func</span><span class="p">.</span><span class="n">__name__</span><span class="si">}</span><span class="s">(</span><span class="si">{</span><span class="n">signature</span><span class="si">}</span><span class="s">)"</span><span class="p">)</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">func</span><span class="p">.</span><span class="n">__name__</span><span class="si">!r}</span><span class="s"> returned </span><span class="si">{</span><span class="n">value</span><span class="si">!r}</span><span class="s">"</span><span class="p">)</span>           <span class="c1"># 4
</span>        <span class="k">return</span> <span class="n">value</span>
    <span class="k">return</span> <span class="n">wrapper_debug</span>
</code></pre></div></div>

<p>signature 变量是通过 字符串表示方法 来创建所有的输入参数。下面的数字对应了代码中的注释</p>
<ul>
  <li>将args创建为列表，使用repr修饰</li>
  <li>将kwargs创建为列表，使用f-string格式化参数为key=value，!r表示使用repr()表示值</li>
  <li>args和kwargs转换后会合并在signature变量中，使用逗号分隔每个变量</li>
  <li>函数运行结束后会返回值</li>
</ul>

<p>让我们在一个简单的函数中使用装饰器被观察它是如何运行的，被装饰的函数只有一个位置参数和一个关键字参数</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">debug</span>
<span class="k">def</span> <span class="nf">make_greeting</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">age</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s">"Howdy </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s">!"</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s">"Whoa </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s">! </span><span class="si">{</span><span class="n">age</span><span class="si">}</span><span class="s"> already, you are growing up!"</span>
</code></pre></div></div>

<p>注意@debug装饰器如何打印make_greeting()函数的signature 和返回值</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">make_greeting</span><span class="p">(</span><span class="s">"Benjamin"</span><span class="p">)</span>
<span class="n">Calling</span> <span class="n">make_greeting</span><span class="p">(</span><span class="s">'Benjamin'</span><span class="p">)</span>
<span class="s">'make_greeting'</span> <span class="n">returned</span> <span class="s">'Howdy Benjamin!'</span>
<span class="s">'Howdy Benjamin!'</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">make_greeting</span><span class="p">(</span><span class="s">"Richard"</span><span class="p">,</span> <span class="n">age</span><span class="o">=</span><span class="mi">112</span><span class="p">)</span>
<span class="n">Calling</span> <span class="n">make_greeting</span><span class="p">(</span><span class="s">'Richard'</span><span class="p">,</span> <span class="n">age</span><span class="o">=</span><span class="mi">112</span><span class="p">)</span>
<span class="s">'make_greeting'</span> <span class="n">returned</span> <span class="s">'Whoa Richard! 112 already, you are growing up!'</span>
<span class="s">'Whoa Richard! 112 already, you are growing up!'</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">make_greeting</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">"Dorrisile"</span><span class="p">,</span> <span class="n">age</span><span class="o">=</span><span class="mi">116</span><span class="p">)</span>
<span class="n">Calling</span> <span class="n">make_greeting</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">'Dorrisile'</span><span class="p">,</span> <span class="n">age</span><span class="o">=</span><span class="mi">116</span><span class="p">)</span>
<span class="s">'make_greeting'</span> <span class="n">returned</span> <span class="s">'Whoa Dorrisile! 116 already, you are growing up!'</span>
<span class="s">'Whoa Dorrisile! 116 already, you are growing up!'</span> 
</code></pre></div></div>

<p>@debug修饰符看起来只是重复了我们刚才写的内容 ，并不是非常有用。 但当应用到不能直接修改的其它函数时，它会更加强大。</p>

<p>下面的例子计算了一个数学常数E的近似值</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">decorators</span> <span class="kn">import</span> <span class="n">debug</span>

<span class="c1"># Apply a decorator to a standard library function
</span><span class="n">math</span><span class="p">.</span><span class="n">factorial</span> <span class="o">=</span> <span class="n">debug</span><span class="p">(</span><span class="n">math</span><span class="p">.</span><span class="n">factorial</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">approximate_e</span><span class="p">(</span><span class="n">terms</span><span class="o">=</span><span class="mi">18</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">math</span><span class="p">.</span><span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">terms</span><span class="p">))</span>
</code></pre></div></div>

<p>这个例子还演示了如何将装饰器应用到已经定义了的函数</p>

<p><img src="/assets/images/python/p01.jpg" /></p>

<p>当调用approximate_e()函数，你可以看到@debug函数在工作</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">approximate_e</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">Calling</span> <span class="n">factorial</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="s">'factorial'</span> <span class="n">returned</span> <span class="mi">1</span>
<span class="n">Calling</span> <span class="n">factorial</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="s">'factorial'</span> <span class="n">returned</span> <span class="mi">1</span>
<span class="n">Calling</span> <span class="n">factorial</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="s">'factorial'</span> <span class="n">returned</span> <span class="mi">2</span>
<span class="n">Calling</span> <span class="n">factorial</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="s">'factorial'</span> <span class="n">returned</span> <span class="mi">6</span>
<span class="n">Calling</span> <span class="n">factorial</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="s">'factorial'</span> <span class="n">returned</span> <span class="mi">24</span>
<span class="mf">2.708333333333333</span>
</code></pre></div></div>

<p>在这个例子中，可以得到一个真实值的近似值e = 2.718281828</p>

<h4 id="给代码降速">给代码降速</h4>

<p>下面的例子看起来可能不是很有用。可能最常见的用例是，您希望对一个不断检查资源是否存在的函数进行速率限制 。 @slow_down decorator在调用被修饰的函数之前会暂停一秒钟</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">slow_down</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="s">"""Sleep 1 second before calling the function"""</span>
    <span class="o">@</span><span class="n">functools</span><span class="p">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper_slow_down</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">time</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper_slow_down</span>

<span class="o">@</span><span class="n">slow_down</span>
<span class="k">def</span> <span class="nf">countdown</span><span class="p">(</span><span class="n">from_number</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">from_number</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Liftoff!"</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">from_number</span><span class="p">)</span>
        <span class="n">countdown</span><span class="p">(</span><span class="n">from_number</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>   
</code></pre></div></div>

<p>来看下@slow_down装饰器的效果，你需要自己运行跑下</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">countdown</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="mi">3</span>
<span class="mi">2</span>
<span class="mi">1</span>
<span class="n">Liftoff</span><span class="err">!</span>  
</code></pre></div></div>

<p>countdown()是一个递归函数。也就是说，它是一个调用自身的函数 。</p>

<h4 id="注册插件">注册插件</h4>

<p>装饰器不是必须要修饰被装饰的函数(这句话不太好翻译，看下面的例子理解起来很容易)，它还可以简单地注册一个函数，并将其解包返回，例如，可以使用它来创建一个轻量级插件体系结构:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">random</span>
<span class="n">PLUGINS</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="s">"""Register a function as a plug-in"""</span>
    <span class="n">PLUGINS</span><span class="p">[</span><span class="n">func</span><span class="p">.</span><span class="n">__name__</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span>
    <span class="k">return</span> <span class="n">func</span>

<span class="o">@</span><span class="n">register</span>
<span class="k">def</span> <span class="nf">say_hello</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s">"Hello </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s">"</span>

<span class="o">@</span><span class="n">register</span>
<span class="k">def</span> <span class="nf">be_awesome</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s">"Yo </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s">, together we are the awesomest!"</span>

<span class="k">def</span> <span class="nf">randomly_greet</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="n">greeter</span><span class="p">,</span> <span class="n">greeter_func</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">PLUGINS</span><span class="p">.</span><span class="n">items</span><span class="p">()))</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Using </span><span class="si">{</span><span class="n">greeter</span><span class="si">!r}</span><span class="s">"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">greeter_func</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> 
</code></pre></div></div>

<p>@register装饰器只是在全局PLUGINS 字典中储存了被装饰函数的引用。注意你不需要在例子中写内部函数或者使用@functools.wraps ，因为返回的是一个未经过修改的初始函数</p>

<p>randomly_greet()函数在注册函数中随机选择一个使用。注意PLUGINS字典已经包含了对注册为插件的每个函数对象的引用:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="o">&gt;&gt;&gt;</span> <span class="n">PLUGINS</span>
<span class="p">{</span><span class="s">'say_hello'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">function</span> <span class="n">say_hello</span> <span class="n">at</span> <span class="mh">0x7f768eae6730</span><span class="o">&gt;</span><span class="p">,</span>
 <span class="s">'be_awesome'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">function</span> <span class="n">be_awesome</span> <span class="n">at</span> <span class="mh">0x7f768eae67b8</span><span class="o">&gt;</span><span class="p">}</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">randomly_greet</span><span class="p">(</span><span class="s">"Alice"</span><span class="p">)</span>
<span class="n">Using</span> <span class="s">'say_hello'</span>
<span class="s">'Hello Alice'</span>
</code></pre></div></div>

<p>这个插件的主要用处在于不需要再单独维护一个插件列表。这个列表在插件注册时自动创建，使得添加一个新插件变得很简单，只需定义函数并用@register装饰即可。</p>

<p>如果你对python中的globals()函数熟悉，你可能会看到一些和我们的插件结构相似之处。globals()可以访问当前作用于的所有全局变量</p>

<p>包括我们的插件</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="nb">globals</span><span class="p">()</span>
<span class="p">{...,</span> <span class="c1"># Lots of variables not shown here.
</span> <span class="s">'say_hello'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">function</span> <span class="n">say_hello</span> <span class="n">at</span> <span class="mh">0x7f768eae6730</span><span class="o">&gt;</span><span class="p">,</span>
 <span class="s">'be_awesome'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">function</span> <span class="n">be_awesome</span> <span class="n">at</span> <span class="mh">0x7f768eae67b8</span><span class="o">&gt;</span><span class="p">,</span>
 <span class="s">'randomly_greet'</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">function</span> <span class="n">randomly_greet</span> <span class="n">at</span> <span class="mh">0x7f768eae6840</span><span class="o">&gt;</span><span class="p">}</span>
</code></pre></div></div>

<p>使用@register 装饰器，可以创建感兴趣的变量管理列表，有效地从globals()中筛选出一些函数</p>

<h4 id="用户是否登录">用户是否登录</h4>

<p>在继续讨论一些更有趣的装饰器之前，让我们在最后一个示例中演示通常在处理web框架时使用的装饰器。在这个例子中，我们使用Flask去设置一个/secret web页面，这个页面只对登录用户或者其他有权限的用户展示</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">redirect</span><span class="p">,</span> <span class="n">url_for</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">login_required</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="s">"""Make sure user is logged in before proceeding"""</span>
    <span class="o">@</span><span class="n">functools</span><span class="p">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper_login_required</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">g</span><span class="p">.</span><span class="n">user</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">redirect</span><span class="p">(</span><span class="n">url_for</span><span class="p">(</span><span class="s">"login"</span><span class="p">,</span> <span class="nb">next</span><span class="o">=</span><span class="n">request</span><span class="p">.</span><span class="n">url</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper_login_required</span>

<span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">route</span><span class="p">(</span><span class="s">"/secret"</span><span class="p">)</span>
<span class="o">@</span><span class="n">login_required</span>
<span class="k">def</span> <span class="nf">secret</span><span class="p">():</span>
    <span class="p">...</span>    
</code></pre></div></div>

<p>虽然这里演示了如何对web框架添加身份验证吗，但通常不应该自己编写这些类型的装饰器。对于Flask可以使用Flask-login扩展，这里的功能更丰富也更加安全</p>

<p>有想象力的装饰器
到目前为止，你已经看到了如何创建简单的装饰器并且非常了解什么是装饰器以及它们是如何工作的。请从这篇文章中休息一下，练习学到的一切。</p>

<p>在本教程的第二部分中，我们将探索更高级的特性，包括如何使用以下特性:</p>
<ul>
  <li>在类上使用装饰器(装饰类)</li>
  <li>在一个函数上应用多个装饰器</li>
  <li>带参数的装饰器</li>
  <li>可以选择是否接收参数的装饰器</li>
  <li>带状态的装饰器</li>
  <li>类装饰器</li>
</ul>]]></content><author><name>Your Name</name></author><category term="Python" /><summary type="html"><![CDATA[Python装饰器介绍]]></summary></entry><entry><title type="html">路由交换 - RIP - 01</title><link href="/rs-rip-01/" rel="alternate" type="text/html" title="路由交换 - RIP - 01" /><published>2022-08-21T00:00:00+08:00</published><updated>2022-08-21T00:00:00+08:00</updated><id>/rs-rip-01</id><content type="html" xml:base="/rs-rip-01/"><![CDATA[<p>RIP 笔记</p>

<h3 id="rip的基本原理与实现">RIP的基本原理与实现</h3>

<p>RIP的端口: UDP 520</p>

<h4 id="rip的计时器和稳定性">RIP的计时器和稳定性</h4>

<ul>
  <li>启动后，每隔30s从启动协议的接口发送更新信息，包含整个路由表。更新的目的地址是广播地址 255.255.255.255</li>
  <li>rip也使用无效计时器，也成为限时计时器，初始化时间为180s，如果超过这个时间还没有收到这条路有的更新，就将这条路有的跳数设置为16跳</li>
  <li>另一种计时器称为垃圾收集或刷新计时器，一般比限时计时器长240-60s，如果到时，这条路由就会被宣告为一条度量值为不可达的路由</li>
  <li>第三个计时器是抑制计时器。如果一条路由更新的跳数大于路由表已记录的该路由的跳数，那么将会引起该路由进入180s的抑制状态阶段</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>timers basic update invalid holddown flush
</code></pre></div></div>

<blockquote>
  <p>默认不建议更改计时器，如果一台路由器更改，那这个RIP域中的路由器都需要更改</p>
</blockquote>

<p>RIP使用带毒性逆转的水平分隔和触发更新，触发更新只有在路由的度量值发生变化时产生，触发更新会有一个1-5s的随机计时器，以免产生触发更新风暴</p>

<h4 id="rip的消息格式">RIP的消息格式</h4>

<p><img src="/assets/images/rip/r01.png" /></p>

<h4 id="请求消息类型">请求消息类型</h4>

<p>可以请求整个路由表信息，也可以请求某些具体路由信息</p>

<h4 id="有类别路由选择">有类别路由选择</h4>

<p>RIP的管理距离为120
数据包选路过程</p>
<ul>
  <li>读出目的地址的网络部分(A\B\C类)，查看在路由表中是否有匹配的条目，没有则丢弃，同时发出一个ICMP目的不可达的消息给源</li>
  <li>如果存在匹配该数据包网络部分的主类网络，会在路由器的主网络的子网中查找，找到匹配则转发，否则发送ICMP目的不可达消息</li>
</ul>

<p>有类别路由选择:直连的子网络</p>

<p><img src="/assets/images/rip/r02.png" /></p>

<ul>
  <li>192.168.35.3数据包进入路由器，路由器没有发现192.168.35.0的条目，该数据包则丢弃</li>
  <li>172.25.33.89数据包进入路由器，路由器中有一个B类172.25.0.0条目，但没有发现172.25.0.0的子网条目，该数据包丢弃</li>
  <li>172.25.153.220数据包进入路由器，路由器中有172.25.0.0的条目并找到172.25.153.0的条目，该数据包被转发到172.25.15.2</li>
</ul>

<p><strong>有类别路由选择:在边界路由器上汇总路由</strong></p>

<p>如果没有和某个目的网络直连，那么该路由器仅仅需要一条路由指向直接相连的路由器</p>

<h4 id="有类别路由选择小结">有类别路由选择:小结</h4>
<ul>
  <li>特点：在通告目的地址时无法通告它的掩码</li>
  <li>如果目的地址是一个和路由器直接相连的主网络成员，那么该网络的路由器接口上配置的子网掩码将被用来确定目的地址的子网</li>
  <li>如果目的地址不是一个和路由器直接相连的主网络的成员，那么路由器会尝试匹配A\B\C类的主网络号</li>
</ul>

<h3 id="配置rip">配置RIP</h3>

<ul>
  <li>router rip</li>
  <li>network 指定主网络</li>
</ul>

<h4 id="被动接口">被动接口</h4>
<p><img src="/assets/images/rip/r03.png" /></p>

<h4 id="配置单播更新">配置单播更新</h4>
<p><img src="/assets/images/rip/r04.png" /></p>

<p>为了防止广播更新，也需要加上一条passive-interface命令</p>

<h4 id="不连续的子网">不连续的子网</h4>

<p><img src="/assets/images/rip/r05.png" /></p>

<p><img src="/assets/images/rip/r06.png" /></p>

<h4 id="控制rip的度量">控制RIP的度量</h4>
<p>可以使用offset-list来改变路由的度量值</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>offset-list <span class="o">{</span>access-list-number | name<span class="o">}</span> <span class="o">{</span><span class="k">in</span> | out<span class="o">}</span> offset <span class="o">{</span><span class="nb">type </span>number<span class="o">}</span>
</code></pre></div></div>

<p><img src="/assets/images/rip/r07.png" /></p>

<p>将serial0的入方向的10.33.0.0的路由加大2跳</p>

<h4 id="最小化更新信息的影响">最小化更新信息的影响</h4>
<ul>
  <li>调整路由选择协议的计时器频率</li>
  <li>配置触发扩展特性消除周期性的RIP更新</li>
</ul>

<p>链路上的两台路由器都必须配置ip rip triggered命令，仅仅发送路由表最初的交换信息和路由表发生变化使得更新信息，只在串行链路上生效</p>]]></content><author><name>Your Name</name></author><category term="RS" /><summary type="html"><![CDATA[RIP 笔记]]></summary></entry><entry><title type="html">路由交换 - OSPF - 01</title><link href="/rs-ospf-01/" rel="alternate" type="text/html" title="路由交换 - OSPF - 01" /><published>2022-08-20T00:00:00+08:00</published><updated>2022-08-20T00:00:00+08:00</updated><id>/rs-ospf-01</id><content type="html" xml:base="/rs-ospf-01/"><![CDATA[<p>OSPF备忘信息</p>

<h2 id="基础术语">基础术语</h2>

<h3 id="链路状态协议的特点">链路状态协议的特点</h3>
<ul>
  <li>快速适应网络变化</li>
  <li>在网络发生变化时发送触发更新</li>
  <li>以较低的频率（如每隔30分钟）发送定期更新，这被称为链路状态刷新</li>
</ul>

<h3 id="每台路由器都必须记录下述信息">每台路由器都必须记录下述信息</h3>
<ul>
  <li>直接相连的邻接路由器</li>
  <li>网络或区域内的其他路由器及其连接的网络</li>
  <li>前往每个目的地的最佳路径</li>
</ul>

<h3 id="ospf使用的各种表">OSPF使用的各种表</h3>
<ul>
  <li>OSPF邻居表=邻接关系数据库</li>
  <li>OSPF拓扑表=OSPF拓扑数据库=LSDB</li>
  <li>路由表=转发数据库</li>
</ul>

<h3 id="区域结构">区域结构</h3>
<ul>
  <li>内部路由器：所有接口都位于同一个区域中的路由器，同一区域中所有内部路由器的LSDB都相同</li>
  <li>骨干路由器：位于骨干区域0边缘的路由器，至少有一个接口与区域0相连。骨干路由器在维护OSPF路由信息时采用的步骤和算法与内部路由器相同</li>
  <li>区域边界路由器（ABR）：连接多个区域的路由器，为其连接的每个区域维护一个LSDB，并路由前往/来自其他区域的数据流</li>
  <li>自治系统边界路由器（ASBR）：至少有一个接口与其他域（如另一个OSPF自治系统或使用增强内部网关协议[EIGRP]的域）相连</li>
</ul>

<p><img src="/assets/images/ospf/01.png" /></p>

<p>在多路访问广播环境中，每个网段都有独立的DR和BDR
在路由器链路通告中，以链路开销的方式通告它。默认的OSPF开销如下</p>
<ul>
  <li>56kbit/s 的串行链路：默认开销为1785</li>
  <li>64kbit/s 的串行链路：默认开销为1562</li>
  <li>T1（1.544Mbit/s 的串行链路）：默认开销为64</li>
  <li>E1（2.048Mbit/s 的串行链路）：默认开销为48</li>
  <li>以太网：默认开销为10</li>
  <li>快速以太网：默认开销为1</li>
  <li>FDDI：默认开销为1</li>
  <li>ATM：默认开销为1</li>
</ul>

<p><img src="/assets/images/ospf/02.png" /></p>

<p><img src="/assets/images/ospf/03.png" /></p>

<p><img src="/assets/images/ospf/04.png" /></p>

<p><img src="/assets/images/ospf/05.png" /></p>

<p>这5种OSPF分组都被直接封装到IP分组的有效负载中，OSPF分组不使用传输控制协议（TCP）和用户数据报协议（UDP）</p>

<h3 id="邻接路由器要建立邻接关系hello分组的如下字段必须匹配">邻接路由器要建立邻接关系，Hello分组的如下字段必须匹配</h3>
<ul>
  <li>Hello 间隔</li>
  <li>失效间隔</li>
  <li>区域ID</li>
  <li>身份验证密码</li>
  <li>末节区域标记</li>
</ul>

<p><strong>要让路由器通过接口建立邻接关系，接口的主IP地址必须位于同一个子网且子网掩码相同，接口的最大传输单元（MTU）也必须匹配</strong></p>

<h3 id="ospf-邻接关系状态">OSPF 邻接关系状态</h3>
<ul>
  <li>Down：没有检测到活动邻居</li>
  <li>Init：收到Hello分组</li>
  <li>双向：路由器在其收到的Hello分组中看到了自己的路由器ID</li>
  <li>预启动：确定了主/从角色</li>
  <li>交换：发送DBD（LSDB摘要）</li>
  <li>加载：交换LSR和LSU以填充LSDB</li>
  <li>完全邻接：邻居处于完全邻接状态</li>
</ul>

<p><strong>如果邻居是通过 NBMA 接口（如帧中继）相连的，OSPF 还可能在 Init 状态前进入Atempt状态</strong></p>

<h3 id="满足如下条件时lsa将被视为更新的">满足如下条件时，LSA将被视为更新的</h3>
<ul>
  <li>序列号更大</li>
  <li>校验和更大（如果序列号相同）</li>
  <li>年龄等于maxage（这表明LSA被抑制）</li>
  <li>LS 年龄小得多</li>
</ul>

<p><img src="/assets/images/ospf/06.png" /></p>

<p><img src="/assets/images/ospf/07.png" /></p>

<p><img src="/assets/images/ospf/08.png" /></p>

<h2 id="常规配置">常规配置</h2>

<h3 id="配置ospf进程的步骤">配置OSPF进程的步骤</h3>

<ul>
  <li>router ospf process-id [vrf vpn-name]在路由器上启用OSPF 进程</li>
  <li>network ip address wildcard-mask area area-id 指定路由器的哪些接口将参与OSPF进程以及网络所属的OSPF区域</li>
</ul>

<p><img src="/assets/images/ospf/9.png" /></p>

<p><img src="/assets/images/ospf/10.png" /></p>

<p><strong>接口配置命令 ip ospf process-id area area-id [secondaries none],优先于命令network area</strong></p>

<p><img src="/assets/images/ospf/11.png" /></p>

<p><img src="/assets/images/ospf/12.png" /></p>

<p>区域OSPF配置示例</p>

<p><img src="/assets/images/ospf/13.png" /></p>

<h3 id="路由器id">路由器ID</h3>
<ul>
  <li>router-id ip-address</li>
  <li>路由器ID设置为最大的活动环回接口地址</li>
  <li>最大的活动物理接口IP地址</li>
</ul>

<p><strong>OSPF数据库使用路由器ID来唯一地标识网络中的每台路由器,因此在整个OSPF自治系统中，路由器ID都不能重复</strong></p>

<p><img src="/assets/images/ospf/14.png" /></p>

<h3 id="查看ospf的运行">查看OSPF的运行</h3>
<ul>
  <li>show ip ospf显示OSPF路由器ID（RID）、OSPF定时器、执行了 SPF 算法多少次以及LSA信息。</li>
  <li>show ip ospf interface [type number] [ brief]：查看接口是否被加入到正确的区域中；该命令还显示各种定时器（包括Hello间隔）和邻接关系</li>
  <li>show ip ospf neighbor detail [type number] [neighbor-id] [detail]：显示一个邻居列表，包括它们的OSPF路由器ID、OSPF优先级、邻接关系状态（如init、预启动或完全邻接）及失效定时器</li>
  <li>show ip route ospf：显示路由器知道的 OSPF 路由，它是判断本地路由器和互连网络其他部分之间的连接性的最佳方法之一。该命令还有可选参数，让您能够进一步指定要显示的信息，如OSPF进程ID</li>
  <li>show ip protocols：显示 IP 路由协议参数，包括定时器、过滤器、度量值、网络及路由器的其他信息</li>
  <li>debug ip ospf events显示与OSPF相关的事件，如建立邻接关系、扩散信息、DR选举和SPF计算</li>
</ul>

<p><img src="/assets/images/ospf/15.png" /></p>

<p><img src="/assets/images/ospf/16.png" /></p>

<p><img src="/assets/images/ospf/17.png" /></p>

<p><img src="/assets/images/ospf/18.png" /></p>

<p><img src="/assets/images/ospf/19.png" /></p>

<h2 id="网络类型">网络类型</h2>

<h3 id="dr和bdr">DR和BDR</h3>

<p><img src="/assets/images/ospf/20.png" /></p>

<ul>
  <li>优先级最高的路由器成为DR</li>
  <li>优先级次高的路由器成为BDR</li>
  <li>接口的OSPF优先级默认为1</li>
  <li>优先级为0的路由器不能成为DR或BDR</li>
  <li>优先级更高的路由器加入网络时，并不会抢占DR或BDR</li>
</ul>

<p><strong>DR 概念是链路级的，牢记这一点很重要。在多路访问广播环境中，每个网段都有自己的DR和BDR</strong></p>

<p>要指定将多路访问链路上的哪个路由器接口用做DR或BDR，可使用接口配置命令ip ospf priority number。默认的优先级为 0，其取值范围为0～255
DR和BDR的价值体现在以下方面</p>

<ul>
  <li>减少路由更新数据流</li>
  <li>管理链路状态同步</li>
</ul>

<p><img src="/assets/images/ospf/21.png" /></p>

<p><img src="/assets/images/ospf/22.png" /></p>

<h2 id="lsa">LSA</h2>

<p><img src="/assets/images/ospf/30.png" />
<img src="/assets/images/ospf/31.png" /></p>

<ul>
  <li>1类（路由器LSA）：每台路由器都生成有关其所属区域的路由器链路通告。路由器链路通告描述了路由器连接到区域的链路的状态，只在区域内扩散。每种LSA的报头都是20字节，其中一个字段是链路状态ID。对于1类LSA，该字段的值为最初发送LSA的路由器的ID。</li>
  <li>2类（网络LSA）：DR为多路访问网络生成的网络链路通告，描述了特定多路访问网络上的一组路由器。网络链路通告在网络所在的区域内扩散。2类LSA的链路状态ID为DR的IP接口地址。</li>
  <li>3类和4类（汇总LSA）：汇总链路通告是由ABR生成的，描述了下述区域间路由
    3类 LSA描述了前往网络的路由（还可能包含汇总路由）
    4类 LSA描述了前往ASBR的路由</li>
  <li>5类（自治系统外部LSA）：自治系统外部链路状态通告是由ASBR生成的，描述了前往自治系统外部的目标网络的路由，被扩散到除各种末节区域外的其他所有地方。5类LSA的链路状态ID为外部网络的地址。</li>
  <li>6 类（多播 OSPF LSA）：这些 LSA 用于 OSPF 多播应用中</li>
  <li>7类（用于NSSA的LSA）：这些LSA用于NSSA中，将在本章后面的“配置NSSA”一节介绍</li>
  <li>8类（BGP的外部属性LSA）：这些LSA用于互联OSPF和BGP</li>
  <li>9、10和11类（不透明LSA）：这些LSA用于升级到OSPF，旨在在OSPF域中分发应用程序特定的信息。例如，Cisco使用9类不透明LSA在OSPF中实现MPLS流量工程。分发不透明LSA时，使用的是标准的LSDB扩散机制。这3种LSA的扩散范围各不相同，9类LSA只在本地网络或子网内扩散，10类LSA只在当前区域内扩散，而11类LSA扩散到整个自治系统（与5类LSA相同）。不透明LSA是在 RFC 5250（The OSPF Opaque LSA Option）中定义的。</li>
</ul>

<p><strong>在Cisco路由器中，OSPFv2不支持6类和8类LSA</strong></p>

<h3 id="1类lsa">1类LSA</h3>
<p>路由器通告1类LSA，这种LSA被扩散到当前区域内的所有路由器，1类LSA指出了每条链路的OSPF开销以及路由器是不是ABR或ASBR</p>

<p><img src="/assets/images/ospf/32.png" /></p>

<p><img src="/assets/images/ospf/33.png" /></p>

<h3 id="2类lsa">2类LSA</h3>
<p>2 类 LSA 是为区域中每个中转的广播或 NBMA 网络生成的，中转网络至少与两台OSPF 路由器直接相连</p>

<p><img src="/assets/images/ospf/34.png" /></p>

<h3 id="3类lsa">3类LSA</h3>
<p>3类（汇总）LSA由ABR生成，它将一个区域内的网络通告给OSPF自治系统中的其他区域</p>

<p><img src="/assets/images/ospf/35.png" /></p>

<h3 id="4类lsa">4类LSA</h3>
<p>仅当区域中有ASBR时，ABR才会生成4类（汇总）LSA。4类LSA标识ASBR，并提供一条前往该ASBR的路由</p>

<p><img src="/assets/images/ospf/36.png" /></p>

<h3 id="5类lsa">5类LSA</h3>
<p>5类LSA描述了前往OSPF自治系统外的网络的路由，它由ASBR发送并被扩散到整个AS</p>

<p><img src="/assets/images/ospf/37.png" /></p>

<p><img src="/assets/images/ospf/38.png" /></p>

<h3 id="ospf的路由表和路由类型">OSPF的路由表和路由类型</h3>

<p><img src="/assets/images/ospf/39.png" /></p>

<p><img src="/assets/images/ospf/40.png" /></p>

<h3 id="计算o-e1-和-o-e2的开销">计算O E1 和 O E2的开销</h3>

<p><img src="/assets/images/ospf/41.png" /></p>

<ul>
  <li>对于O E1 外部路由，开销为外部开销加上分组经过的每条链路的内部开销。多个ASBR将同一条外部路由通告到同一个自治系统中时，应使用这种类型，以避免次优路由</li>
  <li>O E2路由的开销总是只包含外部开销。只有一台 ASBR将外部路由通告到自治系统中时，使用这种类型</li>
</ul>

<h3 id="lsdb的过载保护">LSDB的过载保护</h3>

<p><img src="/assets/images/ospf/42.png" /></p>

<h2 id="特殊区域">特殊区域</h2>

<h3 id="标准区域">标准区域</h3>
<p>这是默认的区域类型，它接受链路更新、汇总路由和外部路由。</p>

<h3 id="骨干区域">骨干区域</h3>
<p>骨干区域为区域0，其他区域都与之相连以交换和路由信息。OSPF骨干区域具有标准OSPF区域的所有特征</p>

<h3 id="末节区域">末节区域</h3>
<p>这种区域不接受关于自治系统外部的路由的信息，如来自非 OSPF 路由器的路由。需要路由到自治系统外部的网络时，路由器使用默认路由（用0.0.0.0表示）。末节区域不能包含ASBR（除非ABR也是ASBR）</p>

<h3 id="绝对末节区域">绝对末节区域</h3>
<p>这种 Cisco 专用的区域不接受来自自治系统外部的路由以及来自自治系统中其他区域的汇总路由。需要将分组发送到区域外的网络时，路由器使用默认路由。绝对末节区域中不能有ASBR（除非ABR也是ASBR）</p>

<h3 id="nssa">NSSA</h3>
<p>NSSA 是对OSPF RFC的补充。这种区域定义了一种特殊的 LSA——7类LSA。NSSA具有末节区域的优点，它们不接受有关自治系统外部的路由的信息，而使用默认路由前往外部网络。然而，NSSA可以包含ASBR，这违反了关于末节区域的规则。</p>

<h3 id="绝对末节nssa">绝对末节NSSA</h3>
<p>Cisco路由器也允许将区域配置为绝对末节NSSA，这种区域可包含 ASBR，但不接受外部路由和来自其他区域的汇总路由。它使用默认路由前往区域外的网络。</p>

<p><img src="/assets/images/ospf/70.png" /></p>

<p><img src="/assets/images/ospf/71.png" /></p>

<h3 id="配置末节区域">配置末节区域</h3>

<p><img src="/assets/images/ospf/72.png" /></p>

<p>步骤</p>
<ul>
  <li>在区域内的所有路由器上配置OSPF</li>
  <li>在区域中所有的路由器上配置路由器配置命令area area-id stub</li>
  <li>（可选）在ABR中配置默认路由的开销</li>
</ul>

<p><img src="/assets/images/ospf/73.png" /></p>

<p><img src="/assets/images/ospf/74.png" /></p>

<h3 id="配置绝对末节区域cisco专有">配置绝对末节区域(CISCO专有)</h3>
<p>5类外部LSA以及3类和4类汇总LSA（区域间路由）不能传播到绝对末节区域中</p>

<p><img src="/assets/images/ospf/75.png" /></p>

<p>步骤</p>
<ul>
  <li>在区域内的所有路由器上配置OSPF</li>
  <li>在区域中所有的路由器上配置路由器配置命令area area-id stub</li>
  <li>在ABR上，在命令area area-id stub中指定关键字no-summary，这让区域变成绝对末节的</li>
  <li>(可选)在ABR上，配置默认路由的开销</li>
</ul>

<p><img src="/assets/images/ospf/76.png" /></p>

<p><img src="/assets/images/ospf/77.png" /></p>

<p><img src="/assets/images/ospf/78.png" /></p>

<h3 id="ospf的路由表">OSPF的路由表</h3>

<p><img src="/assets/images/ospf/79.png" /></p>

<p>（没有任何末节配置的）标准区域中OSPF路由器的路由表，其中包括区域内路由（O）、区域间路由（O IA）和外部路由（O E1和 O E2）</p>

<p><img src="/assets/images/ospf/80.png" /></p>

<p>配置为末节区域后的路由表，其中包含区域内路由（O）和区域间路由（O IA），但不包含外部路由（O E1和 O E2），因为这些路由被区域间默认路由（O*IA）取代</p>

<p><img src="/assets/images/ospf/81.png" /></p>

<p><img src="/assets/images/ospf/82.png" /></p>

<p>ABR上执行汇总（区域仍被配置为末节的）后的路由表，其中包含区域内路由（O）和区域间汇总路由（O IA，这里将路由 172.31.11.1 和 172.31.11.2 汇总成了172.31.11.0/24），但不包含外部路由，（O E1 和 O E2），因为这些路由被区域间默认路由（O*IA）取代</p>

<p><img src="/assets/images/ospf/83.png" /></p>

<p>绝对末节区域后的路由表。注意到在绝对末节区域中，路由器的路由表最小，其中只包含区域内路由（O），而不包含区域间路由（O IA）和外部路由（O E1和 O E2），因为用区域间默认路由（O*IA）取代了这些路由</p>

<h3 id="配置nssa">配置NSSA</h3>
<p>将路由重分发到NSSA中时，将创建一种特殊的LSA——7类LSA，这种LSA只能出现在NSSA中，它是由NSSA ASBR生成的，而NSSA ABR将其转换为5类LSA并在OSPF域中传播。7类LSA的LSA报头中有一个传播（P）位，用于避免在NSSA和骨干区域之间循环传播它。7类LSA的格式与5类LSA相同。</p>

<p><img src="/assets/images/ospf/84.png" /></p>

<p>步骤</p>
<ul>
  <li>在区域内的所有路由器上配置OSPF</li>
  <li>在区域内的所有路由器上配置路由器配置命令 area area-id nssa [no-redistr-ibution] [default-information-originate] [metric metric-value] [metric-type type-value]而不是 area area-id stub</li>
  <li>(可选)ABR上配置默认路由的开销。</li>
</ul>

<p><img src="/assets/images/ospf/85.png" /></p>

<p><img src="/assets/images/ospf/86.png" /></p>

<p><img src="/assets/images/ospf/87.png" /></p>

<h3 id="ospf-nssa-的-lsdb">OSPF NSSA 的 LSDB</h3>

<p><img src="/assets/images/ospf/88.png" /></p>

<p><img src="/assets/images/ospf/89.png" /></p>

<p><img src="/assets/images/ospf/90.png" /></p>

<p>注意到这里没有使用ASBR汇总（4类）LSA，因为5类外部LSA来自ABR而不是ASBR，而ABR在区域0内。如果区域为标准区域，ASBR将生成5类LSA，而ABR将创建4类LSA，以告诉其他路由器如何前往ASBR。</p>

<h3 id="配置绝对末节nssacisco专有">配置绝对末节NSSA(CISCO专有)</h3>
<p>步骤</p>
<ul>
  <li>在区域内的所有路由器上配置OSPF</li>
  <li>在区域内的所有路由器上配置路由器配置命令 area area-id nssa [no-redistr-ibution] [default-information-originate] [metric metric-value] [metric-type type-value]而不是area area-id stub</li>
  <li>在ABR上，在命令area area-id nssa中添加关键字no-summary</li>
  <li>(可选)在ABR上配置默认路由的开销</li>
</ul>

<p><img src="/assets/images/ospf/91.png" /></p>

<p><img src="/assets/images/ospf/92.png" /></p>

<p><img src="/assets/images/ospf/93.png" /></p>

<p>#各种OSPF区域示例</p>

<p><img src="/assets/images/ospf/94.png" /></p>

<p>区域11为标准区域，它接受链路更新、汇总和外部路由。
区域14为末节区域，它不接受4类汇总LSA和5类外部LSA，但接受3类汇总LSA。
区域12为绝对末节区域，它不接受汇总LSA和外部LSA。
区域10为NSSA，它不接受4类汇总LSA和5类外部LSA，但接受3类汇总LSA且可以有ASBR。
区域13为绝对末节NSSA，它不接受汇总LSA和外部LSA，但可以有ASBR</p>

<p><img src="/assets/images/ospf/95.png" /></p>

<h3 id="默认路由">默认路由</h3>
<p>在标准区域中，路由器不生成默认路由 ，可使用命令default-information originate [always] [metric metric-value]  [metric-typetype-value] [route-map map-name]。默认情况下，该命令生成一条E2 路由，其链路状态ID为0.0.0.0，网络掩码为0.0.0.0，导致路由器成为ASBR。
末节区域和绝对末节区域，与末节区域相连的ABR将生成一个链路状态ID为0.0.0.0的汇总LSA，即使该ABR没有默认路由
对于NSSA，默认路由是由与之相连的ABR生成的，但默认情况下不会生成。要让ABR生成默认路由，可使用命令area area-idnssa default-information-originate。ABR将生成一个链路状态ID为0.0.0.0的7类LSA。如果只想将路由导入到标准区域中，而不想将其导入到NSSA中，可在NSSA ABR上使用选项no-redistribution。绝对末节NSSA的ABR自动生成一条默认路由</p>

<h2 id="身份认证">身份认证</h2>

<h3 id="配置简单密码身份验证">配置简单密码身份验证</h3>

<p>步骤</p>
<ul>
  <li>使用接口配置命令 ip ospf authentication-key password指定一个密码</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>使用接口配置命令 ip ospf authentication [message-digest</td>
          <td>null] md5指定身份验证类型</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<p>如果要使用简单身份验证，可在配置命令 area authentication 时不指定任何参数。</p>

<p><img src="/assets/images/ospf/100.png" /></p>

<p>示例</p>

<p><img src="/assets/images/ospf/101.png" /></p>

<p><img src="/assets/images/ospf/102.png" /></p>

<p><img src="/assets/images/ospf/103.png" /></p>

<p>验证</p>

<p><img src="/assets/images/ospf/104.png" /></p>

<p><img src="/assets/images/ospf/105.png" /></p>

<p>排障</p>
<ul>
  <li>没有在两台路由器上都配置身份验证</li>
  <li>两台路由器配置的身份验证类型不同</li>
  <li>两台路由器配置的密码不同</li>
</ul>

<p>在虚链路上配置OSPF简单密码身份验证</p>

<p><img src="/assets/images/ospf/106.png" /></p>

<h3 id="md5身份验证的配置-验证-和故障排除">MD5身份验证的配置 验证 和故障排除</h3>

<p><img src="/assets/images/ospf/107.png" /></p>

<p><img src="/assets/images/ospf/108.png" /></p>

<p>验证</p>

<p><img src="/assets/images/ospf/109.png" /></p>

<p>排障
简单密码身份验证一样，命令 debug ip ospf obj 显示与 OSPF 邻接关系相关的事件，对于排除MD5身份验证故障很有帮助</p>

<p><img src="/assets/images/ospf/110.png" /></p>

<p><img src="/assets/images/ospf/111.png" /></p>

<h2 id="总结">总结</h2>

<h3 id="ospf-使用的表">OSPF 使用的表</h3>
<p>邻居表（也叫邻接关系数据库）、拓扑表（也叫拓扑数据库[LSDB]）和路由表（也叫转发数据库）</p>

<h3 id="由两层组成ospf分层区域结构">由两层组成OSPF分层区域结构</h3>
<p>骨干区域0和常规区域。</p>

<h3 id="各类型的ospf路由器">各类型的OSPF路由器</h3>
<ul>
  <li>内部路由器</li>
  <li>骨干路由器</li>
  <li>ABR</li>
  <li>ASBR。</li>
</ul>

<h3 id="ospf-路由器如何使用-hello-协议建立邻接关系">OSPF 路由器如何使用 Hello 协议建立邻接关系</h3>
<p>两台路由器使用 Hello 分组建立邻接关系后，它们交换LSA并确认收到了邻接路由器的LSA，以同步LSDB。在点到点链路上，路由器彼此建立完全邻接关系，而在 LAN 链路上，路由器只与DR和BDR建立完全邻接关系。</p>

<h3 id="cisco-路由器如何计算-ospf-度量值">Cisco 路由器如何计算 OSPF 度量值</h3>
<p>默认情况下，根据链路带宽计算度量值；如果有速度超过 100Mbit/s 的接口，应在所有路由器上都配置路由器配置命令<strong>auto-cost reference-bandwidth ref-bw</strong>。要覆盖默认开销，可使用接口配置命令 <strong>ip ospf cost interface-cost</strong>手工指定开销。</p>

<h3 id="5-种类型的-ospf分组">5 种类型的 OSPF分组</h3>
<p>Hello、DBD、LSR、LSU 和LSAck</p>
<ul>
  <li>Hello 分组用于发现邻居和建立邻接关系</li>
  <li>DBD用于同步LSDB</li>
  <li>LSR用于请求特定的链路状态记录</li>
  <li>LSU 用于发送请求的记录</li>
  <li>LSAck 用于确认收到了其他类型的分组
    <blockquote>
      <p>OSPF 分组是在IP分组中发送的，使用的协议号为89。</p>
    </blockquote>
  </li>
</ul>

<h3 id="可能经历的ospf-邻接关系状态">可能经历的OSPF 邻接关系状态</h3>
<p>Down、Atempt、Init、双向、预启动、交换、加载和完全邻接。</p>

<h3 id="在邻接路由器上必须匹配的5个hello分组字段">在邻接路由器上，必须匹配的5个Hello分组字段</h3>
<ul>
  <li>Hello间隔</li>
  <li>失效间隔</li>
  <li>区域ID</li>
  <li>身份验证密码</li>
  <li>末节区域标记。</li>
</ul>

<h3 id="规划ospf实施">规划OSPF实施</h3>
<p>包括IP编址方案、网络拓扑和OSPF区域。对于网络中的每台路由器，需要完成的任务包括启用路由协议 OSPF 并指定进程号（可在接口上直接启用，也可使用合适的network命令）、给接口指定正确的区域ID以及给合适的接口配置度量值（这是可选的）。</p>

<h3 id="基本的ospf配置命令">基本的OSPF配置命令</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 全局配置命令 </span>
router ospf process-id。
<span class="c">#接口配置命令 </span>
network ip-address wildcard-mask area area-id 和 ip ospf process-idareaarea-id <span class="o">[</span>secondaries none]。
<span class="c">#接口配置命令</span>
bandwidth kilobits。
<span class="c">#路由器配置命令</span>
router-id ip-address。
<span class="c">#用于查看OSPF运行情况的命令。</span>
show ip ospf。
show ip route。
show ip ospf interface。
show ip ospf neighbor。
show ip route ospf。
show ip protocols。
debug ip ospf events。
debug ip ospf adj。
debug ip ospf packet。
</code></pre></div></div>
<h3 id="如何选择ospf路由器id">如何选择OSPF路由器ID</h3>
<p>路由器配置命令router-id ip-address指定的、最大的活动环回接口IP地址或最大的活动物理接口IP地址。</p>

<h3 id="ospf-定义的三类网络">OSPF 定义的三类网络</h3>
<p>点到点、广播和 NBMA。</p>

<h3 id="如何选举dr和bdr">如何选举DR和BDR</h3>
<p>优先级最高的路由器为DR，优先级次高的路由器为BDR。如果优先级相同，则根据路由器ID来选举。优先级为0的路由器不能成为DR或BDR。优先级是使用接口配置命令 ip ospf prioritynumber 设置的。</p>

<h3 id="可用于nbma网络的5种ospf运行模式">可用于NBMA网络的5种OSPF运行模式</h3>
<p>RFC模式非广播和点到多点以及Cisco模式广播、点到多点非广播和点到点。</p>

<h3 id="lsa类型">LSA类型</h3>
<p>11种 OSPF LSA类型,前5 种是最常用的，它们分别是由每台路由器生成的1类（路由器）、DR生成的2类（网络）、ABR生成的描述区域路由的3类（汇总）、ABR生成的描述前往ASBR的路由的4类（汇总）以及ASBR生成的描述前往外部的路由的5类（外部）。</p>

<h3 id="三种ospf-路由">三种OSPF 路由</h3>
<p>区域内路由（O）、区域间路由（O IA）和外部路由（O E1或OE2）。</p>

<h3 id="使用路由器配置命令">使用路由器配置命令</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>max-lsa maximum-number <span class="o">[</span>threshold-percentage] <span class="o">[</span>warning-only] <span class="o">[</span>ignore-time minutes] <span class="o">[</span>ignore-count countnumber] <span class="o">[</span>reset-time minutes]配置OSPF LSDB过载保护。
</code></pre></div></div>

<h3 id="使用路由器配置命令-1">使用路由器配置命令</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>passive-interface <span class="nb">type </span>number <span class="o">[</span>default]禁止从指定路由器接口向外发送路由协议的路由更新
<span class="c"># 从OSPF 而言，指定接口看起来像末节网络，不通过该接口发送和接收OSPF路由信息。</span>
</code></pre></div></div>

<h3 id="ospf的默认路由">OSPF的默认路由</h3>
<p>在 OSPF 中可使用默认路由，这样就无需知道前往所有目标网络的具体路由。这样做的好处是，路由表和LSDB将小得多，同时又能够到达所有网络。要传播OSPF默认路由，可使用路由器配置命令</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>default-information originate <span class="o">[</span>always] <span class="o">[</span>metric metric-value] <span class="o">[</span>metric-typetype-value] <span class="o">[</span>route-map map-name]。
</code></pre></div></div>

<h3 id="配置路由汇总">配置路由汇总</h3>
<p>可减少占用的CPU周期和LSA扩散，还可缩小LSDB和路由表的规模。OSPF不自动汇总</p>

<p>要在ABR上配置OSPF汇总，可使用路由器配置命令</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>area area-id range address mask <span class="o">[</span>advertise | not-advertise] <span class="o">[</span>cost cost]；
</code></pre></div></div>
<p>要在ASBR 上配置 OSPF 汇总，可使用路由器配置命令</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>summary-address ip-address mask <span class="o">[</span>not-advertise] <span class="o">[</span>tag tag]。
</code></pre></div></div>

<h3 id="ospf-虚链路">OSPF 虚链路</h3>
<p>这是一种用于临时修复骨干故障或将区域连接到骨干的功能。要配置虚链路，可使用路由器配置命令</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>area area-id virtual-link router-id <span class="o">[</span>authentic- ation <span class="o">[</span>message-digest | null]] <span class="o">[</span>hello-interval seconds] <span class="o">[</span>retransmit-interval seconds] <span class="o">[</span>transmit-delay seconds] <span class="o">[</span>dead-interval seconds] <span class="o">[[</span>authentication-key key] | <span class="o">[</span>message-digest-keykey-idmd5key]]；要查看其运行情况，可使用命令 show ip ospf virtual-links。
</code></pre></div></div>

<h3 id="ospf-中定义的多种区域类型">OSPF 中定义的多种区域类型</h3>
<p>标准区域、骨干区域、末节区域、绝对末节区域、NSSA和绝对末节NSSA。要配置末节区域，可使用路由器配置命令</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>area area-id stub；
</code></pre></div></div>
<p>在ABR上配置该命令时，如果指定了关键字<strong>no-summary</strong>，区域将被配置为绝对末节区域。要配置NSSA，应使用路由器配置命令</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>area area-id nssa <span class="o">[</span>no-redistribution] <span class="o">[</span>default-information-originate] <span class="o">[</span>met-ric metric-value] <span class="o">[</span>metric-type type-value] <span class="o">[</span>no-summary]
</code></pre></div></div>
<p>而不要使用命令</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>area area-id stub
</code></pre></div></div>
<p>要将区域配置成绝对末节NSSA，只需在ABR上配置该命令时指定关键字<strong>no-summary</strong>。</p>

<h3 id="ospf-身份验证类型">OSPF 身份验证类型</h3>
<ul>
  <li>null</li>
  <li>简单密码身份验证（也叫明文身份验证）</li>
  <li>MD5 身份验证</li>
  <li>要排除身份验证故障，可使用命令
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>debug ip ospf adj。
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="配置ospf简单密码身份验证的命令">配置OSPF简单密码身份验证的命令</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 接口配置命令 </span>
ip ospf authentication-keypassword。
<span class="c"># 接口配置命令 </span>
ip ospf authentication 和路由器配置命令 area area-id authentication。
<span class="c"># 配置OSPF MD5 身份验证的命令</span>
<span class="c"># 接口配置命令 </span>
ip ospf message-digest-key key-id md5key。
<span class="c">#接口配置命令 </span>
ip ospf authentication message-digest 
<span class="c"># 路由器配置命令 </span>
area area-id authentication message-digest。
</code></pre></div></div>]]></content><author><name>Your Name</name></author><category term="RS" /><summary type="html"><![CDATA[OSPF备忘信息]]></summary></entry><entry><title type="html">pgsql监控</title><link href="/monitor-pgsql/" rel="alternate" type="text/html" title="pgsql监控" /><published>2022-08-19T00:00:00+08:00</published><updated>2022-08-19T00:00:00+08:00</updated><id>/monitor-pgsql</id><content type="html" xml:base="/monitor-pgsql/"><![CDATA[<p>测试pgsql监控</p>

<h3 id="系统">系统</h3>
<p>Centos 7</p>

<h3 id="安装pgsql">安装pgsql</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>yum <span class="nb">install</span> <span class="nt">-y</span> https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm
<span class="nb">sudo </span>yum <span class="nb">install</span> <span class="nt">-y</span> postgresql12-server
<span class="nb">sudo</span> /usr/pgsql-12/bin/postgresql-12-setup initdb
<span class="nb">sudo </span>systemctl <span class="nb">enable </span>postgresql-12
<span class="nb">sudo </span>systemctl start postgresql-12
</code></pre></div></div>

<h3 id="数据库设置">数据库设置</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>su postgres
psql
CREATE USER zbx_monitor WITH PASSWORD <span class="s1">'monitor'</span> INHERIT<span class="p">;</span>
GRANT EXECUTE ON FUNCTION pg_catalog.pg_ls_dir<span class="o">(</span>text<span class="o">)</span> TO zbx_monitor<span class="p">;</span>
GRANT EXECUTE ON FUNCTION pg_catalog.pg_stat_file<span class="o">(</span>text<span class="o">)</span> TO zbx_monitor<span class="p">;</span>
GRANT EXECUTE ON FUNCTION pg_catalog.pg_ls_waldir<span class="o">()</span> TO zbx_monitor<span class="p">;</span>
</code></pre></div></div>

<h3 id="监控配置">监控配置</h3>
<p>监控页面添加主机挂载对应pgsql模板</p>

<h3 id="参考">参考</h3>
<p>https://www.postgresql.org/download/linux/redhat/</p>]]></content><author><name>Your Name</name></author><category term="Monitor" /><summary type="html"><![CDATA[测试pgsql监控]]></summary></entry></feed>